\documentclass[a4paper, 11pt]{article}
\usepackage[a4paper, text={17cm, 24cm}, left={2cm}, top={3cm}]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{times}
\usepackage[czech]{babel}
\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{graphics}
\usepackage{caption}

\title{IOS - Operacni systemy}
\date{}

\begin{document}
%%
%%  TITULNI STRANA
%%
\begin{titlepage}

\begin{center}
\LARGE
\textsc{\Huge Vysoke uceni technicke v Brne}\\
\textsc{\huge Fakulta informacnich technologii}\\
\vspace{\stretch{0.382}}
IOS - Operacni systemy\\[0.4em]
{\Huge poznamky z prednasek}
\vspace{\stretch{0.618}}
\end{center}
{\Large 2019/2020 \hfill Corse \& US Layout}

\end{titlepage}

%%
%% OBSAH
%%

\tableofcontents

%%
%%  TEXT
%%

\newpage

\section{}
\textbf{Prvni prednaska:} Uvod do predmetu, prehled operacnich systemu, zakladni pojmy, jadro operacniho systemu a jejich typy, historie vyvoje operacnich systemu, prehled technickeho vybaveni, klasifikace pocitacu, operacnich systemu, hlavni smery ve vyvoji operacniho systemu. \\
\subsection{Uvod, prehled operacnich systemu}

Operacni system je vyznamnou casti vypocetnich systemu, ty zahrnuji:
\begin{itemize}
    \item hardware, 
    \item operacni system,
    \item uzivatelske aplikacni programy,
    \item uzivatele. \\
\end{itemize}

Prehled nekterych OS:
\begin{itemize}
    \item GNU/Linux 
    \begin{itemize}
        \item GNU/Debian - Ubuntu 
        \item Red Hat - RHEL, Fedora, Cent OS 
        \item SuSE 
        \item Gentoo, Arch Linux, Slackware (= nejstarsi live distribuce linuxu) 
    \end{itemize}
    \item BSD 
    \begin{itemize}
        \item FreeBSD, OpenBSD 
    \end{itemize}
    \item GNU
    \begin{itemize}
        \item zn. GNU Is Not Unix
    \end{itemize}
    \item MS Windows 
    \item Mac OS X
    \begin{itemize}
        \item jadro XNU = X is Not Unix
    \end{itemize}
    \item Android, iOS 
    \item Minix
    \begin{itemize}
        \item pouziva intel ve svych cipech \\
    \end{itemize}
\end{itemize}
\newpage

\subsection{Zakladni pojmy}

Operacni system je program (resp. kolekce programu), ktera vytvari spojujici mezivrstvu mezi hardware operacniho systemu  a uzivateli a jejich uziv. aplik. programy. OS dale spotrebovava zdroje, jako jsou pamet nebo cas CPU.
(tldr: sw, spojujici hardware, uzivatele a programy) \\

\noindent\textbf{Cile OS:}
\begin{itemize}
    \item maximalni vyuziti zdroju pocitace - drahe pocitace, levnejsi pracovni sila (drive)
    \item jednoduchost pouziti pocitacu - levne pc, draha pracovni sila (dnes prevazuje) \\
\end{itemize}

\noindent\textbf{Zakladni role OS:}
\begin{itemize}
    \item spravce prostredku
        \begin{itemize}
            \item pamet, procesor, periferie
             \item dovoluje sdilet prostredky efektivne a bezpecne
        \end{itemize}
    \item tvurce prostredi pro uzivatele a jejich aplikacni programy
        \begin{itemize}
            \item vytvareni abstrakci, virtualnich objektu (resp. poskytuje standardni rozhrani, ktere zjednodusuje prenositelnost aplikaci a zauceni uzivatelu)
            \item abstrakce jsou napr.: proces, program, soubor
            \item problemy abstrakci jsou mensi efektivita a nepristupne nektere nizkourovnove operace \\
        \end{itemize}
\end{itemize}

\noindent\textbf{OS zahrnuje:}
\begin{itemize}
    \item jadro (kernel),
    \item systemove knihovny a utility (= systemove aplikacni programy),
    \item textove (shell) ci graficke uzivatelske rozhrani (X Window). \\
\end{itemize}

\noindent Presna definice, co vse OS zahrnuje neexistuje. Ruzne firmy a komunity to chapou ruzne. (GNU to chape napr. jako projekt svobodneho OS, zahrnujici jadro, utility, GUI, TUI, vyvojove prostredky a knihovny, ...) \\[1em]

\noindent\textbf{definice:} \\[0.5em] \label{procesy} \label{soubory}
\textit{proces} je aktivita rizena programem (podrobneji se jim venujeme od \ref{procesy-detailed}) \\[0.2em]
\textit{program} je predpis, navod na nejakou cinnost zakodovany vhodnym zpusobem \\[0.2em]
\textit{soubor} je kolekce zaznamu (obvykle Byte) slouzici primarne jako zakladni jednotka pro ukladani dat na vnejsich pametovych mediich \\[0.2em]
\textit{adresar} je kolekce souboru

\newpage

\subsection{Jadro operacniho systemu}

Jedna se o nejnizsi a nejzakladnejsi cast OS. Zavadi se jako prvni a bezi po celou dobu behu pocitacoveho systemu (tzv. reaktivni system, spis nez transformacni). Navazuje primo na hardware (pripadne virtualizovany HW) a pro uzivatele a uziv. aplik. zcela zapouzdruje. \\

\noindent\textbf{Bezi v privilegovanem rezimu:}
\begin{itemize}
    \item je mozne menit obsah registru hw, je mozne zadavat prikazy hw (neni mozne v uzivatelskem rezimu)
    \item musi byt podporovano v hardware \\
\end{itemize}

\noindent\textbf{Jadro (obecne) zajistuje:}
\begin{itemize}
    \item zakladni spravu prostredku a tvorbu zakladniho prostredi jak pro uzivatele tak pro zbytek OS
    \item zahrnuje vsechny operace, kdy je potreba primo komunikovat s hardware (prepinani kontextu - jadro, plaovani procesu - nekdy v jadru, nekdy mimo, zavedeni stranky z disku, ..)
    \item sluzby pro zbytek OS a uzivatele, nektere zajistuje automaticky
    \item nektere sluby nejsou poskytovany automaticky, musi si o ne zadat, nazyvame to volani sluzeb, tzv. \textit{system-call} \label{syscall} (= systemova volani), ktere musi byt implemenovana uzitim specializovanych instrukci (intel: sw preruseni, syscall, sysenter) \\
\end{itemize}

\noindent\textbf{Rozlisujeme dva typy rozhrani OS:} \label{kernel-interfaces}
\begin{itemize}
    \item \textit{kernel interface} (nebo taky: ABI, Kernel ABI) - prime volani jadra pomoci specializovanych instrukci
    \item \textit{library interface} - rozhrani vyssi urovne (napr. C knihovny), typicke sluzby jsou napr. printf z C - volaji se funkce ze         systemovych knihoven, mohou ale nemusi vest na volani sluzeb jadra (bezne aplikace pracuji s timto rozhranim) \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em] \label{prepinani-kontextu-jadro}
\textit{transformacni system} je system, ktery dostane nejaky vstup, zpracuje ho a udela nejaky vystup (prekladac) - pokud se zacykli = chyba \\[0.2em]
\textit{reaktivni system} se spusti a do (teoreticky) nekonecna reaguje na podnety uzivatele (spust proces - spusti proces) - pokud prestane pracovat = chyba \\[0.2em]
\textit{prepinani kontextu} je situace, kdy na CPU bezi proces, ten chci pozastavit a nechat bezet jiny proces \\[0.2em]
\textit{instrukce syscall a sysenter} - jakmile aplikace (bezi v uziv. rezimu) zavola takovou instrukci, dojde ke kontrolovanemu prepnuti do rezimu jadra, provede se sluzba, a pote se prepne zpet \\[0.2em]
\textit{ABI} = Application Binary Interface

\newpage

\subsection{Typy jader OS}

\noindent\textbf{Monoliticka jadra}
\begin{itemize}
    \item vysokourovnove komplexni rozhrani s radou sluzeb, abstrakci, ktere mohou pouzivat vyssi vrstvy OS
    \item vsechny subsystemy jsou implementovany v privilegovanem rezimu, rezimu jadra, a zahrnuji napr. spravu pameti, planovani, meziprocesovou komunikaci, souborove systemy, ..
    \item vyhody: vysoka efektivita diky provazanosti
    \item nevyhody: mala flexibilita pri praci s jadrem (ve filesystemu je chyba, chci zmenit jen implementaci filesystemu za novou verzi a vse ostatni nechat - nelze, je nutne cely system zastavit a znovu nastarovat, nelze menit nic za behu) \\
\end{itemize}

\noindent\textbf{Monoliticka jadra s modularni strukturou}
\begin{itemize}
    \item vylepseni koncepce monolitickych jader
    \item umoznuje zavadet/odstranovat subsystemu jadra v podobe tzv. modulu za behu
    \item vyhody: neni nutne cely system zastavovat a znovu bootovat pro vymenu jednoho modulu, vyssi bezpecnost - zavedou se jen moduly, ktere se budou pouzivat
    \item pouzivane v napr. FreeBSD, Linux \\
\end{itemize}

\noindent\textbf{Mikrojadra}
\begin{itemize}
    \item snaha minimalizovat rozsah jadra a rozsah jeho sluzeb
    \item nabizi jednoduche rozhrani, maly pocet abstrakci, sluzeb, typicky nabizi nejzakladnejsi spravu CPU. I/O zarizeni, pameti, ..
    \item vetsina sluzeb nabizenych monolitickymi jadry (ovladace, vyznamne casti spravy pameti, planovani) je implemenovana mimo jadro v tzv. serverech (nebezi v privilegovanem rezimu).
    \item vyhody: flexibilita (vice soucaasne bezicich implementaci ruznych sluzeb, dynamicke spousteni, zastavovani..), zabezpeceni (chyba v serveru / utok na ne neznamena ovladnuti celeho OS, ale jen daneho serveru)
    \item nevyhody: vyrazne vyssi rezie \\
\end{itemize}

\noindent\textbf{Generace mikrojader}
\begin{itemize}
    \item 1. generace - napr. Mach
    \item 2. generace - napr. L4, mensi rezie nez 1. gen
    \item 3. generace - napr. seL4 nebo ProvenCore, duraz na zabezpeceni, navrh s ohledem na moznost formalni verifikace \\
\end{itemize}

\newpage

\noindent\textbf{Hybridni jadra}
\begin{itemize}
    \item "neco mezi mikrojadry a monolitickymi jadry"
    \item jadra zalozena na mikrojadrech, rozsirena o kod, ktery by mohl byt implementovan ve forme serveru, je ale za ucelem mensi rezie tesneji provazan s mikrojadrem a bezi v jeho rezimu
    \item pouzivane v napr. Mac OS X (Mach + BSD), Windows NT (a vyssi), ... \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{servery (v oblasti mikrojader)} jsou procesy \\[0.2em]
\textit{formalni verifikaci} rozumime overeni urcitych vlastnosti systemu s platnosti matematickeho dukazu \\[0.5em]

\noindent\textbf{linux prikazy:} \\[0.5em]
\textit{lsmod} - vypise aktualne zavedene moduly jadra \\[0.2em]
\textit{rmmod} - maze moduly jadra \\[0.2em]
\textit{modprobe} - zavadeni modulu do jadra \\[0.2em]

\newpage

\subsection{Historie vyvoje OS}

\noindent\textbf{definice:} \\[0.5em] \label{hist-preruseni} \label{ne-preemtive}
\textit{preruseni} je elektricky signal, ktery jde od periferie po sbernici k procesoru, na CPU vyvola obsluhu preruseni - mechanismus umoznujici rozbehnout operaci na periferii a o tu periferii se nestarat (periferie pote oznami konec operace) (podrobne se tomu venuje oddil \ref{hw-preruseni}) \\[0.2em]
\textit{multitasking} je soucasny beh vice aplikaci na jednom procesoru (muze byt s preemtivnim nebo nepreemtivnim planovanim) \\[0.2em]
\textit{nepreemtivni planovani} zn. ze uloha, kt. aktualne bezi na CPU muze byt od CPU "odstavena" pouze tehdy, kdyz nejak zakomunikuje s jadrem (= pozada o sluzbu jadra, napr. periferni operace), dokonce lze pouzit specializovane sluzby pro prepnuti kontextu (proces se dobrovolne vzda CPU, tzv. yield sluzby) - vyhoda: snadna implementace, nevyhoda: pokud se proces zacykli (chyba), cely system se zablokuje (porad bezi 1 uloha - vice viz \ref{planovani}) \\[0.2em]
\textit{preemtivni planovani} - proces muze byt odstaven od CPU bez nutnosti komunikace s jadrem, napr. pomoci preruseni (jakehokoli typu - vice viz \ref{planovani}) \\[1em]

\subsection{Prehled technickeho vybaveni}

\noindent\textbf{Procesor (CPU):}
\begin{itemize}
    \item radic, ALU, registry (IP, SP), instrukce, .. \\
\end{itemize}

\noindent\textbf{Pamet:} \label{hiearchie-pameti}
\begin{itemize}
    \item adresa
    \item hiearchie pameti (cache, RAM, disky, ... - bank pameti muze byt vice)
    \begin{itemize}
        \item pameti se lisi spotrebou, kapacitou, rychlosti, cenou za jednotku
        \item na vrcholu hiearchie jsou registry (nejrychlejsi, nejvyssi cena za jednotku, mala kapacita)
        \item cache (vyrovnavaci pameti, ruznych urovni, L1 = level 1, L2, L3, ..)
        \item primarni pamet RAM
        \item sekundarni pameti - disky (SSD, HDD)
        \item vyrovnavaci pameti disku
        \item tercialni pameti (zalohy - nejnizsi cena za jednotku, nejpomalejsi, nejvetsi kapacita - pasky, CD/DVD, externi disky, cloudy, sitove disky, ..) \\
    \end{itemize}
\end{itemize}

\noindent\textbf{Periferie:}
\begin{itemize}
    \item disk (HDD, SDD,..), klavesnice, monitor (I/O porty, preruseni, DMA) \\
\end{itemize}

\noindent\textbf{Sbernice:}
\begin{itemize}
    \item propojuji jednotlive komponenty
    \item na vrcholu hiearchie jsou sbernice propojujici CPU a pamet (FSB - Front Side Bus, HyperTransport QPI - Quick Path Interconnect)
    \item diskove sbernice (SATA/ATA, SCSI/SAS, USB)
    \item dalsi sbernice (NVLink - pripojovani nVidia GPU, PCI - rozsirujici karty ci disky, CAPI - IBM Tauer CPU, propojovani CPU a akceleratoru) \\
\end{itemize}
 
\noindent\textbf{definice:} \\[0.5em] \label{i-o}
\textit{I/O porty} = vstup-vystupni porty, predstavuji pametove oddeleny prostor od adresoveho prostoru bezne pameti, s temito adresami se komunikuje specialnimi instrukcemi (intel: inout) \\[0.2em]
\textit{pametove mapovane I/O} je cast adresoveho prostoru bezne pameti neni pouzita pro praci s pameti, ale adresy jsou presmerovane do HW (neco co zapisu na danou adresu nebude v pameti ale v nejakem registru HW) \\[0.2em]
\textit{DMA} zn. Direct Memory Access, souvisi s nezavislou cinnosti periferii - periferie mohou primo komunikovat s hardware (radic disku si sam z adresy pameti nacte data a pres sbernice je prenasi na disk, nebo naopak) \\[0.2em]

\subsection{Klasifikace pocitacu}

\noindent\textbf{Dle ucelu:}
\begin{itemize}
    \item univerzalni,
    \item specializovane
    \begin{itemize}
        \item vestavene (palubni pc, spotrebni elektronika, ..)
        \item aplikacne orientovane (rizeni db, sitove servery, ..)
        \item vyvojove (zkouseni novych technologii) \\
    \end{itemize}
\end{itemize}

\noindent\textbf{Podle vykonnosti:}
\begin{itemize}
    \item vestavene pc, tablety, mobily, ..
    \item osobni pocitace (PC) a pracovni stanice (workstation) - dnes se nerozlisuje
    \item servery
    \item strediskove pocitace (mainframe) - vyrabi IBM, ladene na obrovsky I/O vykon a vysokou spolehlivost
    \item superpocitace - ladene na surovy vypocetni vykon (vedecke vypocty, simulace) \\
\end{itemize}

\newpage

\subsection{Klasifikace OS}

\noindent\textbf{Podle ucelu:}
\begin{itemize}
    \item univerzalni (UNIX, Linux, Windows, ..)
    \item specializovane (real-time - RT-Linux, databaze, web - z/VSE, mobilni - iOS, Android) \\
\end{itemize}

\noindent\textbf{Podle poctu uzivatelu:}
\begin{itemize}
    \item jednouzivatelske (CP/M, MS-DOS,..)
    \item viceuzivatelske (UNIX, Windows, ..) \\
\end{itemize}

\noindent\textbf{Podle poctu soucasne bezicich uloh:}
\begin{itemize}
    \item jednoulohove
    \item viceulohove (multitasking, ne/preemptivni) \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{soft real-time} - doporuceni aby se akce vykonavaly v realnem case \\[0.2em]
\textit{hard real-time} - akce se musi vykonavat v urcitem case \\[1em]

\subsection{Implementace OS}

OS se obtizne programuji a ladi, protoze to jsou velke programove systemy, paralelni a asynchronni systemy, systemy zavisle na technickem vybaveni. \\

\noindent\textbf{Dusledky:}
\begin{itemize}
    \item setrvacnost pri implementaci (snaha nemenit kod, ktery pracuje spolehlive)
    \item pouzivani technik pro minimalizaci vyskytu chyb (inspekce zdrojoveho kodu, rozsahle testovani, podpora vyvoje technik formalni verifikace) \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{paralelni system} zn. ze zde bezi vice aktivit soucasne \\[0.2em]
\textit{paralelni asynchronni systemy} - procesy se prepinaji v okamzicich, ktere nelze dopredu presne predpovedet \\[1em]

\newpage

\subsection{Hlavni smery ve vyvoji OS}
\begin{itemize}
    \item neustale vylepsovani architektur (snizovani rezii jader,)
    \item bezpecnost, spolehlivost
    \item podpora stale vetsiho poctu procesoru, vice jader
    \item virtualizace
    \item distribuovane zpracovani (cloudy, kontejnery, Internet of Things)
    \item OS tabletu, mobilu, vestavenych systemu, ...
    \item vyvoj novych technik navrhu a implementace OS (podpora formalni verifikace) \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{bezpecnost} zn., ze system je odolny vuci vnejsim utokum \\[0.2em]
\textit{spolehlivost} zn., ze system "nespadne sam od sebe"




%%
%% 2
%%
\newpage

\section{}
\textbf{Druha prednaska:} Unix - uvod: historie UNIXu (nezkousi se), priciny uspechu UNIXu, varianty UNIXu, zakladni koncepty, struktura jadra, komunikace s jadrem - hardwarova preruseni. Prehled programovani v UNIXu: nastroje programatora, ..


\subsection{Priciny uspechu UNIXu}
\begin{itemize}
    \item viceprocesovy, viceuzivatelsky,
    \item napsan v C - prenositelny,
    \item zpocatku (a pozdeji) siren ve zdrojovem tvaru,
    \item "mechanism, not policy",
    \item "fun to hack",
    \item jednoduche uzivatelske rozhrani (terminal),
    \item skladani slozitejsich programu z jednodussich (tvoreni aplikaci typu filtr),
    \item hierarchicky system souboru,
    \item konzistentni rozhrani perifernich zarizeni \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{"mechanism, not policy"} zn. snaha oddelit casti aplikaci (napr. GUI - oddelit zakladni rutiny pro vykreslovani grafiky od politik, tzn. koncove nastavby - barvy oken, umisteni tlacitek, .. - systematicke rozdeleni vede k lepsim optimalizacim a ladenim algoritmu a zaroven rychlym zmenam politik) \\[0.2em]
\textit{"fun to hack"} zn., lide se na vyvoji podili, protoze je to bavi (nejen protoze jsou za to placeni) \\[0.2em]
\textit{aplikace typu filtr} - jednoduche otevrene aplikace, na vstupu maji textovy dokument v otevrene podobe, vstup zpracuji a na vystupu opet otevreny dokument (zadne binarni, zakodovane) \\[1em]

\newpage

\subsection{Varianty UNIXu}
\textbf{Hlavni vetve OS UNIXoveho typu:}
\begin{itemize}
    \item UNIX System V (puvodni system z AT\&T),
    \item BSD UNIX (FreeBSD, NetBSD, ..),
    \item firemni varianty (AIX, Solaris, ..)
    \item Linux \\
\end{itemize}

\noindent\textbf{Sousisejici normy:}
\begin{itemize}
    \item XPG - X/OPEN, SVR4 - AT\&T,SUN, OSF/1, Single UNIX Specification,
    \item POSIX - IEEE standard,
    \item Single UNIX Specification v3/v4 - shell, utility (CLI), API \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{POSIX} je striktni podmnozina Single UNIX Specification, je to standard definujici zakladni textove prikazove rozhrani OS + API \\[1em]

\subsection{Zakladni koncepty}
Jsou dve zakladni koncepce (abstrakce) UNIXu: \textbf{procesy} a \textbf{soubory}. \\

\noindent Procesy mezi sebou komunikuji pomoci ruznych mechanismu meziprocesove komunikace - IPC (Inter-Process Communication) - roury, signaly, semafory, sdilena pamet, sockets, zpravy, streams, .. a pro komunikaci pouzivaji nejake I/O rozhrani (read, write, close, ..) \\

\noindent\textbf{definice:} \\[0.5em]
\textit{procesy} jsou abstrakci probihajici nejake aktivity (viz \ref{procesy})\\[0.2em]
\textit{soubory} jsou abstrakci dat (viz \ref{soubory}) \\[1em]

\newpage

\subsection{Struktura jadra UNIXu}
Zakladni podsystemy jsou sprava souboru a sprava procesu. \\
\textbf{Popis:}
\begin{itemize}
    \item Na hornim okraji jadra (smerem k uzivatelum, aplikacim) je vrstva implementujici rozhrani volani sluzeb, prostrednictvim ktere jadro prebira zadosti o sluzby od aplikaci. Rozhrani kontroluje zda ten, kdo o sluzbu zada ji muze volat, zda jsou parametry validni a rozhrani predava pozadavek dal do jadra.
    \item Aplikace mohou s jadrem komunikovat primo, nicmene nejcasteji komunikuji s jadrem pres knihovny. (viz. \ref{kernel-interfaces})
    \item Na druhem okraji (tesne nad HW) je vrstva abstrakce hadrware.
    \item Mezi spravou souboru a hardware se nachazi ovladace, pote vrstva vyrovnavacich pameti, ktere souborove systemy pouzivaji ke zrychleni prace s relativne pomalymi disky (HDD, SSD - oproti RAM pomale) - OS se snazi vyhnout opakovanemu cteni stejnych dat, proto si v jednom okamziku nacte vic dat nez uzivatel zada, ulozi si data do vyrovnavaci pameti (pri dostatku pameti) a data nacita odtud. (napr. C knihovny jsou pouzivane kazdym druhym programem - jsou v pameti temer porad). \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em] \label{ovladace}
\textit{ovladace} jsou programy slouzici k rizeni (zadavani prikazu, prebirani stavovych informaci, reseni mimoradnych stavu konkretnich periferii) - lze je (jako i prislusna zarizeni) rozdelit na znakova a blokova (kratsi definice viz \ref{ovladac}) \\[0.2em]
\textit{znakova zarizeni} jsou zarizeni komunikujici po jednotlivych znacich (klavesnice) \\[0.2em]
\textit{blokova zarizeni} komunikuji po blocich (disk - sektory, resp. bloky) \\[0.2em]
\textit{komunikaci s jadrem} rozumime nastavovani parametru hardware, vydavani prikazu hw, obsluhu ruznych stavu do kterych se hw dostava (a o kterych je CPU a jadro informovano prostrednictvim preruseni) \\[0.2em]
\textit{nastavovani parametru hw} se deje pomoci I/O portu nebo pametove mapovanych operaci (viz \ref{i-o}) \\[0.2em]

\newpage

\subsection{Komunikace s jadrem a hardwarova preruseni} \label{hw-preruseni}
Sluzby jadra jsou operace, jejich realizace je pro procesy zajistovana jadrem. Explictne je mozne o provedeni urcite sluzby zadat prostrednictvim system call (viz \ref{syscall}). \\

\noindent\textbf{Priklady nekterych sluzeb jadra (systemova volani v UNIXu):}
\begin{itemize}
    \item open, close, read - otevre/zavre/cte soubor,
    \item write - zapisuje,
    \item kill - posle signal,
    \item fork - duplikuje proces,
    \item exec - prepise kod,
    \item exit - ukonci proces. \\
\end{itemize}

\subsubsection{Hardwarove preruseni}
\begin{itemize}
    \item hardware interrupt je mechanismus, kterym HW zarizeni oznamuji jadru asynchronne vznik udalosti, ktere je zapotrebi obslouzit (dalsi mozna definice viz \ref{hist-preruseni}),
    \item zadosti o HW preruseni prichazi jako elektricke signaly (IRQ) do radice preruseni (APIC),
    \item procesor s radicem preruseni komunikuje pomoci I/O portu. \\
\end{itemize}

\noindent\textbf{Prijem nebo obsluju HW preruseni lze zakazat:}
\begin{itemize}
    \item maskovanim preruseni, 
    \item na CPU (instrukce CLI/STI na Intel/AMD - zakazou se vsechna krome NMI),
    \item ciste programve v jadre (preruseni se prijme, ale jadro si jen poznamena jeho prichod a neobsluhuje se) \\
\end{itemize}

\noindent\textbf{NMI:}
\begin{itemize}
    \item non-maskable interrupt je HW preruseni, ktere nelze zamaskovat na radici ani zakazat na CPU,
    \item pouziva se pri kritickych chybach pameti, sbernice, .. (alternativne se pouziva pro ladeni / reseni uvaznuti v jadre "NMI watchdog") \\
\end{itemize}

\noindent\textbf{Preruseni mohou vznikat i v CPU - jsou to synchronni preruseni, tzv. vyjimky (= exceptions):}
\begin{itemize}
    \item trap - po obsluze se pokracuje dalsi intrukci (breakpoint, overflow, ..)
    \item fault - po obsluze se znovu opakuje intrukce, ktera vyjimku vyvolala (vypadek stranky, deleni 0, ..)
    \item abort - dochazi k zavaznym problemum detekovanym CPU, neni jasne jak pokracovat - provedeni se ukonci (zanorene vyjimky typu fault, chyby HW detekovane CPU) \\
\end{itemize}

\textbf{Mohou existovat i dalsi typy preruseni:} (tato preruseni obsluhuje CPU zcela specifickym zpusobem (casto mimo vliv jadra, napr. na Intel/AMD))
\begin{itemize}
    \item Interprocessor interrupt (IPI)
    \begin{itemize}
        \item meziprocesorove preruseni
        \item pouziva se pro preposilani preruseni z jednoho CPU na druhy nebo pro spravu cache (kazdy CPU ma svoji cache, do nich mohou mit CPU nacteny stejne adresy z pameti - pokud dojde ke zmenam v pameti, musi CPU informovat ostatni CPU o zmene)
    \end{itemize}
    \item System management Interrput (SMI)
    \begin{itemize}
        \item preruseni typu sprava systemu
        \item muze byt vyvolano HW i SW ve zvlastnich situacich
        \item pokud se takove preruseni vyvola, tak se dostane ke slovu firmware, ktery provadi obsluhu ruznych chybovych stavu (prehrati, vybita baterie, ..)
        \item v ramci SMI nebezi bezne aplikace ani jadro, nesmi obsluha SMI bezet prilis dlouho (system se muze dostat do nekonzistentniho stavu) \\
    \end{itemize}
\end{itemize}

\subsubsection{Zakazovani preruseni}
\textbf{Proc preruseni zakazovat?}
\begin{itemize}
    \item v ramci obsluhy jednoho preruseni muze nastat dalsi preruseni,
    \item napr. na CPU bezi vypocet, neco nastane na disku, disk posle preruseni, to dojde k CPU a jadro zacne preruseni obsluhovat, v ten moment se neco stane na klavesnici a prijde dalsi preruseni,
    \item pote dale v ramci obsluhy muze jadro upravovat ruzne sve interni struktury, ktere mohou byt v nekonzistentnim stavu (napr. zretezene seznamy procesu [ukazatele], ruzne si je projuje, nez je stihne propojit, prije dalsi proces a muze sahnout do pameti kam nema),
    \item proto obsluha preruseni musi byt synchronizovana a v pripade, ze se v ramci preruseni provadi nejaka kriticka operace je nutne vyloucit ostatni (vsechna) preruseni \\
\end{itemize}

\newpage

\subsubsection{Pristupy k zakazovani preruseni}

Pokud vsak zakazu (nejaka/vsechna) preruseni, abych se mohl venovat obsluze jednoho a budu ho obsluhovat prilis dlouho, system se muze dostat do nekonzistentniho stavu (jako u SMI). Pouzivaji se proto dva pristupy:
\begin{itemize}
    \item je snaha zakazovat jen preruseni s nizsimi prioritami,
    \item rozdelit obsluhu preruseni do vice casti (urovni).
\end{itemize}

\noindent\textbf{Obsluha preruseni je casto delena na dve urovne:}
\begin{itemize}
    \item 1. uroven:
    \begin{itemize}
        \item ma byt co nejkratsi,
        \item v ramci obsluhy preruseni se zakomunikuje nezbytnym zpusobem s HW (prevzani dat z/do HW, vydani prikazu HW, ..) a naplanuje se beh 2. urovne,
        \item nelze pouzit bezne synchronizacni prostredky (protoze napr. CPU bezi nejaky vypocet, prijde preruseni z disku, jadro zacne resit 1. uroven obsluhy, nicmene obsluha != proces)
    \end{itemize}
    \item 2. uroven:
    \begin{itemize}
        \item dokoncuje obsluhu preruseni,
        \item provadi se operace, kdy neni potreba komunikovat s hardware,
        \item nemusi se zakazovat preruseni,
        \item muze bezet v specialnich procesech (interrup threads ve FreeBSD nebo tasklety/softIRQ v Linuxu),
        \item mohou se pouzit bezne synchronizacni prostredky \\
    \end{itemize}
\end{itemize}

\subsubsection{Ovladace zarizeni a preruseni}
\begin{itemize}
    \item pri inicializaci ovladace (v Linuxu je to typicky modul) nebo pri jeho prvnim pouziti se musi registrovat k obsluze urciteho IRQ,
    \item bud u nekterych zarizeni se pouzivaji (historicky) zafixovana cisla preruseni,
    \item nebo ovladac muze zjistit cislo preruseni tak, ze zakomunikuje s radicem sbernic, pokud to nefunguje,
    \item ovladac vyda prikaz zarizeni, ktere ma ovladat, aby zacalo vysilat nejaka preruseni (a "poslouchala" sbernici, "kdo se ozve"),
    \item pote se zaregistruje k obsluze prislusneho preruseni a hardware se pres tabulku preruseni ovladac "dostane ke slovu",
    \item vice zarizeni vsak muze pouzivat stejne cislo zadosti o preruseni
    \begin{itemize}
        \item v takovem pripade jadro vytvori zretezeny seznam ovladacu, ktere maji zajem o dane preruseni
        \item ovladace musi byt napsane tak, ze pokud jim dojde preruseni (o ktere maji zajem), tak musi zakomunikovat s tim zarizenim a zeptat se ho, zda opravdu to zarizeni poslalo dane preruseni
        \item pokud ano - obslouzi se, pokud ne - preda se rizeni preruseni dalsimu ovladaci v seznamu \\
    \end{itemize}
\end{itemize}


\subsubsection{Priklad komunikace s jadrem} \label{pristup-na-disk}
Synchronni komunikace je proces-jadro, asynchronni je hardware-jadro. Priklad (detailnejsi, ale na tema pristupy na disk viz \ref{pristup-na-disk-detailed}):
\begin{itemize}
    \item proces A zavola sluzbu read() a jadro ihned zacne volani obsluhovat (synchronni)
    \item nejprve se podiva do cache zda data, o ktera ma zajem proces A uz tam nejsou
    \item pokud ano, tak mu je rychle nakopiruje z cache na adresu, kterou pozaduje proces (bez komunikace s diskem)
    \item pokud data nejsou v cache, proces A bude pozastaven a jadro vyda prostrednictvim ovladacu disku prikaz k nacteni urciteho objemu dat, typicky vice nez zada uzivatel a nacita do vyrovnavaci pameti (ne na pozadovanou adresu)
    \item na procesoru dale bezi proces B, taky pozada o read(), zopakuje se to same co u A
    \item az disk dokonci operace jednoho z procesu (nemusi byt v poradi volani), disk posle preruseni na CPU
    \item jadro bude informovano, ze ma potrebna data pro proces A/B
    \item z cache nakopiruje pozadovana data na pozadovanou adresu
    \item pote se proces A/B probudi a bezi dal, to same se stane u dalsiho procesu \\
\end{itemize}


\noindent\textbf{definice (pro \ref{hw-preruseni}.x):} \\[0.5em]
\textit{asynchronni} zn., bez prime-okamzite vazby na to co dela jadro nebo aplikace (tiskarna tiskne - operace nekdy skonci - ale nikdy nevim dopredu kdy presne) \\[0.2em]
\textit{synchronni} zn., ze CPU neco provede a ihned se zavola preruseni (napr. deleni 0) \\[0.2em]
\textit{IRQ} = interrupt request \\[0.2em]
\textit{radic preruseni} = interrput controller, hardwarova jednotka, ktera predava preruseni do CPU - registruje prichozi IRQ, ty se dle priorit predavaji do CPU (preruseni je mozne take zamaskovat - nepredavat dal do CPU) v podobe cisla preruseni, CPU se automaticky prepne do chraneneho rezimu a spusti obsluznou rutinu definovanou jadrem (preruseni 1 - provede xxx, 2 - xxx, ..) \\[0.2em]
\textit{APIC} = Advanced Programmable Interrupt Controller - distribuovany system, kazdy CPU ma lokalni APIC, externi zarizeni mohou byt pripojena primo / pres I/O APIC \\[0.2em]
\textit{NMI watchdog} - jadro si nadefinuje, ze casovac mu kazdych n casovych jednotek posle toto preruseni - pokud dojde v jadre k uvaznuti pri obsluze jineho preruseni a vsechna preruseni budou zakazana, toto se vzdy dostane do CPU (jadro se muze zotavit) \\[0.2em]
\textit{vypadek stranky} zn., (pamet je rozdelena na casti, ktere mohou byt rozdeleny na disk) kdyz proces bude sahat do pameti a sahne na stranku, ktera v ni neni - detekuje se ze stranka tam neni - poruseni ochrany pameti - jadro zkontruluje, zda proces nesaha kam by nemel, a pokud ne, tak mu stranku nahraje zpet do pameti a znovu se provede ta stejna instrukce \\[0.2em]
\textit{bezne synchronizacni prostredky} jsou napr semafory nebo zamky a synchronizuji procesy \\[1em]

\noindent\textbf{linux:} \\[0.5em]
zakladni statistiky o obsluze preruseni jsou v \textit{/proc/interrupts}

\subsection{Nastroje programatora UNIXu}
X-Window system, vzdaleny pristup pres X-Window uzitecne prikazy na linuxu, ovladani vimu, apod. - vice viz. 2. prednaska IOS, u zkousky to nebyva.

\section{}
\subsection{Bash, shell, experimenty}
\section{}
\subsection{Bash, shell, experimenty}
Treti a ctvrta prednaska je venovana hlavne shellu, prochazi se prakticky ruzne prikazy a provadi se experimenty, apod. - lepsi je shlednout + na zkousce nic takoveho nebyva.

\newpage

\section{}
\textbf{Pata prednaska:} Sprava souboru: pevny disk, diskove sbernice, sektory, parametry pevnych disku, SSD, problematika zapisu SSD, zabezpeceni disku, diskova pole (RAID), ulozeni dat na disku, fragmentace, pristup na disk a jeho planovani, logicky disk.
\subsection{Pevny disk}
\textbf{Popis:}
\begin{itemize}
    \item uvnitr maji radu kulatych ploten, zaznam se provadi na kazdem z tech dvou povrchu, je v soustrednich kruznicich (= tracks, stopy)
    \item vsechny plotny jsou na stejne ose, pridelane k sobe a rotuji soucasne
    \item k nacitani slouzi sada hlavicek, cteci a zapisove, jsou tam v tolika kusech, kolik je tam povrchu (napr. 3 plotny = 6 povrchu = 6 hlavicek), vsechny umistene na jednom rameni, vsechny hlavicky se pohybuji soucasne
    \item hlavicky jsou nastavene na sade nekolika stop (kruznic) o stejnem prumeru = cylindr,
    \item stopy se deli na sektory
    \item velikosti sektoru byly drive 512B, u CD/DVD 2048B, dnes 4096B \\
\end{itemize}

\noindent\textbf{Adresace sektoru:}
\begin{itemize}
    \item ze zacatku se pouzival CHS - urci se se kterym cylindrem chci pracovat, dale s kterou hlavou a jakym sektorem v ramci stopy,
    \item v soucasne dobe se pouziva LBA, kde jsou sektory (bloky) cislovane (jako adresy v pameti) od 0 po n, diskova jednotka si musi tato cisla prevadet na CHS \\

\end{itemize}

\noindent\textbf{Periferni ci diskova rozhrani:}
\begin{itemize}
    \item pouzivaji se pro pripojeni disku,
    \item nejbezneji se pouziva ATA, drive se pouzivala v paralelni verzi (PATA - jednotlive byty se posilaly paralelne, pri rostoucich rychlostech byl problem zajistit synchronizaci techto dat), nyni v seriove verzi (SATA)
    \item take se pouziva SCSI ci SAS (Serial Attached Scasi), USB, FireWire, FibreChannel, Thunderbold, PCI Express nebo NVMe (pripojovani nejrychlejsich SSD),
    \item nad temito rozhranimi muze byt dalsi HW rozhrani propojujici tyto sbernice, jako treba AHCI, OHCI, UHCI, .. \\
\end{itemize}

\newpage

\noindent\textbf{Diskove sbernice se lisi:}
\begin{itemize}
    \item rychlosti (SATA do 6 Gbit/s, SAS 22.5 Gbit/s),
    \item poctem pripojenych zarizeni (SATA desitky, 65535 SAS),
    \item maximalni delkou kabelu (1-2m SATA, 10m SAS),
    \item architekturou pripojeni (moznost pripojeni jednoho zarizeni vice cestami u SAS),
    \item seznamem prikazu, ktere to zarizeni umi (flexibilita pri chybach, selhani, zotaveni, ..) \\
\end{itemize}

Pres diskove sbernice je mozne mit pripojene i jine typy pameti, jako jsou flash disky, SSD, pasky, CD/DVD/BD ci tercialni pameti. V systemu vznika hierarchie pameti, viz. \ref{hiearchie-pameti}. \\

\noindent\textbf{definice:} \\[0.5em]
\textit{cylindr} (v HDD) je mnozina stop o stejnem prumeru \\[0.2em]
\textit{sektor} je nejmensi jednotka diskoveho prostoru, ktery mi umozni diskova elektronika nacist nebo zapsat \\[0.2em]
\textit{blok} nebo \textit{diskovy blok} je sektor v HDD \\[0.2em]
\textit{alokacni blok} nebo \textit{blok souboroveho systemu} je nejmensi jednotka, kterou umozni alokovat OS \\[0.2em]
\textit{CHS} zn. Cylinder Head Sector  \\[0.2em]
\textit{LBA} zn. Linear Block Adress \\[0.2em]

\subsection{Parametry pevnych disku}
Pristupova doba sestava z \textbf{doby vystaveni hlav} a \textbf{rotacniho zpozdeni}. \\

\noindent Typicke parametry soucasnych disku jsou kapacita, prumerna doba pristupu (jednotky ms u HDD) , otacky a prenosova rychlost. U prenosovych rychlosti se rozlisuje \textit{sustained tranfer rate} a \textit{maximum transfer rate}. \\

\noindent Mazani dat probiha tak, ze se prepisou metadata, pouze se poznamena (OS), ze dany soubor byl smazan. \\

\noindent\textbf{definice:} \\[0.5em]
\textit{doba vystaveni hlavicek} zn., ze pokud nejsou nastavene hlavicky na stope, se kterou chci pracovat (malokdy), tak je nutne pohnout hlavickami (vic zasunout dovnitr nebo vysunout) \\[0.2em]
\textit{rotacni zpozdeni} je doba nez mi pod spravne nastavenou hlavicku najede sektor (narotuje se disk) \\[0.2em]
\textit{maximum transfer rate} je spickova prenosova rychlost, jak maximalne rychle je schopen disk komunikovat po kratkou dobu (typicky rychlost predani dat z vyrovnavacich pameti disku) \\[0.2em]
\textit{sustained transfer rate} opravdova rychlost cteni z ploten \\[0.2em]

\noindent \textbf{linux:} \\[0.5em]
\textit{hdparm [-t]} umoznuje zmerit prenosovou rychlost a menit parametry disku, -T meri rychost prenosu z vyrovnavaci pameti OS (RAM)

\newpage

\subsection{Solid State Drive - SSD}
Mohou byt zalozena na ruznych technologiich, nejcasteji na nevolatilnich pametech NAND flash nebo DRAM (se zalohovanym napajenim) ci na kombinacich.

\subsubsection{Klady a zapory SSD}

\noindent \textbf{Vyhody:}
\begin{itemize}
    \item rychly (okamzity) nabeh,
    \item nahodny pristup (mikrosekundy),
    \item vetsi prenosove rychlosti (stovky MB/s, ATA do 600MB/s, 3.5GB/s s M.2, 7GB/s s PCI Express 4),
    \item zapis muze byt mirne pomalejsi,
    \item tichy provoz, lepsi mechanicka a magneticka odolnost,
    \item obykle nizsi spotreba (neplati pro DRAM). \\
\end{itemize}

\noindent \textbf{Nevyhody:}
\begin{itemize}
    \item vyssi cena za jednotku prostoru,
    \item omezeny pocet prepisu (nevyznamne pro bezny provoz),
    \item vetsi riziko katastrofickeho selhani, 
    \item mensi vydrz mimo provoz (pri vyplem napajeni a skladovani),
    \item komplikace se zabezpecenim (bezpecne mazani nebo sifrovani prepisem dat - vyzaduje specialni pdporu). \\
\end{itemize}

\subsubsection{Problematika zapisu u SSD}
NAND flash SSD jsou organizovany do stranek (typicky 4KiB) a ty jsou sdruzeny do bloku (typicky 128 stranek = 512 KiB). \\

\noindent\textbf{Zapis nebo prepis dat:}
\begin{itemize}
    \item prazdne stranky lze zapisovat jednotlive (prepisovat ne!),
    \item pokud chci prepisovat (jednu stranku), je nutne cely blok nacist do pameti, vymazat (zresetovat) a v pameti upraveny blok nacist zpet (= write emplification, zesileni zapisu - mnohonasobne zpomaleni),
    \item problem je mensi pri sekvencnim (pockam az budu mit dost dat tak aby pokryly blok) nez pri nahodnem zapisu do souboru. \\
\end{itemize}

\noindent\textbf{Problem se sifrovanim a bezpecnym mazanim:}
\begin{itemize}
    \item diky tomu jak SSD prepisuji data se data nekolikrat presouvaji po disku,
    \item proto disk musi poskytovat hw podporu pro bezpecne mazani nebo sifrovani. \\
\end{itemize}

\noindent\textbf{Reseni problemu prepisu u SSD:}
\begin{itemize}
    \item typicky ma SSD vice stranek-bloku nez je deklarovana kapacita (pri prepsani se zapise do volne stranky),
    \item po smazani dostatku stranek (tak ze tvori blok) se blok zresetuje - prikazem TRIM souborovy system sdeli SSD, ktere stranky jiz nejsou pouzivane (a ktere bloky muze SSD smazat),
    \item radic SSD muze stranky presouvat tak, aby si nektere bloky uvolnil (pokud je v bloku malo stranek, presunou se a blok se zresetuje),
    \item TRIM nelze pouzit vzdy (typicky pokud v souborovem systemu mame obraz jineho souboroveho systemu, nemusi byt mozne sdelit zakladnimu filesystemu informace o praznych blocich, apod. nebo databaze, ktere si ukladaji data do velkeho predalokovaneho prostoru, ci obrazy virtulanich stroji a virtualni disky) \\
\end{itemize}

\noindent Radic SSD presouva i dlouho nezmenene stranky, aby minimalizoval pocet prepisu stranek. \\

\noindent\textbf{definice:} \\[0.5em]
\textit{nevolatilni} zn., ze pokud se vypne napajeni, tak obsah zustane zachovan (alespon po nejakou rozumnou dobu) \\[0.2em]
\textit{stranka} je nejmensi jednotka dat, kterou lze do SSD zapsat \\

\subsection{Zabezpeceni disku}
Diskova elektronika typicky na ukladana data (sama o sobe) zabezpecuje kody, ktere umi pri naslednem cteni detekovat a pripadne opravit chyby - pouziva ECC. (detekce a oprava chyb je pouze v rezii disku, pokud disk detekuje chybu a neni prilis velka, chybu opravi a data ulozi na jiny sektor, poznaci si, ze ten sektor nema pouzivat) \\

\noindent Existuje technologie, ktere umoznuji zjistit, v jakem stavu disk je (statistiky, premapovani, pocet chybnych sektoru, ..) - S.M.A.R.T (podporovana vsemi "rozumnymi" disky) \\

\noindent Pak je mozne jeste provadet testovani na urovni OS, napr. e2fsck nebo badblocks nebo si nektere filesystemy (RFS, ZFS) provadeji kontinualni kontroly toho, co se ve filesystemu deje. Tyto utility nebo filesystemy mohou chyby detekovat (a varovat) nebo opravit (pokud neni chyba prilis velka) ci vyradit pouziti nekterych sektoru. \\


\noindent\textbf{definice:} \\[0.5em]
\textit{ECC} = Error Correction Code \\[0.2em]
\textit{S.M.A.R.T} = Self Monitoring Analysis and Reporting Technology \\[0.2em]
\textit{kontinualni kontroly (fs)} zn., ze si ukladaji sve dalsi kontrolni soucty, a pote si kontroluji pri praci se souborem, zda kontroly souhlasi \\

\noindent\textbf{linux:} \\[0.5em]
\textit{smartctl} je prikaz umoznujici vyuziti technologie S.M.A.R.T (testy disku, statistiky, ..) \\[0.2em]
\textit{smartd} je nadstavbou smartctl (pravidelne spousteni testu, ..)

\newpage

\subsection{Diskova pole (RAID)} \label{RAIDs}
RAID je technologie umoznujici z vetsiho poctu (levnejsich a ne prilis spolehlivych, vykonnych) disku vytvorit jeden disk, ktery je rychlejsi a spolehlivejsi. \\

\noindent\textbf{Muze byt implementovan:}
\begin{itemize}
    \item hardwarove (do rozsirujici karty pripojime nekolik disku a ta implementuje RAID),
    \item subsystemem v jadre,
    \item nektere souborove systemy maji implementaci RAID v sobe.  \\
\end{itemize}

\noindent Ruznych typu RAID je nekolik (tzv. raid levels). \\

\subsubsection{RAID 0}
\begin{itemize}
    \item data jsou rozlozena po dvou ci vice discich, ale kazdy datovy blok je ulozen jen na jednom disku (napr. dva disky, 0 a 1, prvni datovy blok [sektor, skupina sektoru] je na 0, druhy na 1, treti na 0, ...)
    \item vyssi efektivita cteni ci zapisu,
    \item je mozne paralelne cist ci zapisovat (do vice disku)
    \item prudce snizuje spolehlivost - pokud selze jeden disk, prijdu o data na nem \\
\end{itemize}

\subsubsection{RAID 1}
\begin{itemize}
    \item disk mirroring, pro 2 a vice disku,
    \item vsechny bloky dat se zapisuji na vsechny disky,
    \item moznost cist a zapisovat paralelne,
    \item vyssi spolehlivost (data jsou na vsech discich) \\
\end{itemize}

\subsubsection{RAID 2}
\begin{itemize}
    \item nejslozitejsi, proto se prilis nepouziva,
    \item pouziva zabezpecovaci Hemingovy kody,
    \item k urcitemu poctu datovych disku je urcity pocet zabezpecovacich disku,
    \item data se ukladaji na datovych discich na urovni bytu, k nim se dopocitavaji zabezpecovaci kody (napr. 4 datove - 3 zabezpecovaci),
    \item byty dat se rozlozi do vsech disku (ofc ty se musi prevest do bajtu a sektoru a zapisuje se to po sektorech)
    \item jediny RAID, ktery umi detekovat chyby, nektere i sam opravit, dokonce umi i zjistit, ktery disk selhal \\
\end{itemize}

\newpage

\subsubsection{RAID 3}
\begin{itemize}
    \item jednodussi zabezpeceni nez RAID 2, v podobe paritnich bytu,
    \item rozklada data po bajtech ci skupinach bajtu, ktere zabezpecuje partinim zabezpecenim (napr. 4 disky - 3 datove a 1 paritni). \\
\end{itemize}

\subsubsection{RAID 4}
\begin{itemize}
    \item je analogie (tak jako RAID 3, akorat ..),
    \item provadi se rozkladani na urovni bloku-sektoru,
    \item nevyhoda u RAID 3 i 4 je pretizeni paritniho disku - pri zapisu/cteni se vzdy pracuje s paritnim diskem (a datovym) - na paritni disk se zapisuje tolikrat casteji, kolik mam datovych disku, tzn. vetsi pravdepodobnost selhani \\
\end{itemize}

\subsubsection{RAID 5}
\begin{itemize}
    \item prakticky se uz pouziva,
    \item funkce paritniho disku neni vyhrazena pro jeden disk, ale mezi disky tzv. rotuje,
    \item napr. v konfiguraci se 4 disky, prvni 3 datove bloky se ulozi na 3 disky, na poslednim bude parita, pro dalsi trojici se ulozi na 3. disk, pro dalsi na 2., dalsi na 1., a potom zase na posledni, apod. .. = rovnomerne zatizeni disku,
    \item diky parite jsme schopni opet detekovat a korigovat chybu v jednom disku (pocet bitu neni sudy - chybi tam parity bit),
    \item parita se pocita dle sektoru (prvni bit 1. sektoru, prvni 2. sektoru, ..),
    \item pokud selze vice disku, nelze dopocitat bity (data) \\
\end{itemize}

\subsubsection{RAID 6}
\begin{itemize}
    \item parita se uklada 2x,
    \item dokaze se vyrovnat se selhanim az 2 disku,
    \item vetsi redudance dat (obetuji se 2 disky jako parita) \\
\end{itemize}

\noindent RAID je mozne vytvorit i na jednom fyzickem disku (na kterem jsou logicke disky).

\newpage

\subsection{Opravy chyb u paritnich disku}
\begin{itemize}
    \item paritni disky pouzivane u RAID 3 - 6,
    \item jakmile clovek urci disk, ktery selhal, je mozne zreprodukovat jeho obsah,
    \item priklad: 4 disky, 1 paritni, treti datovy selze
    \begin{itemize}
        \item prvni byty v datovych jsou 010 (potom v paritnim aby byl sudy pocet je 1), dalsi byty jsou 111 (licha parita, do paritniho disku se doplni 1 na sudou), dalsi jsou 011 (suda - v paritnim je 0)
        \item selze treti disk, vymeni se za novy, prazdny
        \item dopocitaji se data opet na sudou paritu: mam prvni byty 01? a v paritnim 1 - aby byla suda, v novem disku musi byt 0, dalsi byty 11? a v paritnim 1 - v novem musi byt 1, apod. ... \\
    \end{itemize}
\end{itemize}

\noindent\textbf{definice: (pro \ref{RAIDs}.x)} \\[0.5em]
\textit{RAID} = Redundant Array of Independent Disks \\[0.2em]
\textit{parita (bitu)} je sudost/lichost bitu, pocet sudych/lichych 1 bitu \\[0.2em]
\textit{parity bit} zn., ze na MSB se prida 1 pokud pocet 1 (bitu) je lichy \\

\subsection{Ulozeni dat na disku}
Diskova jednotka neumozni pracovat s nicim mensim nez sektor, ale typicky OS si sektory nejak seskupi (do vetsi jednotky) a neumozni pracovat s nicim mensim, nez je alokacni blok. \\

\noindent\textbf{Logicka a fyzicka naslednost:}
\begin{itemize}
    \item 1 alokacni blok se namapuje fyzicky za sebou na diskovem prostoru,
    \item vice alokacnich bloku jiz nemusi byt fyzicky na disku za sebou (filesystem se vsak snazi o to, aby tomu tak bylo) \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{alokacni blok} neboli cluster je skupina pevneho poctu sektoru, typicky mocnina 2 (nejmene $2^0$ = 1 alokacni blok), pro sektory v ramci alokacniho bloku je zaruceno, ze jdou za sebou logicky i fyzicky (na disku) v souboru, dale je to nejmensi jednotkou diskovou diskoveho prostoru, se kterym bezne pracuje jadro (filesystem, uzivatel). \\

\newpage

\subsection{Fragmentace}

\subsubsection{Externi fragmentace}

Rozumime jev, ktery vznika v pametech postupnym obsazovanim a uvolnovanim pameti, kdy v pameti vznika sekvence oblasti, ktere jsou volne a pouzite (a pouzite ruznymi soubory). \\

\noindent\textbf{Priklad externi fragmentace:}
\begin{itemize}
    \item na disku vytvorim soubor 1, zabira urcite misto,
    \item pote dalsi soubor 2,
    \item pote soubor 1 chci zvetsit, tak se soubor 1 rozdeli na 2 casti - soubor 1.1 (puvodni misto kde byl - pred s2) a soubor 1.2, ktery bude za souborem 2,
    \item stejnym zpusobem zvetsim soubor 2 a vznikne sekvence s1.1, s2.1, s1.2, s2.2,
    \item nyni se rozhodnu smazat prvni soubor a budu mit sekvenci volne misto, s2.1, volne misto, s2.2 == externi fragmentace. \\
\end{itemize}

\noindent Externi fragmentace je i na plne obsazenem disku, kde staci, aby byl disk obsazen soubory nespojite (tzn. jeden soubor je rozdelen do vice casti, neni ulozeny na jednom miste, napr. s1.1, s2, s1.2 nebo viz priklad hore). \\

\noindent\textbf{Negativni dopady externi fragmentace:}
\begin{itemize}
    \item na disku za urcitych okolnosti (v beznych FS nevznikaji) mohou vzniknout casti prostoru, ktere jsou jiz dale nevyuzitelne, protoze jsou prilis male (tldr vznik volnych useku, ktere nejdou vyuzit)
    \begin{itemize}
        \item okolnosti (pri kterych vzniknou nevyuzitelne casti prostoru): pri alokovani diskoveho prostoru spojite (na miru souboru ci jeho castem, nepridelovani po jednotkach pevne velikosti) a navic budu mit dolni mez urcujici velikost diskoveho prostoru tak, aby byl pouzitelny (muze vzniknout v souvislosti s tim, ze do pouzitych diskovych oblasti si mohu ukladat pomocne informace, k cemu se pouzivaji - pokud bude informace vetsi nez "volna dira" - nepouzitelna) - mam na disku bloky volneho mista o pozadovane velikosti (1GB, soubor, 0.5GB), ale protoze chci ukladat spojite (soubor o velikosti 1.5GB), nelze takove misto vyuzit
        \item vznikne nespojite rozlozeny soubor (viz priklad) a je nutne si pamatovat v pomocnych datech = metadatech informace o tom, kde jednotlive casti souboru jsou (ukladaji se na mista, kde jednotlive casti jsou, "odkazuji" se na dalsi metadata - dalsi casti smazaneho souboru),
    \end{itemize}
    \item cim vice casti souboru - tim vice metadat - cim vice fragmentovane - tim vice je pristup na data pomalejsi (u HDD se ceka navic na natoceni hlavicek a rotace disku) \\
\end{itemize}

\noindent\textbf{Souborove systemy se snazi negativni dopady fragmentace minimalizovat:}
\begin{itemize}
    \item rozlozeni souboru po disku (snaza ukladat soubory na disk tak, aby nebyly nutne za sebou, ale bylo mezi nimi volny prostor),
    \item pouzivani predalokace (uzivatel si pozada filesystem o vymezeni urciteho prostoru na disku, napr. databaze),
    \item odlozena alokace (=allocate-on-flush, filesystem nezapise ihned po zmene souboru, ale chvili pocka - pocita s tim, ze uzivatel bude chtit menit soubor "za chvili" znovu - az nebude delsi dobu dochazet ke zmenam, pote hleda vhodny volny prostor) \\
\end{itemize}

\noindent Pri (intenzivnim) beznem pouzivani disku se vsak fragmentaci nelze vyhnout. Pokud by byla fragmentace prilis vyrazna, je mozne pouzit defragmentacni nastroje, ktere provadeji kopirovani, presouvani casti souboru a reorganizaci diskoveho prostoru tak, aby se fragmentace odstranila - casove narocna operace. \\

\noindent Prvniho negativniho dopadu externi fragmentace (nevyuzitelne a prilis male oblasti) je mozne se zbavit pri pouzivani alokaci po jednotkach pevne velikosti - alokacni bloky - vzdy je ale snaha alokovat spojite (v horsim pripade alokuji nespojite, pokud to nejde) \\

\subsubsection{Interni fragmentace}
Nespojita alokace po jednotkach pevne velikosti (alokacni bloky) ma vyhodu, ze redukuje dopady externi fragmentace, ale potom vytvari interni fragmentace. Interni fragmentace se obvykle toleruje.  \\

\noindent\textbf{Priklad interni fragmetace:}
\begin{itemize}
    \item chci alokovat soubor o velikosti 9 000 B,
    \item mam 4 KiB velke alokacni bloky,
    \item potom je nutne alokovat 12 KiB pro tento soubor,
    \item ty zbyvajici 3 KiB v poslednim alokacnim bloku zustanou nevyuzite. \\
\end{itemize}

\noindent Existuje nekolik malo filesystemu, ktere se snazi resit interni fragmentaci (ReiserFS, ZFS) pomoci techniky zvane 'tail packing' ("zbavovani ocasku" souboru) - vice souboru muze pouzivat 1 fyzicky alokacni blok (zaplni se volne misto). Vetsine filesystemu toto vsak nepodporuje. \\

\newpage

\subsection{Pristup na disk} \label{pristup-na-disk-detailed}
(viz \ref{pristup-na-disk}) Proces kdyz chce nacitat/zpracovavat data, zavola sluzbu k tomu urcenou (read, write, .. - muze byt zabaleno i v nejakem knihovnim volani, napr. scanf zavola read), dojde k predani rizeni jadru, dostane se ke slovu jadro, podiva se do cache, pokud tam ta data ma, preda je, pokud ne, musi je nacist z disku - s diskem komunikuje pres I/O porty nebo pametove mapovane I/O porty, disku se predavaji prikazy pres jeho rozhrani (ATA disk - ATA prikazy), jdou z filesystemu pres ovladac prislusneho disku (pote to prochazi sbernicemi), ten komunikuje s radicem disku - disk dostane prikaz, jakmile dobehne operace, disk posle preruseni na procesor, tam se dostava ke slovu jadro, to zpracuje preruseni a zachova se podle nej (uspech - preda data, chyba - zpracuje ji). \\

\noindent\textbf{definice:} \\[0.5em] \label{ovladac}
\textit{ovladac} je software, ktery umi komunikovat s urcitym typem zarizeni, jina definice viz. \ref{ovladace}

\subsection{Planovani pristupu na disk}
Soucasti jadra je subsystem nazyvany planovac diskovych operaci, ktery shromazduje pozadavky od filesystemu (nacteni, zapsani dat z/do disku). Planovac si uklada pozadavky do svych planovacich front, pozadavky pripadne preusporadava a predava dal ovladaci ci radici disku k realizaci. \\

\noindent Planovac se snazi minimalizovat rezii disku. \\

\noindent Jednou ze strategii preusporadavani pozadavku (u HDD) je pouziti \textbf{vytahoveho alogritmu (elevator, SCAN alghorithm):}
\begin{itemize}
    \item snaha, aby se hlavicka disku plynule pohybovala od stredu k okraji a zpet a vyrizovat pozadavky dle pohybu hlavicky,
    \item modifikace SCAN algoritmu je napriklad Circual SCAN, kdy se pozadavky vyrizuji pouze pri jednom smeru,
    \item dalsi modifikace jsou LOOK a C-LOOK, kde se hlavicka nepohybuje od stredu k okraji, ale pouze v tom rozsahu, kde je potreba provadet operace. \\
\end{itemize}

\noindent\textbf{Planovac se muze snazit vice operaci sloucit do jedne operace} (napr. operace v ramci jednoho bloku se sdruzi):
\begin{itemize}
    \item takove kroky maji vyznam i u SSD,
    \item snaha vyvazovat pozadavky jdouci od jednotlivych uzivatelu (procesu),
    \item implementace priorit (prioritnejsi proces - pozadavky se vykonaji drive),
    \item snaha odkladat operace tak (v nadeji), ze je bude pote mozne sloucit,
    \item snaha implementovat casova omezeni na dobu cekani pozadavku,
    \item muze implementovat paralelizaci pozadavku predavanych do diskoveho subsystemu (modernejsi a velmi vykonne SSD umi resit operace  paralelne). \\
\end{itemize}

\noindent\textbf{linux:} \\ [0.5em]
pro zjisteni, jaky planovac pouzivame se staci podivat do \textit{/sys/block/$<$devname$>$/queue/scheduler} \\

\subsection{Logicky disk} \label{5.11}
V pocitaci je mozne mit vicero fyzickych disku, ktere je dale mozne rozdelit na logicke disky a konkretni souborove systemy je mozne instalovat na logicke disky. Pro spravu a vytvareni logickych disku lze pouzit programy cfdisk, disk, gparted, .. \\

\subsubsection{Zpusob ulozeni informaci o diskovych oblastech na disku}
\begin{itemize}
    \item MBR
    \begin{itemize}
        \item v prvnim (nultem) sektoru byla tabulka obsahujici rozdeleni na 1-4 primarni partitions
        \item pokud bylo nutne pouzit vice partitions, potom misto primarni se nahradila rozsirenou diskovou oblasti, ktera se dale mohla rozdelit na podoblasti zvane logicke diskove oblasti, kazda z nich popsana formou zretezeneho seznamu, EBR
        \item pouzivane u starsich PC
    \end{itemize}
    \item GPT
    \begin{itemize}
        \item je tabulka (pole) o az 128 odkazech na jednotlive diskove oblasti,
        \item stejny vyhrazeny prostor jako u MBR \\
    \end{itemize}
\end{itemize}

\subsubsection{LVM}
\begin{itemize}
    \item spravce logickych oblasti,
    \item umoznuje pokrocilejsi tvorbu logickych disku a
    \item do logickeho disku pridavat fyzicke disky (za behu),
    \item LVM muze byt bud primo ve filesystemu nebo v casti jadra (mezi filesystemem a planovacem). \\
\end{itemize}

\subsubsection{Ruzne typy souborovych systemu}
\begin{itemize}
    \item fs (prvni fs na unixu), ufs, ufs2,
    \item ext2, ext3, ext4,
    \item btrfs (inspirovan ZFS),
    \item ReiserFS, HSF+/APFS (Mac OS X), XFS, JFS, HPFS,
    \item FAT, VFAT, FAT32, exFAT (rodina FAT vznikla v MSDOS, pote pouzivany ve Windows - velmi jednoduche a siroce podporovane),
    \item F2FS (fs pro efektivni prace se SSD), ISO9660, UDF, Lustre, GPFS (clustery, superpocitace),
    \item ZoneFS (ZFS). \\
\end{itemize}

\noindent Po koupe noveho disku a rozdeleni na logicke disky je nutne se rozhodnout, jaky souborovy system na prislusnem logickem disku bude pouzivan - je nutne disk \textbf{zformatovat} pro pouziti. Drive se pouzivalo i nizkourovnove formatovani (stare disky s nestabilnim magnetickym zaznamem). \\

\newpage

\subsubsection{Chyby disku (souvislost s FS)}

\noindent Na disku mohou vznikat chyby beznym opotrebenim, nevhodnym vypnutim napajeni, je zapotrebi opravit ridici struktury souboroveho systemu (program fsck - kontroluje konzistenci filesystemu nebo zurnalovani, copy on write, soft updates, ..). \\

\subsubsection{Dalsi typy souborovych systemu} \label{VFS-old} 

\noindent\textbf{Virtualni souborovy system (VFS)} je vrstva, ktera v jadre zastresuje vsechny ostatni souborove systemy z toho duvodu, aby jine subsystemy jadra nemusely pracovat specialnim zpusobem s ruznymi souborovymi systemy. (viz take \ref{VFS-new})  \\

\noindent Existuji take ruzne sitove souborove systemy, treba NFS. (viz take \ref{NFS-more}) \\

\noindent\textbf{Specialni souborove systemy}
\begin{itemize}
    \item neukladaji zadna data, obsah neni nikde na disku ani neexistuje zadna specialni cast pameti
    \item zpristupnuji napr. aktualni stav jadra - adresar /sys, sysfs filesystem,
    \item procfs filesystem v adresari /proc zpristupnuje informace o bezicich procesech (ale i o nejakych castech stavu jadra),
    \item tmpfs zase vytvari souborovy system v RAM. \\
\end{itemize}

\noindent\textbf{definice: (pro \ref{5.11}.x)} \\[0.5em]
\textit{logicky disk} je taky diskova oblast, partition \\[0.2em]
\textit{MBR} = master boot record \\[0.2em]
\textit{EBR} = extended boot record \\[0.2em]
\textit{GPT} = GUID Partition Table, GUID = Globally Unique Identifier \\[0.2em]
\textit{LVM} = Logical Volume Manager \\[0.2em]
\textit{formatovani} zn., ze se nainstaluji metadata (ridici data) souboroveho systemu do prislusne diskove oblasti, v ramci toho se mohou vymazat vsechna data na dane oblasti \\[0.2em]

\newpage
\setlength{\parindent}{0pt}

\section{}
\textbf{Sesta prednaska:} pokracovani Spravy souboru. Zurnalovani, jeho implementace a alternativy, Copy-on-write, Klasicky UNIXovy system souboru FS, i-uzly, kde a jak jsou data ulozena, pocty odkazu, limit maximalni velikosti souboru, vyhody a nevyhody FS, jine zpusoby organizace souboru, EXT4, NTFS, Organizace volneho prostoru na disku, deduplikace, typy souboru v UNIXu, adresar, montovani disku
\subsection{Zurnalovani}
Je technika zalozena na vytvareni zurnalu.  \\

\begin{itemize}
    \item souborove systemy se zurnalem jsou treba ext3, ext4, ufs, XFS, JFS, NTFS, ..
    \item zurnalovani umoznuje spolehlivejsi (nikdy nemame obecne zajisteno, ze se nic spatneho stat nemuze) a     \item rychlejsi navrat (nez nejake utility) do konzistentniho stavu po chybach
    \item data obvykle zurnalovana nejsou (velka rezie), ale mohou byt
    \item zavisi na tom, ze operace, ktere zurnalovani implementuji, se provedou ve spravnem poradi -- nutnost spoluprace s planovacem, take disky si samy data preusporadavaji (nelze nijak ovlivnit) \\
\end{itemize}

\noindent\textbf{Zurnal:}
\begin{itemize}
    \item zapis zurnalu je p\v{r}ed\v{r}azen\'{y},
    \item vytvari se v nem cyklicky prepisovany buffer,
    \item p\v{r}ed\v{r}azenost zapisu do zurnalu mi zaruci, ze operace pokryte zurnalovanim jsou atomicke - vytvari transakce \\
\end{itemize}

Kompromis mezi zurnalovanim a nezurnalovanim dat je \textbf{p\v{r}ed\v{r}azen\'{i} zapisu dat na disk pred zapisem metadat do zurnalu} (a nasledne zapis ostrych metadat na disk). Priklad:
\begin{itemize}
    \item zapisuji do souboru - bud vytvarim zcela novy nebo ho zvetsuji (typicke zpusoby zapisu),
    \item pri zvetsovani se nejprve zapisou data na disk za existujici data (bez poznamenavani informace o tom, ze se soubor zvetsuje),
    \item pokud operace selze, soubor zustane v puvodnim stavu (diky neupravenym metadatum puvodniho souboru),
    \item teprve az data budou na disku, tak se do zurnalu zapise informace o zvetsovani souboru,
    \item pote se zmeni metadata souboru (a uzivatel se k datum dostane),
    \item pri selhani napajeni v moment, kdy jsou metadata v zurnalu, ale ne na disku, je mozne tyto metadata obnovit \\
\end{itemize}

\textbf{Proces mazani souboru na disku:}
\begin{itemize}
    \item odstraneni zaznamu z adresare,
    \item uvolneni uzlu (metadat souboru),
    \item uvolneni oblasti pouzitych tim souborem \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{zurnal} je specialni soubor ci specialni oblast na disku slouzici pro zaznamy modifikovanych metadat (dat o datech), pripadne i dat pred jejich zapisem na disk (v podobe beznych dat) \\[0.2em]
\textit{p\v{r}ed\v{r}azen\'{y}} znamena, ze zapis do zurnalu se provede pred ostrym zapisem "uzitecnych" dat (ci metadat) na disk \\[0.2em]
\textit{atomicke operace} zn., ze but operace uspeje cela (vsechny dilci kroky) nebo neuspeje vubec (zadny dilci krok) \\

\subsubsection{Implementace zurnalovani}
Existuji 2 zakladni pristupy k implementaci zurnalovani. \\
\textbf{REDO:}
\begin{itemize}
    \item implementace na zaklade dokonceni transakci,
    \item pouziva napr. ext3, ext4,
    \item sekvence dilcich operaci (vytvarejici tu operaci, kterou chci provest) se zapise do zurnalu (zacatek, konec transakce, kontrolni soucet),
    \item pote se operace provadi na disku,
    \item po uspesnem dokonceni se transakce ze zurnalu uvolni,
    \item pri selhani a pote zotaveni se system podiva do zurnalu, podiva se po neuvolnenych transakcich, jestli jsou cele - pocatecni a koncova znacka, jestli sedi kontrolni soucet - pokud vse sedi, tak system provede vsechny operace znovu \\

\end{itemize}
\textbf{UNDO:}
\begin{itemize}
    \item implementace na zaklade anulace transakci,
    \item v kombinaci s REDO se pouziva v NTFS,
    \item proklada zaznam dilcich operaci (ktere se maji provest) do zurnalu a nasledne jejich provedeni na ostrych datech (zaznamena dilci operaci - provede ji),
    \item probehne cela transakce - zaznam ze zurnalu se uvolni,
    \item pri chybe se eliminuji vsechny nedokoncene transakce (vsechny provedene dilci kroky se musi vratit - vrati se disk do puvodniho stavu) \\
\end{itemize}

Pri implementaci zurnalovani je klicove \textbf{dodrzeni poradi kroku, ve kterem se provadeji}. (U REDO napr. je nutne, aby se nejprve zapsaly sekvence operaci do zurnalu a teprve pote se provadely operace na disku) Pokud tato sekvence nebude dodrzena, zurnal nebude spravne fungovat. \\

\newpage

\subsubsection{Copy-on-write}
Je alternativa k zurnalovani pouzivana napriklad v ZFS (OpenZFS), BTRFS, ReFS (Resilient File System).
\begin{itemize}
    \item kopie pri zapisu,
    \item zalozeno na tom, ze vsechna nova data / metadata se zapisi na disk, a pote se zpristupni,
    \item vyuziva se pritom toho, ze obsah disku je popsam hierarchickou stromovou strukturou,
    \item zmeny se provadeji v souladu s touto strukturou (od listu ke koreni),
    \item pokud vypadne napajeni v moment, kdy data (bloky) nejsou jeste zpristupnena, data nejsou dostupne z korene stromu a jakoby se nic nestalo,
    \item pokud se mi tyto data podari zapsat uspesne, postupne zacnu upravovat vsechny uzly vedouci az ke koreni a zpristupnim nova data,
    \item teprve po modifikaci korenu se stanou zmenena data (uzly) dostupne
    \begin{itemize}
        \item koren je nutne zabezpecit, aby nedoslo k chybe pri zapisu do nej
        \item stary korenovy uzel se neprepisuje, ale pouze se tam zapise nova verze korenoveho zaznamu (s casovym razitkem)
        \item soucasne tam bude zabezpecovaci kod (kontrolni soucet),
        \item pokud dojde ke krachu systemu, staci si nacist vsechny koreny, zkontrolovat kontrolni soucty, vybrat si vsechny, kde sedi kontrolni soucty, s nejnovejsim casovym razitkem a tyto pouziju (pokud dojde k chybe nez se stihne zapsat novy koren, pouzije se ten puvodni) \\
    \end{itemize}
\end{itemize}

\textbf{Vyhodami copy-on-write jsou:}
\begin{itemize}
    \item snimky souboroveho systemu (zapamatuje se pouze korenovy uzel - minimalni rezie),
    \item klony souboroveho systemu (vytvori se pozadovany pocet kopii korenoveho uzlu),
    \item vyhodou je, ze nezmenene uzly (data) a listy budou na disku pouze jednou, pouze je nutne si pamatovat zmenene uzly / listy a cestu ke koreni + koren (kopie stale ukazuji na stejny strom). \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{stromova struktura} (copy-on-write) je vyhledavaci strom, ktery popisuje veskery obsah disku, typicky se v nem vyhledava na zaklade unikatni identifikace souboru \\[0.2em]
\textit{adresare} (copy-on-write) jsou specialni soubory ulozeny na disku, ktere jsou dostupne ve strome (stromove strukture) \\[0.2em]
\textit{snimek souboroveho systemu} ulozi se obsah disku tak, ze je mozne se k nemu pozdeji vratit \\[0.2em]
\textit{klon souboroveho systemu} je vytvoreni 2 kopii souboroveho systemu a od daneho okamziku je mozne s kazdou kopii pracovat samostatne (napr. pri vetsim poctu VM, kdy vsechny VM sdili stejny pocatecni obsah disku, ale od urciteho momentu kazda VM chce obsah menit samostatne) \\

\newpage

\subsubsection{Dalsi alternativy zurnalovani}
\textbf{Soft updates:}
\begin{itemize}
    \item pouziva se v UFS (FreeBSD systemy),
    \item filesystem se snazi sledovat zavislosti mezi tim jaka data a metadata se meni,
    \item uzpusobuje poradi zapisu metadat a dat na disk tak, aby v jakemkoli okamziku byl obsah na disku konzistentni (az na moznost vzniku "garbage") \\
\end{itemize}

\textbf{Log-structured file systems:}
\begin{itemize}
    \item logovaci souborove systemy (= strukturovane jako log),
    \item pouziva se v LFS, UDF, F2FS,
    \item cely souborovy system ma charakter jednoho velkeho logu,
    \item ktery se zapisuje v cyklicky prepisovane pameti napric celym diskem,
    \item posledni obsah disku je vzdy dostupny pres posledni zaznam (a odkazy, ktere z nej vedou),
    \item pri provadeni zmen se pridaji data napr. za aktualni konec vyuziteho diskoveho prostoru, prida se k tomu zaznam (o tom co se zmenilo), zpristupni se data z posledniho zaznamu. \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{"garbage"} je cast prostoru na disku, ktera se tvari jako obsazena, ale neni \\[0.2em]
\textit{logem} rozumime soubor, ktery obsahuje zaznamy o zmenach (nebo: log = zapis o zmenach) \\

\newpage

\subsection{Klasicky UNIXovy system souboru (FS)}
Je puvodni filesystem unixu (70. leta). Vyvinul se z nej UFS, z nej zase EXT2, 3 (pote vznikl i EXT4). \\

\textbf{Souborovy system byl rozclenen (na urovni logickych disku) na:}
\begin{itemize}
    \item boot blok - obsahoval informace (kod, cast kodu) potrebne pro zavedeni pri startu,
    \item super blok - informace o souborovem systemu (typ, verze, velikost, pocet i-uzlu, volne misto, korenovy adresar, volne i-uzly, ..),
    \item tabulka i-uzlu - tabulka (pole n i-uzlu) pouzita s popisy souboru,
    \item datove bloky - data souboru, metadata (pomocne adresovaci bloky). \\
\end{itemize}

\textbf{Zakladni rozlozeni FS bylo zmodifikovano v navazujicich filesystemech:}
\begin{itemize}
    \item datove bloky byly rozdeleny do skupin, 
    \item kazda skupina mela svoje i-uzly,
    \item duvodem byla lepsi lokalita, prostorova blizkost dat a metadat (typicky pri praci se soubory jsou nutne i jeho metadata),
    \item pote tedy ta struktura vypadala takto: boot blok, super blok, usek i-uzlu, usek dat, usek i-uzlu, usek dat, .. \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{i-uzel} je zakladni datova struktura reprezentujici kazdy jeden soubor v typickych UNIXovych systemech (pozn. pri formatovani se urci dopredu maximalni pocet souboru, ktere na diskovem oddilu budou existovat) \\

\subsubsection{i-uzel}
Zakladni datova struktura popisujici soubor v UNIXu (nebo viz definice hore). Ke kazdemu souboru musi byt i-uzel. Ten obsahuje metadata o souboru: 
\begin{itemize}
    \item stav i-uzlu (alokovany, volny)
    \item typ souboru (obycejny, adresar, zarizeni, pojmenovana roura, ..),
    \item delka souboru v bajtech,
    \item casy mtime (posledni modifikace dat - zapis), atime (posledni pristup - cteni), ctime (posledni modifikace i-uzlu),
    \item UID, GID,
    \item pristupova prava (cislo, napr. 0644 = rw-r--r--),
    \item pocet pevnych odkazu (neboli jmen souboru),
    \item informace o tom, kde se nachazi data o souboru (tabulka odkazu na datove bloky a dalsi informace nebo odkazy na pomocne bloky s dalsimi metadaty, napr. ACL, extended attributes, dtime - udaj o smazani souboru, ..) \\
\end{itemize}

Jmeno souboru neni v i-uzlu, ale je ulozeno v adresari. \\

\textbf{definice:} \\[0.5em]
\textit{UID} je cislo identifikace vlastnika \\[0.2em]
\textit{GIT} je cislo identifikace skupiny \\[0.2em]
\textit{ACL} zn. Access Control List, pristupove seznamy rozsirujici zakladni UNIXova prava tak, ze je mozne priradit konkretni prava ke konkretnim uzivatelum \\[0.2em]
\textit{extended attributes} zn. rozsirene atributy, s jakymi specifickymi prave se muze soubor napr. spoustet \\[0.2em]
\textit{ctime} je posledni zmena i-uzlu, vyuzitelne napr. pokud se zfalsuje mtime, posledni zmena souboru se pozna prave podle ctime \\

\subsubsection{Kde a jak jsou ulozena data}
\begin{itemize}
    \item v i-uzlu je rada primych (az 10, novejsi unixove fs maji 12) i neprimych odkazu na data,
    \item prime odkazy odkazuji na alokacni bloky na disku,
    \item pokud je potreba vice odkazu, pouzije se neprimy odkaz prvni urovne, ktery odkazuje na specialni alokacni blok neobsahujici data, ale dalsi prime odkazy na data,
    \item pokud nestaci ani to, pouzije se neprimy odkaz druhe urovne, ktery odkazuje na pomocny adresovaci blok, ktery obsahuje dalsi neprime odkazy 1. urovne, ktere odkazuji na dalsi prime odkazy (a ty odkazuji na data) - vznika strom
    \item pokud ani to stacit nebude, pouzije se adresovaci blok 3. urovne, vedouci na adresovaci bloky s neprimymi odkazy 2. urovne, kazdy z nich na bloky s odkazy 1. urovne, ty vedou na prime odkazy a ty na data.
\end{itemize}

\begin{figure}[htb]
    \centering
    \scalebox{1.6}{\includegraphics{6.2.2.jpg}}
    \caption{z prezentace IOS: Souborove systemy, slide 23 - odkazy v i-uzlech}
\end{figure}

\newpage

\subsubsection{Pocty odkazu}
\begin{itemize}
    \item neprimy odkaz 1. urovne - pri 4 KiB clusteru je to 1024 odkazu (1 odkaz = 4B) = 1024 datovych bloku,
    \item neprimy odkaz 2. urovne - pri 4 KiB clusteru je to $1024^2$ odkazu = stejny pocet datovych bloku,
    \item neprimy odkaz 3. urovne - pri 4 KiB clusteru je tam $1024^3$ odkazu = stejny pocet datovych bloku \\
\end{itemize}

\subsubsection{Limit maximalni velikosti souboru}

Poctem primych odkazu neprimeho odkazu 3. urovne je dan maximalni pocet bloku, ktere je mozne v tomto souborovem systemu ulozit. Teoreticky limit velikosti souboru je tak:
$$10 * D + N * D + N^2 * D + N^3 * D$$
kde $D$ je velikost bloku v bajtech (bezne 4096B), $M$ je velikost odkazu na blok v bajtech (bezne 4B), $N = D/M$, je pocet odkazu v bloku. \\

Toto omezeni velikosti je pouze jednim z omezenim, ktere velikosti souboru omezuji. \textbf{Dalsi omezeni jsou dana:}
\begin{itemize}
    \item dalsimi datovymi strukturami a typy, ktere pouziva FS (napr. datovy typ delky souboru v bajtech v i-uzlu),  
    \item strukturami VFS (veskera prace s jakymkoli filesystemem musi projit pres VFS),
    \item rozhranim jadra,
    \item architekturou systemu (32b - velikost souboru bude 32b cislo + MSB je pouzit pro indikaci chyby [-1 bit pro data] - soubory maximalne do 2 GiB nebo dnes bezna architektura 64b - 64b velikosti) \\
\end{itemize}

\textbf{Existuje Large File System Support}, kde ve 32b systemu se nahradi vsechny udaje kde se pracuje s velikosti vetsim datovym typem - podpora souboru \textit{vetsich jak 2 GiB}. \\

\textbf{linux:} \\[0.5em]
\textit{du [soubor]} vypise zabrane misto v blocich vc. rezie (metadat) \\[0.2em]
\textit{ls -l [soubor]} vypise velikost souboru v bajtech (pouze uzitecna data) \\[0.2em]
\textit{df} vypise volne misto na discich \\[0.2em]
\textit{ls -i [soubor]} zpristupni cislo i-uzlu souboru \\[0.2em]
\textit{is -e /dev/... n} - vypis i-uzlu n na /dev/... \\[0.2em]
\textit{dumpe2fs} - zakladni informace o souborovem systemu ext2,3,4 \\[0.2em]
\textit{/dev/zero} je soubor typu zarizeni generujici proud 0 \\[0.2em]
\textit{dd if=[source] of=[dest]} je nizkourovnove kopirovani \\

\newpage

\subsubsection{Vyhody a nevyhody architektury FS}
Neboli proc bylo navrzen FS prave tak, jak je. Architektura FS je totiz ovlivnena snahou o minimalizaci jejich rezie s relativne pomalymi disky (HDD, SDD), jedna se zejmena o bezne operace se soubory, jako je pruchod soubourem (otevru - prochazim od zacatku do konce) ci presun (seek), zvetsovani ci zmensovani (vc. mazani) souboru. \\

\textbf{Je nutne vzit do uvahy, z jakych (mikro)operaci se tyto operace sestavaji}. Jsou to operace:
\begin{itemize}
    \item vyhledavani adresy prvniho nebo urciteho bloku souboru,
    \item vyhledavani nasledujicich bloku,
    \item pridani ci odebrani bloku,
    \item alokace ci dealokace volneho souboru (informace o volnych oblastech, minimalizace externi fragmentace) \\
\end{itemize}

FS a jeho naslednici UFS, EXT2, EXT3 (EXT4 uz neni jeho naslednik!) predstavuji kompromis s ohledem prevazne na male soubory. (tyto fs funguji skvele pro male soubory - u vetsich souboru je nutne prochazet ci menit vetsi objem metadat) \\

Jistou optimalizaci pouzivanou i u klasickych filesystemu pro male soubory je ulozeni dat primo do i-uzlu. (pokud se tam data vlezou). \\

\textbf{definice:} \\[0.5em]
\textit{symbolicky odkaz} je soubor odkazujici na jiny soubor (pouziva ulozeni dat primo do i-uzlu) \\[0.2em]
\textit{rychle symlinky} maji data v i-uzlu \\[0.2em]
\textit{pomale symlinky} maji data mimo i-uzel

\newpage

\subsection{Jine zpusoby organizace souboru}
\subsubsection{Kontinualni ulozeni}
\begin{itemize}
    \item neboli spojite ulozeni souboru na disku,
    \item na disku je jeden spojity usek dat reprezentujici soubor,
    \item vyhodami jsou rychle vyhledani adresy 1./urciteho bloku nebo vyhledavani nasledujicich bloku,
    \item nevyhody: soubory nebude mozne jednoduse zvetsovat pokud budou prilis blizko u sebe (bude nutne jej presunout na jine volne a vetsi misto, pokud to pujde ci provest defragmentaci a pote zvetsit soubor)
    \item nepouziva se prilis (kvuli sve nevyhode) \\
\end{itemize}

\subsubsection{Zretezene seznamy alokacnich bloku}
\begin{itemize}
    \item kazdy alokacni blok obsahuje sva (uzitecna) data a na konci obsahuje odkaz na nasledujici alokacni blok,
    \item vyhodami jsou rychly pristup na zacatek ci pruchod daty,
    \item nevyhodou je presun na nahodne misto v souboru - nutnost precist cely soubor az po dany blok (1 GiB soubor, chci posledni blok - musim precist cely),
    \item dalsi nevyhodou je rozprostreni metadat po celem disku - pri drobne chybe na disku prijdu o data (tedy i metadata, kde jsou odkazy na nasledujici bloky) a dojde k velke ztrate dat (vsechna data "za" ztracenymi daty jsou nepristupna),
    \item neni prilis vhodna, nicmene se pouziva v souborovych systemech FAT \\
\end{itemize}

\subsubsection{FAT}
\begin{itemize}
    \item File Allocation Table,
    \item od zretezenych seznamu se lisi tim, ze seznamy popisujici rozlozeni souboru na disku jsou ulozeny v separatni oblasti na disku (tzv. FAT),
    \item kde jsou tato data koncentrovana - rychleji se prohledavaji, lze vytvorit tak vice kopii FAT (prevence okamzite ztraty dat pri chybe),
    \item stale vznikaji problemy s rychlosti pri nahodnem pristupu (stale jde o zretezeny seznam)
    \item tabulka je pole, ktere obsahuje pro kazdy blok na disku 1 polozku, kazda polozka obsahuje odkaz na dalsi blok/polozku,
    \item pouziva se i dodnes (a je to velmi rozsirene), protoze je to jednoduche (napr. vestavene systemy) \\
\end{itemize}

\newpage

\subsubsection{B+ stromy}
\begin{itemize}
    \item jsou datovou strukturou prevzatou z databazovych systemu,
    \item maji dva typy uzlu - vnitrni a listove,
    \item vnitrni uzly jsou koren, jeho naslednici krome listovych, obsahuji odkaz na naslednika a vyhledavaci klic,
    \item listove uzly take obsahuji odkazy a vyhledavaci klice, odkazy vedou na data na disku, posledni odkaz na poslednim listu odkazuje na list na stejne urovni (jsou tak propojeny linearnim seznamem),
    \item pouzivaji se za ucelem popisu rozlozeni dat na disku (obsah souboru, pote vyhledavaci klic bude offset - cislo logickeho bloku v ramci souboru) nebo se pouzivaji pro adresare (klice budou jmena souboru) nebo pro popis celeho obsahu disku (klic je dvojice i-uzel a posuv souboru) \\
\end{itemize}

\textbf{Vyhledavani v B+ stromu:}
\begin{itemize}
    \item pri hledani klice (k) se podivam, zda je klic mensi jak klic k0, pokud ano, pujdu nize, kde je k00, pokud ne, zjistim, jestli je klic mezi k0 a k1, pokud ano, jdu druhym smerem, opakuji po kn,
    \item pokud jsem niz, opakuji to same co vys az nedojdu k listovym uzlum,
    \item zde hledany klic najdu nebo zjistim ze v teto strukture klic neni
    \item pote mam odkaz na datovy blok,
    \item v pripade ze chci cist dal, tak jdu linearne po sobe po nasledujicich listovych uzlech \\
\end{itemize}

\begin{figure}[htb]
    \centering
    \scalebox{2}{\includegraphics{6.3.4.jpg}}
    \caption{z prezentace IOS: Souborove systemy, slide 27 - B+ strom}
\end{figure}

\newpage

\textbf{Prace s B+ stromy:}
\begin{itemize}
    \item jsou zde limity jak moc/malo maji byt uzly zaplneny (strom se udrzuje vyvazeny) - pro uzly s $m$ odkazy mame klice $0, 1$, .. az $m - 2$ klicu (odkazu je o 1 mene nez klicu + cislovani od 0), 
    \item pokud je strom tvoren solo korenem - nejmene muze mit $1$ odkaz, maximalne $m - 1$ odkazu (posledni odkaz je pouzit jako ukoncovac seznamu listu),
    \item pokud to neni solo koren, tak ma nejake nasledniky, minimalne jich ma tak $2$, maximalne $m$,
    \item vnitrni uzel ma tak $\frac{m}{2}$ (zaokr. nahoru) az $m$ odkazu, list $\frac{m}{2} - 1$ (opet $\frac{m}{2}$ zaokr. nahoru) az $m - 1$ odkazu,
    \item vlozeni:
    \begin{itemize}
        \item nejprve projdeme stromem od korene k listum,
        \item najdeme kam chceme vlozit,
        \item podivame se, zda ma list volny odkaz,
        \item pokud ano - pouzijeme ho, pokud ne - list se rozstepi na 2 poloviny a podivam se o uroven vys, zda je mozne namisto 1 listu linkovat 2 listy,
        \item pokud ano - prida se odkaz, pokud ne - nadrazeny uzel se musi rozstepit a postupovat o uroven vys,
        \item ... stepi se strom az pripadne se rozstepi koren a strom bude mit 2 koreny
    \end{itemize}
    \item ruseni:
    \begin{itemize}
        \item se opet od listove urovne, tak, ze se zrusi odkaz v listu,
        \item zkontroluje se, zda je uzel zaplneny v ramci danych limitu,
        \item pokud ano - gut, pokud ne - podivam se na sousedni uzly a pokud se provest prerozdeleni tak, aby byly vsechny uzly naplneny v ramci limitu,
        \item pokud se to nepodari, tak dojde ke slouceni listu,
        \item posunu se o uroven vys, zrusim jeden odkaz, zkontroluji opet limity, zopakuji to same,
        \item ... az se muze stat, ze se zrusi i koren \\
    \end{itemize}
\end{itemize}

B+ stromy a jeho varianty jsou pouzivany pro popis diskoveho prostoru v filesystemech jako
XFS, JFS, ZFS, Btrfs, ReFS, ..
v omezene podobe tzv. stromu extentu v EXT4, podobna struktura je i v NTFS \\

\textbf{definice:} \\[0.5em]
\textit{solo koren} = jediny koren

\newpage

\subsubsection{Extent}
\begin{itemize}
    \item pouziva se ke zrychleni prace s velkymi soubory,
    \item umoznuji zmensit objem metadat (je mozne rict, ze nektere alokacni bloky jsou ulozeny pospolu = vytvari extent), potom budu popisovat rozlozeni souboru po extentech (ne po alokacnich blocich),
    \item prinese lepe vyvazene indexove struktury,
    \item rychlejsi mazani,
    \item jsou pouzity snad ve vsech systemech s B+ stromy,
    \item B+ strom se snadno kombinuje s extenty (neplati pro klacicky Unixovy strom - protoze ve stromu jsou explicitne ulozene vyhledavaci klice, ale Unixovy nema v zadnych strukturach [i-uzel] ulozenou velikost datovych bloku [protoze jsou vsechny stejne a konstantni]) \\
\end{itemize}

Pokud pouzivame B+ stromy, tak rychlemu spojitemu pruchodu pomaha listova uroven, pokud je prolinkovani listu pouzito. Pro male soubory muze predstavovat B+ strom zbytecnou rezii (data se bud ulozi primo v i-uzlu nebo nebo z nej mame prime odkazy na extenty z i-uzlu [do max. 4 extentu]) \\

\textbf{definice:} \\[0.5em]
\textit{extent} je jednotka vystavena na bloky, posloupnost promenneho poctu alokacnich bloku (jdoucich za sebou logicky v souboru i fyzicky na disku) \\

\newpage

\subsection{EXT4}
Pouziva pro popis rozlozeni dat na disku strom extentu. Pro "male soubory" (mysleno soubory, na ktere je mozne se odkazovat az 4 extenty, pak tyto extenty budou odkazovane primo z i-uzlu; tldr soubory s malym poctem extentu) \\

\textbf{definice:} \\[0.5em]
\textit{strom extentu} je v principu B+ strom degradovany na maximalne 5 urovni, bez pouzivani vyvazovani (napr. prerozdelovani uzlu pri mazani) a zretezeni listu \\

\subsection{NTFS}
Zakladni datovou strukturou popisujici disk je MFT - Master File Table (ma pro kazdy soubor alespon 1 radek, na 0. radku popisuje samo sebe, 1. radek pripadne kopie MFT, pripadne metadata, pote obsahy souboru).  \\

\textbf{Obsah souboru muze byt reprezentovan bud:}
\begin{itemize}
    \item pokud jde o kratky soubor, bude ulozen v MFT v jeho radku (vcetne metadat),
    \item soubor je rozdelen na extenty (ty jsou odkazovane primo z radku souboru v MFT, tak ze v radce souboru jsou informace o pocatecnim VCN a LCN a pocet clustero, ktery dany extent obsahuje) - vyhledava se v tom stejne jako v B+ stromu
    \item pokud je extentu potreba vice nez se vleze na jeden radek, alokuji se pomocne radky (z hlavniho radku vedou odkazy na pomocne, z pomocnych vedou odkazy na disk) - prochazeni je opet ve stylu B+ stromu \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{VCN} - virtual cluster number, logicky blok souboru \\[0.2em]
\textit{LCN} - logical cluster number, cislo fyzickeho bloku (souvisi s tim ze je to na logickem disku) \\

\subsection{Organizace volneho prostoru na disku}
V klasickem Unixovem FS a rade jeho nasledovniku (UFS, EXT2, 3), take v NTFS se pouzivaji bitove mapy, kde pro kazdy blok mam 1 bit. V bitove je mozne pote vyhledavat pomoci bitovych mask - zrychli vyhledavani. \\

\textbf{Dalsi mozne zpusoby organizace volneho prostoru:}
\begin{itemize}
    \item pouziji se alokacni seznamy (zretezeni volnych bloku na disku),
    \item zretezeni volnych polozek v tabulce (FAT),
    \item B+ strom (udrzovani informaci o tom, kde je volne misto, adresace velikosti a/nebo offsetem)
    \item volny prostor muze byt take organizovan po extentech. \\
\end{itemize}

\newpage

\subsection{Deduplikace}
\begin{itemize}
    \item podporovana ZFS, NTFS, Btrfs, XFS, (ext4 ne) ..
    \item snazi se odhalit opakovane ukladani stejnych dat na disk a ulozi je pouze jednou a odkazuje se na ne vicenasobne.
    \item systemy s deduplikaci se snazi takova data detekovan (sekvence bitu, bloku, extentu, ..)
    \item zalozeno na kryptografickem hashovani (hledaji se data se stejnym popisem, urci se shoda),
    \item muze byt realizovano pri zapisu nebo dodatecne (zadost uzivatele),
    \item muze usporit diskovy prostor (pri virtualizaci, na mail serverech, repozitare, ..), pametovy prostor i cas (zamezi se opakovanemu cteni i zapisu),
    \item pri mensim objemu duplikace muze naopak zvysit spotrebu CPU casu, spotrebu pametoveho i diskoveho prostoru \\
\end{itemize}

\textbf{Rozdil oproti copy-on-write:}
\begin{itemize}
    \item copy-on-write se muze uchytit (klony, snimky) pouze tehdy, pokud duplikaty vzniknou cinnosti samotneho filesystemu (napr. vytvoreni virtualek),
    \item zatimco deduplikace aktivne vyhledava duplikaty (napr. uzivatel, co stahuje stejne reklamni letaky) \\
\end{itemize}

\subsection{Typy souboru v UNIXu}
\begin{itemize}
    \item - je obycejny soubor,
    \item d adresar,
    \item b blokovy specialni soubor,
    \item c znakovy specialni soubor,
    \item l symbolicky odkaz (symlink),
    \item p pojmenovana roura,
    \item s socket \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{specialni soubor} je typ souboru reprezentujici hardwarove zarizeni (disk, hw, pamet) se kterym se komunikuje po blocich nebo znacich \\[0.2em]
\textit{symbolicky odkaz} je soubor obsahujici jmeno jineho souboru (odkazuje na nej) \\

\newpage

\subsection{Adresar}
Je to kolekce jinych souboru na nejvyssi urovni abstrakce. Soubor obsahuje mnozinu dvojic jmeno a unikatni ciselne oznaceni. \\

\textbf{Jmeno souboru:}
\begin{itemize}
    \item drive limit 14 znaku, dnes az 255 (na konci musi byt '\verb|\0|')
    \item ve jmene nesmi byt / nebo '\verb|\0|' \\
    \item lati ze kazdy adresar v POSIX systemu vzdy obsahuje minimalne 2 jmena: . (odkaz na sebe) a .. (odkaz na rodicovsky adresar)
\end{itemize}

\textbf{Cislo souboru:}
\begin{itemize}
    \item u klasickeho souboru unixu je to cislo i-uzlu,
    \item v jinych pripadech to slouzi jako klic do dane vyhledavaci struktury (B+ strom) \\
\end{itemize}

\textbf{Implementace adresaru:}
\begin{itemize}
    \item pouzivaji se ruzne pristupy, lisi se jednoduchosti implementace ci rychlosti vyhledavani (vkladani),
    \item seznam (obsah souboru bude tvorena seznamem),
    \item B+ stromy (v NTFS, XFS, JFS, APFS nebo EXT3/4 - ty pouzivaji H-stromy: 1-2 urovne, bez vyvazovani a vyhledava se na zaklade zahashovaneho jmena)
    \item hashovaci tabulky v napr. ZFS \\
\end{itemize}

Soubor v UNIXu muze mit vice jmen. Dalsi jmena se vytvari pomoci prikazu ln \\

\textbf{linux:} \\[0.5em]
\textit{ln [existujici jmeno] [nove jmeno]} vytvori dalsi jmeno souboru \\

\newpage

\subsection{Montovani disku}
\textbf{Princip motnovani disku:}
\begin{itemize}
    \item v UNIXu neni zadne oznaceni disku (A:, C:, ..), ale mame jeden adresarovy "strom",
    \item v systemu je jeden korenovy logicky disk,
    \item dalsi logicke disky se pripojuji programem \textit{mount} do existujiciho adresaroveho stromu (korenovy adresar zarizeni se "slepi" s adresarem v mem stromu) \\
\end{itemize}

Pripojovaci volby se mohou zadavat rucne (v terminalu) nebo se mohou predpripravit do /etc/fstab. Soubor /etc/mtab obsahuje tabulku aktualne pripojenych disku. \\

\textbf{Novejsi technologie umoznuji automaticke montovani nove pripojenych zarizeni:}
\begin{itemize}
    \item na linuxu bezne pracuje system udev, ktery
    \item rozpozna, ze se pripojilo nove zarizeni,
    \item vytvori odpovidajici soubor typu blokove zarizeni (/dev/..),
    \item informuje o tom zbytek systemu pomoci sbernice D-Bus,
    \item aplikace typu spravce souboru pak muze provest automaticke montovani (a dalsi akce),
    \item prednost ma vzdy /etc/fstab,
    \item identifikace se nemusi provadet jen zarizenim (/dev/..), je mozne si vygenerovat unikatni identifikator a pouzivat ten (UUID) \\
\end{itemize}

\textbf{Technologie Automounter:}
\begin{itemize}
    \item subsystem jadra,
    \item pripojuje automaticky potrebne disky v situaci, kdy se pokusime pristoupit na pozici adresaroveho stromu, kam by takovyto disk mel byt pripojeny (napr. na /mnt ma byt pripojena flashka, nemusi byt mountla, uzivatel da cd /mnt, automounter to zjisti a pripoji flashku sem),
    \item ma take nejaky cas, po kterem disk automaticky odpoji, pokud se nim nepracuje  \\
\end{itemize}

\textbf{Union mount:}
\begin{itemize}
    \item technologie umoznujici sjednocujici montovani (v unixu dostupna pomoci filesystemu UnionFS),
    \item umoznuje do jednoho pripojneho bodu namontovat vice disku,
    \item obsah pripojneho bodu je sjednocenim obsahu disku,
    \item v pripade, ze na vice discich jsou soubory se stejnymi jmeny vznikaji kolize, ty se resi napr. preddefinovanim priorit pripojovanych filesystemu a zpristupni se soubor daneho jmena z logickeho disku, ktery ma nejvetsi prioritu
    \item UnionFS ma copy-on-write semantiku, coz umoznuje emulaci prepisovani neprepisovatelnych medii (v 1 vetvi CD, neprepisovatelne, na tom je linuxova distribuce, soucasne se do stejneho bodu pripoji bezny disk s vyssi prioritou - na zacatku bude disk prazdny, budou videt vsechny soubory z CD, jakmile se pokusim prepsat neco, UnionFS vytvori kopii na prepisovatelny disk) \\
\end{itemize}

\textbf{linux:} \\[0.5em]
\textit{mount [co-pripojit] [kam-pripojit]} pripoji logicky disk \\

\newpage

\section{}
\textbf{Sedma prednaska:} Pokracovani Spravy souboru. Symbolicke odkazy, 
\subsection{Symbolicke odkazy}
\begin{itemize}
    \item je samostatny soubor odkazujici na existujici soubor,
    \item system pri otevreni automaticky otevre cilovy souboru - vicenasobne zpracovani cesty (ceska k symlinku a cesta uvnitr nej),
    \item soubor se smaze, pokud jeho pocet jmen klesne na 0,
    \item symlink muze odkazovat na neexistujici soubor (pri otevreni dojde k chybe),
    \item muze odkazovat i na jiny logicky disk,
    \item lze ze symlinku vytvorit cyklkus (jeden odkazuje na druhy a druhy na prvni) - v systemy je preddefinovany maximalni pocet na sebe odkazujicich symlinku (pri prekroceni dojde k chybe),
    \item symlinky lze vyuzit napr. pri upgradu systemu. \\
\end{itemize}

\textbf{Rozdil rychlych/pomalych symlinku:}
\begin{itemize}
    \item obsahem symlinku je jmeno ciloveho souboru,
    \item pokud jmeno souboru neni prilis dlouhe (vleze se do i-uzlu), potom se ulozi do i-uzlu = rychly symlink (staci otevrit jen i-uzel),
    \item pokud se jmeno nezleve do (i-uzlu), alokuji se normalne alokacni bloky na disku = pomaly symlink \\
\end{itemize}

\textbf{linux:} \\[0.5em]
\textit{ln -s [existujici soubor] [symbolicky odkaz]} vytvori symbolicky odkaz \\

\newpage

\subsection{Blokove a znakove specialni soubory} \label{blok-char-hw}
Soubory reprezentujici rozhrani souboroveho systemu k fyzickym (opravdovy hw) ci virtualnim zarizenim (xterminaly, ..). Souborovy system vyvtari souborove rozhrani, tim umoznuje tyto soubory pri urcitych operacich identifikovat (jmeno soubory, napr. /dev/sdX), s celym zarizenim lze take pracovat jako se souborem. \\

Typicky zarizeni sidli v adresari /dev \\

\textbf{Bezne typy zarizeni:}
\begin{itemize}
    \item /dev/hda - (drive)oznaceni pro prvni fyzicky disk na prvnim ATA/PATA rozhrani
    \item /dev/hda1 - (drive) prvni logicky disk na hda
    \item /dev/sda - prvni fyzicky disk SCSI, navic i disky SATA/PATA (jadro nad temito disky emuluje SCSI)
    \item /dev/mem - obsah pameti (RAM)
    \item /dev/zero - nekonecny zdroj 0 bajtu
    \item /dev/null - soubor typu cerna dira - cokoli se do nej zapise, do se zahodi (presmerovani vystupu programu tak, aby nas neotravoval), pri cteni se tvari jako prazdny soubor
    \item /dev/random - generator nahodnych cisel
    \item /dev/tty - terminal
    \item /dev/lp0 - tiskarny
    \item /dev/mouse - mys
    \item /dev/dsp - zvukova karta
    \item /dev/loop - zarizeni typu (smycka) loop mi umoznuje pripojit soubor jako disk (obraz souboroveho systemu) k adresari, jakoby se jednalo o novy fyzicky disk \\
\end{itemize}

Tato oznaceni zavisi na pouzitem systemu (Linux, distribuce, ..). Vyhoda zavedeni specialnich souboru je, ze umoznuji identifikovat zarizeni, se kterymi chci pracovat. \\

\newpage

\subsection{Pristupova prava}
V UNIXu jsou typicky rozlisena na prava pro vlastnika, skupinu vlastniku a ostatni.
Existuje rozsireni ACL (access control list). \\

\textbf{Uzivatele:}
\begin{itemize}
    \item jsou definovani administratorem systemu (root) v /etc/passwd,
    \item maji definovana sva UID - uzivatelska cisla (root UID = 0),
    \item kazdy soubor ma sveho vlastnika,
    \item chown - zmena vlastnika souboru (pouze root), \\
\end{itemize}

\textbf{Skupiny:}
\begin{itemize}
    \item definuje administrator systeu v /etc/group,
    \item maji sva GID - cislo identifikujici skupinu uzivatelu,
    \item v kazde skupine je uvedeno, kdo do te skupiny patri,
    \item kazdy uzivatel muze byt clenem vice skupin,
    \item jedna z nich je aktualni (pouziva se pri vytvareni souboru) \\
\end{itemize}

\textbf{linux:} \\[0.5em]
\textit{groups} - vypis skupin uzivatele \\[0.2em]
\textit{chgrp} - zmena skupiny souboru \\[0.2em]
\textit{newgrp} - novy shell s jinym aktualnim GID \\

\newpage

\subsection{Typy pristupovych prav}
\textbf{Obycejne soubory:}
r, w, x - pravo cist, zapisovat a spustit soubor jako program. \\

\textbf{Adresare:}
\begin{itemize}
    \item r - pravo cist obsah adresare,
    \item w - pravo zapisovat (vytvaret a rusit soubory),
    \item x - pravo pristupovat k souborum v adresari (moznost cd adresar, ls -l adresar, ..) \\
\end{itemize}

\textbf{Typicky vystup pristupovych prav je:}
\begin{itemize}
    \item ve formatu: [1:typ souboru] [3:prava vlastnika] [3:prava skupiny] [3:prava ostatnich]
    \item napr.: -rwx---r-- (ciselne vyjadreni v 8 soustave 0704)
    \item je obycejny soubor, vlastnik ma vsechna prava, skupina zadna a ostatni maji prava na cteni \\
\end{itemize}

Zmena pristupovych prava se deje pomoci chmod. (Pro nespustitelne soubory je bezny chmod 0644). \\

\textbf{linux:}
\textit{chmod [1:pro koho][nova prava] [soubor/y]} zmena pristupovych prav \\

\subsection{Sticky bit}
Priznak, ktery pokud bude prirazen nejakemu adresari, tak se vytvori adresar, ve kterem i pres pravo cteni a zapisu souboru mohou uzivatele rusit pouze ty soubory, ktere sami vytvorili. (typicky adresar /tmp) (tldr: uzivatel muze mazat, ale pouze to co vlastni) \\

\subsection{SUID, SGID}
\textbf{S procesy jsou spojeny identifikatory jako jsou:}
\begin{itemize}
    \item UID - realna identifikace uzivatele (cislo uzivatele, ktery dany proces spustil)
    \item EUID - efektivni identifikator pouzivany pro kontrolu pristupovych prav (vetsinou stejne jako UID)
    \item GID - realna identifikace skupiny (kdo spustil proces)
    \item EGID - efektivni GID, (stejne chovani jako u EUID) \\
\end{itemize}

Vlastnik programu muze propujcit sva prava komukoliv, kdo spusti program s nastavenym SUID. (tldr: propujci se prava mezi uzivateli, bezne se to pouziva v pripadech, kdy administrator propujcuje sva prava uzivatelum, napr. passwd) \\

Pri pouziti SUID bude UID = uzivatele, ktery proces spustil a EUID = identifikace vlastnika (= ktery prava pujcil). Pokud budou prava propujcena (pouzito SUID), misto x se vypise s, pokud tam x neni, vypise se S. \\

\subsection{Typicka struktura adresaru v UNIXu}
\textbf{FHS - Filesystem Hierarchy Standard (Linux), (cast hierarchie):}
\begin{itemize}
    \item /bin - programy pro vsechny uzivatele (spustitelne, mohou byt zapotrebi pri bootovani - musi byt dostupne lokalne)
    \item /boot - soubory pro zavadec systemu (obrazy jadra, pocatecni fs)
    \item /dev - specialni soubory - rozhrani zarizeni
    \item /etc - konfiguracni soubory pro system i aplikace
    \item /home - domovske adresare uzivatelu
    \item /lib - sdielne knihovny a moduly jadra
    \item /media - pripojny bod pro prenosna zarizeni
    \item /mnt - pripojny bod pro docasne filesystemy
    \item /proc - informace o procesech a jadru
    \item /root - domovsky adresar superuzivatele
    \item /run - docasne informace o bezicim systemu (demony)
    \item /sbin - programy pro superuzivatele (nutne pro bootovani, ne vse je spustitelne superuzivatelem)
    \item /sys - informace o jadru, zarizenich, modulech, ..
    \item /tmp - docasne pracovni soubory (obsah se maze pri restartu)
    \item /usr - obsahuje dale adresare a
    \begin{itemize}
        \item soubory, ktere nejsou nutne pri zavadeni systemu, struktura je zde podobna jako u / :
        \item bin, sbin, lib,
        \item include (hlavickove soubory),
        \item share (soubory je mozne sdilet nezavisle na architekture),
        \item local (koren dalsi hierarchie urcena pro lokalni nestandardni instalace programu),
        \item src (zdrojove texty jadra)
    \end{itemize}
    \item /var - soubory menici se za behu systemu
    \begin{itemize}
        \item obsahuje log (zaznamy o cinnosti systemu), 
        \item spool (pomocne soubory pro tisk),
        \item mail (postovni prihradky uzivatelu) \\
    \end{itemize}
\end{itemize}

\newpage

\textbf{Nove tema: Datove struktury a algoritmy pro vstup/vystup}
\subsection{Pouziti vyrovnavacich pameti}
Cilem pouziti cache (vyrovnavacich pameti) je minimimalizace poctu pomalych operaci s periferiemi (disky). Hierarchie:
kolekce, sbirka dilcich vyrovnavacich pameti (s velikosti 1 alokacniho bloku, ci nasobku), nazyva se buffer-pool, muze mit pevnou velikost, spise je promenna. \\

\newpage

\subsection{Operace se soubory}

\subsubsection{Cteni}
\textbf{Prvni cteni alokacniho bloku:}
\begin{itemize}
    \item zjisti se, zda je blok v pameti,
    \item pokud ne, naalokuje se novy blok, muze se vyuzit jiz nejaky systemem predalokovany a nevyuzity,
    \item nactou se data z disku, presunou se do vyrovnavaci pameti,
    \item vyrovnavaci pamet je v prostoru jadra (bezne procesy zde nemaji pristup),
    \item vykousne se z nactenych dat tu cast, o kterou ma uzivatel/proces zajem,
    \item nakopiruje se to do adresoveho prostoru uzivatelskeho prostoru \\
\end{itemize}

\textbf{Pri dalsim cteni:}
\begin{itemize}
    \item nejprve se opet vyhleda, zda je blok v pameti,
    \item pokud ano,
    \item nebude se cist z disku, pouze se z alokacniho bloku vykousne cast, o kterou ma uzivatel/proces zajem,
    \item tato cast se uzivateli preda \\
\end{itemize}

\subsubsection{Zapis}

\textbf{Postup pri zapisu:}
\begin{itemize}
    \item nejprve se zjisti, zda je blok v pameti,
    \item pokud ne, prideli se vyrovnavaci pamet,
    \item nactou se data z disku do vyrovavaci pameti,
    \item jadro prevezme od procesu, ktery chce zapisovat data, ktera chce zapsat,
    \item prepise jimi danou cast alokacniho bloku, dirty bit se zmeni (0 na 1),
    \item operace konci (neprovede se zapis na disk),
    \item casem se provede zpozdeny zapis na disk a vynuluje se dirty bit \\
\end{itemize}

System sam od sebe s periodou prepisuje cache na disky, lze si to vynutit pomoci sync ci fsync. \\

Pokud je znamo, ze se prepise cely alokacni blok (nebo se jedna o novy blok), buffer se vynuluje a nenacitaji se data z disku do cache. \\


\textbf{definice:} \\[0.5em]
\textit{dirty bit} je indikator toho, jestli jsou data cache sladena s obsahem na disku (0 - data v cache = disk, 1 - data cache != data disk - nuluje se zpozdenym zapisem) \\

\subsubsection{Otevreni souboru pro cteni}
Pokud soubor jeste \textbf{nebyl otevren}:
\begin{itemize}
    \item system musi vyhodnotit cestu a naleznou cislo i-uzlu (resp. cislo datove struktury poskytujici informace o danem souboru - pristupova prava, kde jsou ulozena data),
    \begin{itemize}
        \item pri tom se postupne nacitaji i-uzly vsech adresaru vedouci na soubor,
        \item pote se nacte i-uzel souboru,
        \item system pouziva d-entry cache (specialni vyrovnavaci pamet pouzita pro preklad odpovidajicich jmen souboru na i-uzel) 
        \item dale alokuje polozku v tabulce V-uzlu,
    \end{itemize}
    \begin{itemize}
        \item z disku se nacte i-uzel,
        \item vlozi se do nove alokovane polozky = vznika rozsirena pametova kopie i-uzlu,
        \item budou tam i informace navic (jako je pocet odkazu na danou polozku - danym i-uzlem muze pracovat vice procesu).
    \end{itemize}
    \item v tabulce popisovacu vytvorime novou polozku,
    \begin{itemize}
        \item tato tabulka je ulozena v zaznamu o procesu (tabulka procesu v jadre) nebo v uzivatelske oblasti,
        \item pouzije se nejnizsi volna polozka zde,
        \item naplni se odkazem na polozku v tabulce otevrenych souboru,
    \end{itemize}
    \item pokud se otevreni vydari, vrati se cislo popisovace, pokud ne, tak vraci -1. \\
\end{itemize}

Tolik tabulek se pouziva pro zamezeni duplikaci udaju. Behem otevirani se provadi kontrola pristupovych prav. Soubor je mozne otevrit v rezimu pro cteni, zapis, cteni i zapis. \\

Dalsi otevreni souboru (\textbf{jiz jednou otevreny}):
\begin{itemize}
    \item opet se vyhodnoti cesta k souboru a ziska se cislo i-uzlu,
    \item system se podiva do tabulku V-uzlu,
    \item zjisti, ze i-uzel uz tam je,
    \item nebude se znovu i-uzel nacitat z disku, pouze se zvysi citac pouziti i-uzlu,
    \item tabulka V-uzlu musi byt vyhledavaci (typicky vyhledaci struktury jako hash tabulka, strom, ..),
    \item naalokuje se nova polozka v tabulce otevreni (naplni se rezimem otevreni, pozici, odkazem na sdileny V-uzel),
    \item naalokuje se nove poloza ve file descriptoru ukazujici na nove otevreni (a ta se vrati) \\
\end{itemize}

\newpage

\textbf{Je mozne pridavat i dalsi identifikatory, napr.:}
\begin{itemize}
    \item priznak, ze ma byt soubor vytvoren pokud neexistuje,
    \item pokud existuje, ma byt zkracen na 0,
    \item otevrit v rezimu pridavani (kdekoli je aktualne ukazovatko v souboru, tak v pripade zapisu se automaticky posune na konec a tam se prida),
    \item synchronni zapis (operace zapisu skonci az tehdy, kdyz se data zapisou opravdu na disk) \\
\end{itemize}

\textbf{Pri chybe:}
\begin{itemize}
    \item open vraci -1,
    \item nastavi se chybovy kod, ktery blize popisuje co se stalo (do knihovni promenne errno),
    \item existuji standardni chybove kody,
    \item lze pouzit standardni knihovni funkci perror \\
\end{itemize}

\textbf{linux:} \\[0.5em]
\textit{fd = open([jmeno souboru], [rezim]);} otevre soubor \\[0.2em]
\textit{V-uzly} je tabulka i-uzlu filesystemu VFS \\[0.2em]
\textit{tabulka popisovacu} je pole s radky cislovanymi od 0 (0 - stdin, 1 - stdout, 2 - stderr) \\[0.2em]
\textit{tabulka procesu} v jadre je cast adresoveho prostoru, ve kterem ma jadro ulozene pomocne informace k procesum a ma sem pristup pouze jadro \\[0.2em]

\subsubsection{Cteni a zapis z/do souboru}
\textbf{Cteni:}
\begin{itemize}
    \item zkontroluje se platnost popisovace (otevreni popisovace, soubor pro cteni),
    \item pokud se jedna o prvni pristup, naalokuje se cache, nactou se data do cache a z cache se prislusna data pouziji,
    \item pokud uz jsou data v cache, nactou se odtud,
    \item predani se deje pozadovanych z cache (RAM, jadro) do pole (RAM, cache adresoroveho prostoru procesu),
    \item funkce vraci pocet opravdu prectenych bajtu nebo -1 pri chybe (+ nastavi errno). \\
\end{itemize}

\textbf{Zapis:}
\begin{itemize}
    \item funguje podobne jako read,
    \item pred vlastnim zapisem kontroluje dostupnost diskoveho prostoru a tento prostor alokuje (rezervuje),
    \item vraci pocet opravdu zapsanych bajtu nebo -1 \\
\end{itemize}

\newpage

\textbf{linux:} \\[0.5em]
\textit{read([popisovac], [adresa pameti, kam se ma zapsat], [kolik bajtu se ma nacist])} precte soubor \\[0.2em]
\textit{write ([popisovac], [adresa pameti, ze ktere se nactou data], [kolik bajtu se zapise])} zapis do souboru \\

\subsubsection{Primy pristup k souboru}
Nahodne presouvani v souboru. \textbf{Postup:}
\begin{itemize}
    \item zkontroluje zda je popisovac platny (je soubor otevren?)
    \item nastavi pozici offset bajtu od whence
    \begin{itemize}
        \item SEEK\_SET - napr. 200 - posunu se od 200 bajtu od zacatku,
        \item SEEK\_CUR - od aktualni pozice,
        \item SEEK\_END - od konce souboru),
    \end{itemize}
    \item nelze se posunou pred zacatek souboru,
    \item je ale mozne se posunout za konec souboru (a zapsat),
    \item vraci se vysledna pozice od zacatku souboru nebo -1 \\
\end{itemize}

Posunem za konec souboru a naslednym zapisem vznikaji tzv. ridke soubory (sparse files):
\begin{itemize}
    \item umoznuje na disku o nejake kapacite vytvorit soubor, ktery ma zdanlive vetsi velikost nez samotny disk,
    \item bloky do kterych se nezapisovalo nejsou alokovany a nezabiraji diskovy prostor (pri cteni se povazuji za 0),
    \item take muze vzniknout mazanim uprostred souboru (hole punching) \\
\end{itemize}

\begin{figure} [h]
    \centering
    \scalebox{2}{\includegraphics{7.9.5.jpg}} \\
    \caption{z prezentace IOS: Sprava souboru - ridke soubory} 
\end{figure}

\textbf{linux:} \\[0.5em]
\textit{lseek([popisovac souboru], [offset], [oproti cemu se chci posouvat])} primy pristup k souboru \\

\newpage

\subsubsection{Zavreni souboru}
\begin{itemize}
    \item zkontroluje se platnost file descriptoru (je vubec otevreny?),
    \item uvolni se dana polozka v tabulce popisovacu,
    \item system se podiva na odkazovanou polozku v tabulce otevrenych souboru,
    \item snizi se pocitadlo o 1,
    \item pokud bude pocitalo != 0, uzavirani skonci,
    \item pokud bude pocitadlo == 0, pokracuje se do 
    \item prislusne polozky tabulky V-uzlu, snizi se zde pocitadlo o 1,
    \item pokud bude zde pocitadlo != 0, uzavreni skonci,
    \item pokud bude zde == 0, soubor se definitivne uzarve,
    \item uvolni se z pameti i-uzel z tabulky V-uzlu (se zmenenymi udaji - cas zapisu, pristupu, modifikace i-uzlu, ..),
    \item naplanuje se blok, ve kterem je i-uzel ulozen,
    \item casem se i-uzel zapise na disk,
    \item funkce vraci 0 nebo -1 pri chybe \\
\end{itemize}

Pokud se proces skonci, automaticky se zavrou vsechny jeho deskriptory. Uzavreni souboru nezpusobi ulozeni obsahu jeho vyrovnavaci pameti na disk. \\

\textbf{linux:} \\[0.5em]
\textit{close([popisovac souboru])} zavre soubor \\

\subsubsection{Duplikace deskriptoru souboru}
\begin{itemize}
    \item zkontroluje se platnost deskriptoru (je soubor otevren?),
    \item zkopiruje obsah puvodniho popisovace do noveho (odkaz ve fd tabulce se zkopiruje do dalsi polozky v teto tabulce - oboje ukazuji na stejnou polozku tabulky otevrenych souboru + inkrementuje se pocitadlo), 
    \item automaticky se novy deskriptor uzavre (pokud je otevren),
    \item vraci index nove vytvorene polozky nebo -1,
    \item typicke pouziti je u presmerovani (stdin/stdout) \\
\end{itemize}

\textbf{linux:} \\[0.5em]
\textit{dup([popisovac])} duplikace deskriptoru (duplikuje existujici popisovac do nejvyssiho volneho noveho) \\[0.2em]
\textit{dup2([popisovac], [novy popisovac])} duplikace deskriptoru (do ktereho popisovace se duplikuje) \\

\subsubsection{Ruseni souboru}
\begin{itemize}
    \item vyhodnoti se cesta, zkontroluje se platnost jmena souboru, pristupova prava (zapis),
    \item odstrani se pevny odkaz (=hard link) mezi jmenem souboru a i-uzlem,
    \item zmensi se pocet jmen v i-uzlu,
    \item pokud je pocet jmen == 0 a i-uzel nikdo nepouziva - i-uzel muze byt uvolnen a mohou byt uvolneny vsechny bloky souboru,
    \item dokud ma soubor alespon 1 jmeno nebo nema zadne jmeno ale je otevren alespon 1x, nelze soubor z disku opravdu smazat,
    \item funkce vraci 0 nebo -1 pri chybe \\
\end{itemize}

Je mozne provest unlink na otevreny soubor (smaze se az po jeho uzavreni) a pracovat s nim dale,
vyuziti pri instalacich novych verzich programu, ktere aktualne bezi. (upgradovat upgradovaci program) \\

\textbf{linux:} \\[0.5em]
\textit{unlink([jmeno soubor, prip. cesta])} rusi soubor \\[0.2em]
\textit{shred} - bezpecne mazani \\

\subsubsection{Dalsi operace se soubory}

\textbf{linux:} \\[0.5em]
\textit{creat, open} - vytvoreni souboru \\[0.2em]
\textit{rename} - prejmenovani souboru \\[0.2em]
\textit{truncate, ftruncate} - zkraceni souboru \\[0.2em]
\textit{fcntl, lock} - zamykani zaznamu \\[0.2em]
\textit{chmod, chown} - zmena atributu \\[0.2em]
\textit{utime} - umoznuje zmenit casy prace se soubory (neumoznuje zmenit cas modifikace i-uzlu) \\[0.2em]
\textit{stat} - ziskani atributu (velikost, prava, ..) \\[0.2em]
\textit{sync, fsync} - vynuceni si zapisu vyrovnavacich pameti \\

\subsubsection{Adresarove soubory}
Obsahuje dvojice cislo i-uzlu a jmena souboru. Adresare nelze zapisovat ci cist po bajtech.

\textbf{linux:} \\[0.5em]
\textit{mkdir} - tvori se adresare (vytvori polozky . a ..) \\[0.2em]
\textit{opendir} - otevre adresar \\[0.2em]
\textit{readdir} - cte adresar \\[0.2em]
\textit{closedir} - zavre adresar \\[0.2em]
\textit{creat, link, unlink} - modifikace se provadi neprimo vytvarenim/modifikacemi souboru \\

\subsubsection{Blokove a znakove specialni soubory}
Predstavuji rozhrani k blokovym / znakovym zarizenim (/dev/..., viz. \ref{blok-char-hw})
\begin{itemize}
    \item lze je vytvorit pomoci mknod,
    \item typicky tyto soubory vytvari jadro ci demoni (udev, devd - pri pripojeni zarizeni se vytvori automaticky prislusny soubor) \\
\end{itemize}

Pri pouziti beznych souborovych operaci jadro mapuje operace na odpovidajici podprogramy, ktere ty operace implementuji pro dany typ zarizeni s vyuzitim \textbf{tabulek}:
\begin{itemize}
    \item znakovych zarizeni,
    \item blokovych zarizeni \\
\end{itemize}

Tyto tabulky obsahuji ukazatele na funkce implementujici prislusne operace v ovladacich danych zarizeni. \\

Specialni soubory na disku zabiraji \textbf{pouze i-uzel, krome beznych udaji maji v i-uzlu typ souboru a 2 udaje}:
\begin{itemize}
    \item hlavni cislo,
    \begin{itemize}
        \item major number,
        \item udava typ zarizeni
        \item odkazuje do tabulky zarizeni (hlavni cislo = n-ty radek tabulky),
    \end{itemize}
    \item vedlejsi cislo 
    \begin{itemize}
        \item minor number, 
        \item udava instanci zarizeni
        \item pouziva se jako parametr pri volani urcite operace - parametr funkce ovladace (cislo = ktere zarizeni se ma presne pouzit)
    \end{itemize}
    \item typ souboru urcuje tabulku (blok, znak.) \\
\end{itemize}

\textbf{linux:} \\[0.5em]
\textit{mknod} vytvori specialni soubory \\[0.2em]
\textit{ovladac} je sada podprogramu pro rizeni urciteho typu zarizeni (nebo viz xx nebo viz xx) \\

\newpage

\subsection{Terminaly}
Jsou fyzicka ci logicka zarizeni umoznujici (primarne) textovy vstup a vystup systemu (po radcich), editace vstupniho radku ci specialni znaky (Ctrl+C SIGINT, Ctrl-D konec vstupu, ..) \\

\textbf{Rozhrani:}
\begin{itemize}
    \item /dev/tty - pro kazdy proces, ktery ma ridici terminal, odkazuje na jeho ridici terminal
    \item /dev/ttyS1 - fyzicke terminaly na seriove lince,
    \item /dev/tty1 - virtualni terminaly (konzole),
    \item pseudoterminaly (/dev/ptmx - master, /dev/pts/1,..) tvoreny dvojici master / slave, po kazdem otevrenim se vytvori novy slave - emuluje komunikaci pres seriovou linku (umoznuje pro propojeni urcitych casti, napr. SSH - propojeni klienta se vzdalenym klientem) \\
\end{itemize}

\textbf{Ruzne rezimy zpracovani znaku} (radkove discipliny - line discipline):
\begin{itemize}
    \item raw - neprovadi se zpracovani znaku,
    \item cooked - zpracovani vsech ridicich znaku,
    \item cbreak - provadi zpracovani maleho poctu znaku (ctrl+c, mazani, ..) \\
\end{itemize}

Nastaveni rezimu zpracovani znaku je mozne pomoci stty. Dale je mozne nastavit \textbf{rezim terminalu}:
\begin{itemize}
    \item prikazy tset, tput, reset,..
    \item promennou TERM, ve ktere ulozen aktualni typ terminalu,
    \item typy terminalu (prikazy terminfo, termcap) \\
\end{itemize}

Tyto prikazy komunikuji s terminalem pomoci \textit{escape sekvenci}. Knihovna curses je standardni knihovna pro rizeni terminalu ci tvorbu aplikaci s terminalovym uzivatelskym rozhranim. \\

\textbf{definice:} \\[0.5em]
\textit{escape sekvence} jsou sekvence znaku escape, prikaz [parametry], escape, prikaz, .. \\

\newpage

\subsection{Roury}
Jsou prostredkem meziprocesove komunikace. Rozlisujeme: \\

\textbf{Nepojmenovane roury}
\begin{itemize}
    \item nemaji adresarovou polozku, tedy neexistuji v souborovem systemu,
    \item lze s nimi pracovat pouze tak, ze se vytvori pomoci volani pipe (vrati cteci a zapisovy deskriptor), jakmile dojde k uzavreni - prace s rourou konci,
    \item mohou s ni pracovat bezne pouze pribuzne procesy,
    \item je dostupna pomoci popisovacu z tabulky popisovaci (pri klonu procesu se naklonuje tabulka popisovaci - proces bude ukazovat na stejne misto v tabulce otevrenych souboru),
    \item jedina vyjimka, jak je mozne odkaz na nepojmenovanou rouru predat je pres UNIXove sockety (krome klonovani procesu),
    \item vytvari se v kolonach (napr. paralelne bezici procesy p1 | p2 | p3 - na presmerovani se pouzivaji nepojmenovane roury) \\
\end{itemize}

\textbf{Pojmenovane roury}
\begin{itemize}
    \item vyvtari se pomoci mknod is mkfifo,
    \item existuji v souborovem systemu,
    \item mohou se zavrit, otevrit, apod. \\
\end{itemize}

Roury slouzi jako mechanismus meziprocesove komunikace. Implementovane jako kruhovy buffer s omezenou kapacitou. Procesy komunikujici pres rouru jsou synchronizovany. \\

\textbf{definice:} \\[0.5em]
\textit{pribuzne procesy} - pokud jeden proces otevre rouru a zacne se klonovat, vsechny tyto procesy mohou s rourou pracovat \\[0.2em]
\textit{konzumenti} - procesy, ktere ctou \\[0.2em]
\textit{producenti} - procesy, ktere zapisuji \\

\newpage

\section{}
\textbf{Osma prednaska:} Dokonceni souborovych systemu: Roury, sockety. Procesy:

\subsection{Sockety}
Umoznuji jak sitovou (klient-server, TCP, UDP) tak lokalni (filesystem) komunikaci. \\

Pro vytvoreni socketu se pouziva volani socket:
\begin{itemize}
    \item nasledne se ceka na pripojeni (bind - propojit socket s TCP/UDP portem ci souborem, listen - zacinam cekat, accept - prijem prichoziho spojeni),
    \item klient se pripoji pomoci (connect),
    \item prijem a vysilani zprav (recv / send ci read / write - volani vraci popisovace otevrenych souboru),
    \item uzarevni (close) \\
\end{itemize}

Sokety podporuji blokujici i neblokujici I/O. Pri praci s vice sockety je mozne je obsluhovat vice procesy - vlakny (prikaz select) - typy souboru, u kterych muze nastat potreba cekat na moznost provedeni urcite operace. Sokety taky maji vyhodu, ze je mozne vytvorit aplikace, ktere mohou bezet distribuovane v siti. \\

\textbf{definice:} \\[0.5em]
\textit{blokujici rezim} (I/O) - pokud chci nacitat data ze socketu, budu pozastaven, dokud se nejaka data neobjevi \\[0.2em]
\textit{select} umoznuje testovat, zda na popisovaci je dostupna nejaka operace (ci mnozine popisovacu) \\[0.2em]
\textit{pasivni cekani} - nespotrebovava se CPU cas, energie, .. \\

\subsection{VFS} \label{VFS-new}
Virtual File System. Definice viz. \ref{VFS-old}. Komunikace s ruznymi filesystemy se prenasi z uzivatele na autora fs, ktery pokud chce, aby dany fs byl vyuzitelny, musi ho provazat s VFS (propojeni VFS a uzivatele resi vyvojari). \\

Typicka datova struktura VFS jsou \textbf{V-Uzly} = rozsirene pametove kopie i-uzlu, ktere krome dat i-uzlu obsahuji dalsi data:
\begin{itemize}
    \item jako pocet odkazu na v-uzel z tabulky otevrenych souboru, 
    \item ukazatele na funkce implementujici operace nad i-uzlem (v patricnem filesystemu). \\
\end{itemize}

\newpage

\subsection{NFS} \label{NFS-more}
Network File System. Zpristupnuje soubory ulozene na vzdalenych systemech. \\

Jedna se o \textbf{system klient-server}:
\begin{itemize}
    \item klient pozada o cteni ze souboru (napr.),
    \item vsechny operace prochazi pres VFS,
    \item pozadavek se z VFS preda na NFS klienta,
    \item NFS klient preda pozadavek na NFS server,
    \item NFS server pracuje s lokalnim filesystemem jiz na vzdalenem PC,
    \item ten pracuje take s VFS (ale na serveru), prostrednictvim nej ziska data s lokalniho filesystemu,
    \item data pote putuji zpet pres sit k uzivateli zpet \\
\end{itemize}

Umoznuje \textbf{kaskadovani} - je mozne si lokalne do jednoho adresaroveho stromu pripojit vzdaleny strom (a do nej pripojit dalsi vzdaleny filesystem). \textbf{Autentizujeme se nejcasteji pres UID, GID} (musi existovat duvera mezi spravcem lokalniho a vzdaleneho systemu). Nebo se pouziva jine mechanismy (kryptografie, ..) \\

NFS verze 3:
\begin{itemize}
    \item starsi, bezestavova verze - nepouziva operace otevirani, uzavirani soubori, kazda operace si musi nest veskere informace o souboru,
    \item na strane klienta nema cache (slozita implementace), na strane serveru cache,
    \item nema podporu zamkyani (operace pro zamknuti zaznamu souboru jsou prazdne) \\
\end{itemize}

NFS verze 4:
\begin{itemize}
    \item stavova,
    \item cache na strane klienta,
    \item podpora zamykani \\
\end{itemize}

\subsection{Spooling}
Simulatenous perpiheral operation on-line (simulatenalni online provadeni perifernich operaci). Jedna se o \textbf{provadeni online bez cekani periferni operace (vystup) na periferiich, ktere nemusi online prokladani dat od ruznych procesu ci uzivatelu podporovat}. (napr. sitova tiskarna - spousta uivatelu, kazdy chce, aby tisk se provedl okamzite)

Vystup se provede do vyrovnavaci pameti spool (soubor), system si vede frontu cekajicich uloh, operaci, do fronty se zaradi odkaz na vytvoreny soubor, uloha se ma dokoncim po uvolneni periferie. \\

\textbf{linux:} \\[0.5em]
\textit{/var/spool} obsahuje soubory spool \\

\newpage
\textbf{Nove tema:} Sprava procesu.

Sprava procesu (process management) zahrnuje: \label{procesy-detailed}
\begin{itemize}
    \item prepinani kontextu (dispatcher, vzdy v rezimu jadra),
    \item planovac (nemusi byt v jadre),
    \item spravu pameti,
    \item podporu meziprocesove komunikace (signaly, roury, sockety, synchronizace - semafory, mutexy, ..) \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{prepinani kontextu} rozumime fyzicky odebirani procesoru jednomu procesu a pridelovani jimenu procesu (take viz \ref{prepinani-kontextu-jadro}) \\[0.2em]
\textit{planovac} rozhoduje, ktery proces ci procesy pobezi a pripadne jak dlouho

\subsection{Proces}
Definice viz \ref{procesy}. Proces je bezici program, tedy aktivni entita, abstrakce aktivity probihajici v systemu. Program je naopak pasivni entita (definice viz \ref{procesy}). \\

\textbf{Proces je v OS definovan:}
\begin{itemize}
    \item unikatnim identifikatorem (PID - process identifier),
    \item stavem planovani,
    \item ridicim programem,
    \item obsahem registru (beznych - EAX, BX, EIP, ..),
    \item zasobnikem (aktivacni zaznamy - informace o rozpracovanych funkcich),
    \item daty (staticka ne/inicializovana data, hromady, individualne alokovane pameti),
    \item tim, jake dalsi vazby a zdroje OS vyuziva (jake soubory ma aktualne otevreny, signaly, obsluzne funkce signalu, PPID, UID, GID, semafory, sdilena pamet, sdilene knihovny, ..) \\
\end{itemize}

\newpage

\subsection{Stavy planovani a jejich zmeny}
Nejzakladnejsi planovaci diagram (vetsiny/vsech ruznych OS) - \textbf{stavy procesu}. \\

\textbf{Stavy planovani procesu (obecne):}
\begin{itemize}
    \item new - proces je inicializovan (vytvari se struktury co jej popisuji, data, proces pripadne ceka ve vstupni fronte dlouhodobeho planovace, ..)
    \item ready - proces ceka na kratkodoby planovac na prideleni procesoru, dispatcher provede prepnuti, prepne se do running
    \item running - proces muze byt preruen (preemtivni planovani - opet stav ready), muze pozadat o sluzbu jadro (I/O operace, sync) - stav waiting,
    \item waiting - proces ceka na dokonceni operace (sluzba jadra), pote pujde do stavu ready,
    \item terminated - proces skonci (proces se v systemu nejakou dobu vyskytuje ve stavu ukonceny) \\
\end{itemize}

% obrazek 5/38, sprava procesu
\begin{figure} [ht]
    \centering
    \scalebox{2}{\includegraphics{8.6_1.jpg}}
    \caption{z prezentace IOS: Sprava procesu - stavovy diagram obecneho planovani procesu}
\end{figure}

\newpage

\textbf{Stavy planovani procesu v UNIXu:}
\begin{itemize}
    \item init - vytvoreny, neinicializovany,
    \item runnable - pripraven bezet,
    \item running - proces bezi (pridelen procesor), v pripade preempce (proces se vzda CPU) - jde do runnable,
    \item sleeping - proces pozada o I/O ci sync akci (ceka na dokonce operace), po realizaci bude runnable
    \item suspended - pomoci signalu SIGSTOP muze byt proces zmrazen a ceka ceka na rozmrazeni (signal SIGCONT),
    \item zombified - ukonceni procesu a prechod do stavu zombie (matoha), proces skoncil, odebrany vsechny zdroje, pouze o nem zustava zaznam v tabulce procesu (zde je jeho navratovy kod dokud si ho nekdo neprevezme) \\
\end{itemize}

% obrazek 6/38, sprava procesu
\begin{figure} [ht]
    \centering
    \scalebox{2}{\includegraphics{8.6_2.jpg}}
    \caption{z prezentace IOS: Sprava procesu - stavovy diagram planovani procesu v UNIXu}
\end{figure}

OS s procesem pracuje tak, ze je reprezentovan pomoci struktury PCB (process control block), nekdy take task control block ci task struct. \\

\textbf{PCB zahrnuje (primo / formou odkazu):}
\begin{itemize}
    \item identifikatory spojene s procesem,
    \item stav planovani,
    \item obsah registru (v okamziku kdy je pozastaven),
    \item planovaci informace (priorita, ukazatele na planovaci fronty, ..),
    \item informace spojene se spravou pameti (tabulky stranek pri pouziti strankovaci pameti),
    \item informace spojene s uctovanim (sumarizuje informace o behu procesu - spotreba CPU, ..),
    \item informace o vyuziti I/O zdroju (otevrene soubory, tabulka popisovacu, ..) \\
\end{itemize}

PCB muze byt bud jedna struktura nebo muze byt rozdeleno na nekolik casti. \\

\subsection{Casti procesu v pameti v UNIXu}
Prvni soucast pameti vyuzite procesem je \textbf{uzivatelsky adresovy prostor} (user address space) - je pristupny procesu (muze z teto casti pameti cist/psat), obsahuje:
\begin{itemize}
    \item kod (ktery je rizen, code area/text segment),
    \item data (ne/inicializovana, hromada, alokovana pamet),
    \item zasobnik,
    \item soukroma data sdilenych knihoven, sdilene knihovny ci sdilena pamet \\
\end{itemize}

Dalsi cast informaci o procesech byva v nekterych pripadech - ne vzdy umistena v \textbf{uzivatelske oblasti} (napr. linux tento koncept nepouziva - vse ma v tabulce procesu):
\begin{itemize}
    \item ulozena pro kazdy proces v casti uzivatelskeho adresoveho prostoru, ktera neni pristupna procesu ,
    \item je to pristupne jadru,
    \item u kazdeho procesu si v teto casti uklada informace o procesu je tam:
    \item cast PCB, ktera je pouzivana zejmena za behu procesu,
    \item PID, UID, EID, GID, EGID, PPID (identifikator rodice),
    \item obsah registru,
    \item deskriptory souboru (informace o tom, ktere otevreni souboru reprezentuje stdin, stdout),
    \item obsluzne funkce signalu (funkce, ktere se budou volat pro obsluhu signalu),
    \item uctovani,
    \item pracovni, korenovy adresar \\
\end{itemize}

\textbf{Dalsi zaznamy jsou v tabulce procesu:}
\begin{itemize}
    \item ulozeno trvale v jadru,
    \item informace o procesu, ktere jsou dulezite i kdyz proces nebezi:
    \item PID, PPID, UID, EID, ...,
    \item stav planovani,
    \item udalost, na kterou proces ceka,
    \item planovaci informace (pro planovac pri rozhodovani ktery proces dal pobezi ci ne - priorita, spotreba casu, ..),
    \item cekajici signaly (signaly, kt. mohou prijit, i kdyz proces nebezi),
    \item odkaz na tabulky dat reprezentujici rozlozeni procesu, dat, kodu, zasobniku, .. \\
\end{itemize}

\newpage

Pote jsou jeste zaznamy v \textbf{tabulce pametovych regionu:}
\begin{itemize}
    \item jak je rozdelen uzivatelsky adresovy prostor na regiony (= souvisly kus pameti pouzity za urcity region, kod, zasobnik, ..),
    \item velikost techto regionu,
    \item globalni tabulka regionu (odkaz z teto na lokalni tabulky regionu),
    \item regiony byvaji cleneny na stranky (tabulky stranek) \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{logicky adresovy prostor} - rozsah vsech logickych adres, ktere se mapuji do fyzicke pameti \\[0.2em]
\textit{zasobnik jadra} je separatni zasobnik nekdy pouzivan pro ukladani rozpracovanych funkci jadro v okamziku kdy jadro provadi sluzbu pro dany proces \\

\subsection{Kontext procesu}
Je jine oznaceni pro \textbf{stav procesu}. Rozlisujeme:
\begin{itemize}
    \item uzivatelsky kontext - cast stavu procesu popisujici cast pameti dostupnou procesu samotnemu (kod, zasobnik, data),
    \item registrovy kontext,
    \item systemovy kontext - cast stavu procesu nedostupna samotnemu procesu (uzivatelska oblast, polozky tabulky procesu, pametove regiony,..) \\
\end{itemize}

\newpage

\subsection{Systemova volani nad procesy UNIXu}
= standardni POSIXova volani:
\begin{itemize}
    \item fork, exec, exit, wait, waitpid,
    \item kill, signal - synchronizace,
    \item getpid, getppid - ziskavani identifikatoru, ... \\
\end{itemize}

\textbf{Identifikatory spojene s procesy v UNIXu:}
\begin{itemize}
    \item identifikace procesu PID (vlastni identifikator procesu),
    \item identifikace predka PPID (proces, ktery dany proces vytvoril, rodic),
    \item realny-skutecny uzivatel, skupina uzivatelu, ktery proces spusitl - GID, GID,
    \item efektivni uzivatel ci skupina - EUID, EGID (viz. SUID, SGID v x.x),
    \item ulozene EUID a EGID - procesu umoznuji docasne se zbavit vysokych prav, ktere ziskal (proces se dobrovolne vzda vyssich prav - ulozi se a pobezi s beznymi pravi - v okamziku provadeni kritickych operaci si prava zase navysi -- ochrana pred chybami v programech),
    \item v linuxu FSUID, FSGID (file system UID/GID - oddelena zvysena privilegia pro praci s filesystemu),
    \item PGID, SID (process group identifier, session identifier - skupina procesu ci sezeni, do kterych proces patri) \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{sezeni} je skupina skupin procesu vytvarejici se typicky pri praci s terminaly \\

\subsection{Vytvareni procesu}
Procesy v UNIXu vznikaji \textbf{volanim sluzby fork}. Fork je volani, ktere se \textbf{zavola jednou}, pokud nedojde k chybe, tak \textbf{skonci 2x}. Na zaklade volani fork vznika \textbf{vztah rodic-potomek (parent-child) a hierarchie procesu}. Vysledkem forku je totiz \textbf{duplikace procesu}. Vznika takrka identicka kopie potomka, ktery dedi:
\begin{itemize}
    \item ridici kod, data, zasobnik, sdilenou pamet, otevrene soubory, obsluhu signalu, vetsinu synchronizacnich prostredku, ..
    \item pro efektivitu pouziva pro praci s pameti copy-on-write
    \item kopie se lisi v navratovem kodu fork, identifikatorech, udajich spojenych s planovanim a uctovanim, nededi se cekajici signaly, souborove zamky a nektere dalsi zdroje ci nastaveni .. \\
\end{itemize}

\textbf{Navratove kody forku:}
\begin{itemize}
    \item 0 - fork se zdaril, if(pid==0) { kod pro potomka }
    \item -1 - fork se nezdaril, if(pid==-1) { kod rodice }
    \item cokoli jineho (PID potomka) - else { kod pro rodice } \\
\end{itemize}

\newpage

\subsection{Hierarchie procesu v UNIXu}
Prvnim procesem, ktery vznika a vyvtvari ho jadro je \textbf{proces init s PID=1} (aktualni novejsi implementace je pojmenovana jako systemd - prikaz pstree). Tento proces je \textbf{predkem vsech ostatnich uzivatelskych procesu}. \textbf{PPID initu je 0}.

Existji take procesy jadra (kernel threads/processes), jejich init predkem neni:
\begin{itemize}
    \item jejich kod je soucasti jadra,
    \item vyskytuje se i proces s PID=0, vznika uplne jako prvni, podili se na inicializaci jadra, nasledne se meni na swapper (pokud je na systemu pouzit) nebo na cekaci smycku ci je to pouzivano jako procesova obalka pro vlakna jadra (na linuxu se tento proces nevypisuje) \\
\end{itemize}

Init se podili na \textbf{inicializaci systemu}, pote \textbf{prebira navratove kody procesu, ktere skonci, ale ktere osirely driv nez skoncily} (tedy rodic skonci driv nez potomek) - teoreticky by byl zombie procesem do nekonecna, proto init prebira jeho navratovy kod a umozni mu odchod ze systemu.

\textbf{definice:} \\[0.5em]
\textit{swapper} je proces, ktery slouzi k tomu, ze v pripade akutniho nedostatku pameti nektere procesy pozastavi a zcela ulozi na disk (veskere casti pameti zabirane procesem) \\[0.2em]
\textit{kthread} je proces, na linuxu init pro procesy jadra, ma PID=2 \\

\textbf{linux:} \\[0.5em]
\textit{pstree} vypis stromu procesu \\

\subsection{Zmena programu -- exec}
Umoznuje v ramci existujiciho procesu vymenit "jeho vnitrnosti" - \textbf{zahodit existujici kod a nahradit ho kodem jinym}. Exec je funkce, ktera se \textbf{zavola jednou a neskonci vubec} (je v nejakem kodu, ten kod prestane bezet) pokud nedojde k chybe.

Pokud v procesu zavolam exec:
\begin{itemize}
    \item porad dedi radu rysu sveho predka,
    \item zustava mu rada zdroju a vazeb OS (identifikatory, otevrene soubory, ..),
    \item zanikaji vazby a zdroje vazane na puvodni ridici (obsluzne funkce signalu, sdilena pamet, pametove mapovane soubory, semafory).
\end{itemize}

Skupina funkci exec:
\begin{itemize}
    \item execve (zakladni volani), execl, execlp, execle, execv, ..
\end{itemize}

Pozn.: Ve Windows se procesy vytvari volanim CreateProcess( ... ), ktere zahrnuje funkcnost fort i exec. \\

\newpage

\subsection{Cekani na potomka - wait, waitpid}
Slouzi k tomu, aby mohl \textbf{rodic cekat (pasivne) na dokonceni cinnosti svymi potomky}.

Volani wait:
\begin{itemize}
    \item ceka na ukonceni 1 z potomku,
    \item vraci cislo potomku, ktery skoncil (pripadne -1 pokud prijde signal, ktery cekani prerusi nebo pokud cekame na potomka a zadneho nemame),
    \item muze to byt operace blokujici, pokud zadny z potomku jeste neskoncil, 
    \item pokud nektery potomek skoncil driv pred volanim wait, okamzite volani wait skonci a vrati se navratovy kod. \\
\end{itemize}

Volani waitpid:
\begin{itemize}
    \item umoznuje cekani na ukonceni urciteho potomka urcite skupiny dle PID
    \item umoznuje cekani i na pozastaveni ci probuzeni (SIGSTOP, SIGCON). \\
\end{itemize}

\subsection{Start systemu}
\begin{itemize}
    \item (nejprve) dostane se ke slovu firmware PC (UEFI/BIOS),
    \item nacteni a spusteni zavadece OS (nekdy se zavadecu pouziva nekolik, napr. BIOS vyuzival zakladni kod MBR - serie zavadecu),
    \item nactou se inicializacni funkce jadra a samotneho jadro, spusteni inicializacnich funkci,
    \item inicializacni funkce jadra vytvori proces 0, dalsi procesy jadra a proces init,
    \item proces init pokracuje v inicializaci systemy, spostu demony a procesy,
    \item v urcitem okamziku se z nej spusti procesy umoznujici prihlaseni v GUI (GDM, SDDM, LightDDM) bud z nich nebo s nim spolupracujici procesu se spousti procesy pro praci s X Windows,
    \item na konzolich se spusti getty (ctrl+alt+f1,f2,..) - umozni uzivateli zadat prihlasovaci jmeno, zmeni se na login, nacte od uzivatele heslo, pote se zmeni na shell, ze ktereho se spousti dalsi procesy, po ukonceni se opet spousti getty,
    \item proces init i po inicializaci nadale bezi, prebira navratove kody procesu, jejich rodic skoncil driv nez prislusny proces, take resi reinicializaci systemu (na prani uzivatele ci vypadek napajeni) \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{firmware} je program ulozeny v nevolatilnich pametech, provadejici kontrolu hadrware, pripadnou inicializaci hw  \\

\newpage

\subsection{Urovne behu}
System urovni behu byl zaveden jiz v UNIX System V. Rozlisuji se urovne behu 0-6: (nektere mely predpripraveny standardni vyznam, nektere si definoval administrator)
\begin{itemize}
    \item 0=halt - zastaveni systemu,
    \item 1=single user - jednouzivatelsky rezim, pouziva spravce systemu,
    \item 3-6=definovane rezimy adminem,
    \item 6=reboot - automaticke restartovani,
    \item s/S=jednouzivatelsky rezim - daji se zde ale definovat ruzne akce, ktere se maji provadet pri prepnuti do techto rezimu,
    \item je mozne zmenit urovne behu (rezimy) pomoci \textit{tellinit N}. \\
\end{itemize}

Konfigurace urovni behu:
\begin{itemize}
    \item v adresari /etc/rcX.d (X=uroven behu), jsou skripty spoustene pri vstupu do dane urovne,
    \item nejprve se volaji skripty zacinajici K v poradi danem cislem za tim K (volaji se s argumentem stop),
    \item pote se volaji skripty zacinajici S (volaji se s argumentem start),
    \item start, stop - definuje se co se ma spustit ci jak se co ma zastavit,
    \item v adresari /etc/init.d vytvorime skript, ktery pozadovanou sluzbu bude umet spoustet, na patricne misto K a S odkazu se vytvori symlink na pozadovany skript,
    \item skripty v inid.d typicky prijimaji parametry start, stop, reload, restart
    \item tyto skripty se nemusi volat pouze pri zmene urovne behu, ale je mozne je volat i rucne - z /etc/inid.d
    \item v souboru /etc/inittab je horni, hlavni uroven systemu, kde se popisuje napr. implicitni uroven behu ci jake urovne behu jsou podporovane \\
\end{itemize}

Existuji ruzne nove implementace procesu init - dnes nejbeznejsi je \textbf{systemd}:
\begin{itemize}
    \item zakladni urovne behu jsou nahrazeny jednotky (units), ktere maji ruzne typy (targets, services, ..),
    \item spousti inicializacni jednotky paralelne na zaklade jejich zavislosti (= vyhodou je, ze inicializace systemu je mozne provadet paralelne, zatimco init se dela sekvencne),
    \item emuluji se urovne behu (zpetna kompatibilita),
    \item uzitecne jsou adresare /lib/systemd ci /usr/lib/systemd, .. (podrobne informace o systemd) \\ 
\end{itemize}

\newpage

\subsection{Planovani procesu} \label{planovani}
Procesy planuje planovac.

Rozlisujeme 2 \textbf{planovaci algoritmy} (definice viz. \ref{ne-preemtive}):
\begin{itemize}
    \item nepreemtivni planovani (typicky I/O operace, konec - volani exit, vzda se CPU - yield),
    \item preemtivni planovani (typicky preruseni od casovace, muze jit i o jine, treba od disku) \\
\end{itemize}

Rozlisujeme \textbf{3 "typy" planovani}:
\begin{itemize}
    \item dlouhodobe planovani - ktere ulohy budou pripusteny do systemu,
    \item strednedobe planovani - procesy maji pamet / nemaji pamet - jedna se o system swapovani,
    \item kratkodobe planovani - procesy maji pamet - prepinani mezi ulohami \\
\end{itemize}

\textbf{System swapovani} (= strednedobe planovani):
\begin{itemize}
    \item v pripade nedostatku pameti nektere procesy pozastavi, odebere jim veskerou pamet a ulozi je na disk,
    \item tyto procesy jsou vyrazeny z planovani (nemaji pamet - nemohou bezet),
    \item pri zadosti o spusteni ulohy uloha pak nebude spustena ihned, ale system ceka na uvolneni systemovych zdroju (sluzba ceka ve fronte) - pote uz se jedna dlouhodobe planovani (rozhoduje se o tom, ktere ulohy budou vubec pripusteny do systemu) \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{planovac} rozhoduje ktery proces ci procesy pobezi a pripadne jak dlouho \\[0.2em]
\textit{systemy s neepremtivnim planovanim} = systemy s kooperovanym planovanim (procesy musi spolupracovat, kooperovat) \\

\subsection{Prepnuti kontextu (procesu)}
Prepnuti kontextu na prikladu - dispecer na zaklade rozhodnuti planovace prepina mezi procesem A a B:
\begin{itemize}
    \item bude muset uchovat stav registru (nekterych, ale vcetne ridicich registru) procesu A do PCB (nebo task struct v linuxu),
    \item dojde k uprave nekterych ridicich struktur v jadre (uprava planovacich struktur, uctovacich struktur, ..),
    \item obnova ulozenych hodnot registru procesu B,
    \item dojde k predani rizeni proceu na adresu, kde bylo drive preruseno provadeni procesu B,
    \item tato akce se musi provadet v rezimu jadra \\
\end{itemize}

Neuklada se a neobnovuje cely stav procesu (pri pozastaveni procesu neni nutne na disk ukladat obsah pameti, ukladaji se pouze registry).

Presto prepnuti muze trvat \textbf{radove stovky/tisice instrukci} - jadra umoznuji interval v jakem prichazeji preruseni z casovace - je treba si dat pozor, aby ten interval nebyl prilis kratky, protoze zacne pote prevazovat rezie systemu nad uzitecnym behem (neustale ukladani a obnovovani obsahu registru).

\newpage

\section{}
\textbf{Devata prednaska:} Dokonceni spravy procesu.

\subsection{Kratke planovaci algoritmy}
\subsubsection{FCFS}
\begin{itemize}
    \item first come, first served,
    \item planovaci algoritmus zalozeny na jednoduche FIFO fronte,
    \item proces, ktery nove vznikne nebo je uvolnen z cekani na nejake operaci (I/O, sync, ..), pripadne proces, ktery se vzda CPU,
    \item se zaradi na konec fronty,
    \item procesy, ktere pobezi se vybiraji ze zacatku fronty,
    \item jedna se o nepreemtivni algoritmus (prepnuti kontextu dojde pokud se bezici proces vzda CPU ci zavola sluzbu jadra) \\
\end{itemize}

\subsubsection{Round-robin}
\begin{itemize}
    \item preemtivni obdoba FCFS,
    \item pracuje podobne jako FCFS,
    \item kazdy proces ma prideleno nejake casove kvantum,
    \item jakmile je mu pridelen CPU, proces bezi a pobezi nanejvys po dobu casoveho kvanta,
    \item po vyprseni casu je procesu odebran CPU a je zarazen na konec fronty,
    \item CPU se prideli procesu ze zacatku fronty \\
\end{itemize}

\subsubsection{SJF}
\begin{itemize}
    \item shortest job first,
    \item nejprve se provede nejkratsi uloha,
    \item algoritmus prideluje CPU tomu procesu, ktery aktualne deklaruje nejkratsi dobu pro svuj dalsi beh na CPU, po ktery nebude zadat o zadne I/O operace (tzv. CPU burst),
    \item beh uloh se deli na vypocetni prace (CPU burst) a pote na periody, kdy se komunikuje s periferiemi (disky, site,..),
    \item nepreemtivni algoritmus (neprerusuje proces pred dokoncenim jeho aktualni vypocetni faze),
    \item statisticky minimalizuje prumernou dobu cekani a zvysuje propustnost systemu,
    \item je nutne dopredu znat dobu behu procesu na CPU v jejich jednotlivych vypocetnich fazich, ci musi tu byt moznost tyto doby rozumne odhadnout (na zaklade predchoziho chovani techto uloh),
    \item dava smysl pro opakovane provadene ulohy, 
    \item pouziva se zejmena v davkovych (specializovancyh) systemech,
    \item nevyhodou algoritmus je starnuti (hladoveni, starvation) - ke starnuti dochazi pri cekani na nejake zdroje (CPU, zamek, ..) je situace, kdy nektery proces, ktery o ten zdroj zada, na nej ceka bez zaruky, ze nej nekdy ziska,
    \item pokud nejaky proces deklaruje delku CPU burst a v systemu budou neustale kratsi procesy s touto delkou, tyto procesy ho budou neustale predbihat (nikdy se tak k CPU nedostane) \\
\end{itemize}

\subsubsection{SRT}
\begin{itemize}
    \item shortest remaining time,
    \item preemtivni obdoba SJF,
    \item je zde prevence pri vzniku ci uvolneni procesu z cekani (kdyz se uvolni novy proces a deklaruje kratsi vypocetni fazi nez ten, ktery dosud bezel - muze byt provaden on), \\
\end{itemize}

\subsubsection{Viceurovnove planovani}
\begin{itemize}
    \item procesy rozdeleny do ruznych skupin (typicky dle priority, ale ne nutne - napr. dle typu procesu),
    \item kazda skupina procesu muze pouzivat jiny dilci planovaci algoritmus (FSFS, round-robin, SJF, ..) s ruznymi parametry,
    \item krome toho mame dalsi ("hlavni") algoritmus, ktery rozhoduje, ktera skupina procesu dostane CPU cas - casto jednoduse na zaklade priorit skupin,
    \item pote je dalsi planovaci algoritmus, ktery planuje mezi skupinami \\
\end{itemize}

\subsubsection{Viucerovnove planovani se zpetnou vazbou}
\begin{itemize}
    \item skupiny procesy jsou rozdeleny dle priorit,
    \item proces, ktery se stane nove pripravenym bezet (nove vznikne, je uvolnen z cekani, ..) je zarazen do skupiny procesu s nejvyssi prioritou.
    \item v teto skupine bezi a postupne klesa do nizsich priorit,
    \item az spadne do nejnizsi urovne (planovan round-robin),
    \item pouzivaji se varianty, kdy proces ma prednastavenou statickou prioritou a zaradi se do planovaci urovne teto priority, a pote ma i dynamickou prioritu, ktera se muze zvysovat i snizovat, typicky se priority meni tak, ze pokud nejaky proces spotrebovava mnoho CPU casu - priorita se snizi, proces ceka na mnoho I/O operaci - priorita se zvysi,
    \item cilem je zajistit rychlou reakci interaktivnich procesu, \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{interaktivni procesy} jsou procesy komunikujici s uzivatelem \\ 

\subsection{Planovac v Linuxu (od verze 2.6.23)}
Pouziva se \textbf{viceurovnove prioritni planovani se 100 zakladnimi statickymi prioritnimi urovnemi}:
\begin{itemize}
    \item priority 1-99 jsou vyhrazeny pro procesy realneho casu (algoritmy FCFS s preemci na zaklade priorit nebo round-robin),
    \item priorita 0 jsou bezne procesy planovane CFS planovacem,
    \item v ramci urovne 0 se pouzivaji podurovne v rozmezi -20 az 19, nejvyssi poduroven je -20 (je mozne bezne uzivatelsky nastavovat prikazy nice/renice),
    \item v ramci urovne 0 se rozlisuji 3 typu procesu (bezne, davkove a idle procesy),
    \item zakladni prioritni uroven (RT proces v 1-99, bezny proces) a typ planovani (round-robin, FCFS, ..) je mozne nastavit pomoci sluzby sched\_setscheduler,
    \item pozdeji pridano planovani pro sporadicke periodicke ulohy - zalozeno na strategii earliest deadline first (prezvato z RT OS) \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{FCFS s preemci na zaklade priorit} - pokud behem behu procesu dobehne I/O operace ci sync operace, ktera zpusobi proveditelnost procesu s vyssi prioritou, dojde k prepnuti kontextu  (nedochazi k prepnuti kontextu na zaklade casovych kvant s procesy s stejnou prioritou) \\[0.2em]
\textit{davkove procesy} maji mirnou penalizaci s hlediska priorit, maji ale delsi kvantum \\[0.2em]
\textit{idle} maji nizkou prioritu, procesy, u ktery se predpoklada, ze se dostanou ke slovu az v okamzik, kdyz v systemu nic uzitecnejsiho neni \\[0.2em]
\textit{sporadicke periodicke ulohy} jsou ulohy, ktere bezi, maji periodicke vypocetni faze (ocekavana faze - zname dobu jak dlouho trvaji + mame casovy limit, dokdy se maji vypocty provest), ktere se provadeji cas od casu \\[0.2em]

\subsection{Completely Fair Scheduler}
Neboli CFS planovac:
\begin{itemize}
    \item snazi se explicitne kazdemu procesu poskytnout odpovidajici procento strojoveho casu s ohledem na jeho priority (4 procesy, stejna priorita - vsichni 25 procent CPU),
    \item u kazdeho procesu si vede udaje o tom, kolik virtualniho CPU casu uz ten proces na CPU stravil,
    \item vede si udaj o minimalnim stravenem CPU case (dava nove pripravenym procesum),
    \item procesy udrzuje ve vyhledavaci strukture red-black tree podle vyuziteho CPU casu,
    \item pri rozhodovani, ktery proces pobezi, z strukturu vezme ten, ktery aktualne stravil nejmene casu na CPU,
    \item proces necha bezet po casove kvantum, ktere spocita na zaklade priorit,
    \item virtualni procesorovy cas - situace: 2 procesy bezici cely den (kazdy pul dne), prijde novy proces, fyzicky na CPU bezel 0s (nejvyssi priorita, bezel by pul dne a ty 2 by byly off), proto virtualni CPU cas - novy proces dostane cas mensi nez minimalni straveny cas vsemi procesy (ne 0),
    \item algoritmus ma podporu pro skupinova planovani, umi rozdelovat cas spravedlive pro skupiny procesu (spoustene z ruznych terminalu, od ruznych uzivatelu, ..) \\
\end{itemize}

\subsection{Planovani ve Windows NT a novejsich}
\begin{itemize}
    \item Pouziva se viceurovnove prioritni planovani se zpetnou vazbou na zaklade interaktivity:
    \item 32 prioritnich urovni, 0 - nulovani volnych stranek pameti (aby pres ne se nedostaly informace od jednoho uzivatel k jinemu), 1 - 15 bezne procesy, 16 - 31 procesy realneho casu,
    \item zakladni priorita procesu je dana kombinaci planovaci tridy a planovaci urovne (v ramci tridy),
    \item priorita se dynamicky snizuje ci snizuje:
    \item zvysi se priorita procesu spojene s oknem, ktere je v popredi,
    \item zvysi se priorita procesu spojene s oknem, do ktere prichazi vstupni zpravy (mys, casovac, klavesnice, ..),
    \item zvysuje se priorita procesu uvolnenych z cekani (I/O operace),
    \item zvysena priorita se po kazdem vycerpani kvanta snizu o jedno uroven (az do dosazeni zakladni priority) \\
\end{itemize}

\subsection{Inverze priorit}
Jedna se o \textbf{nezadouci problem}, ktery je nutne resit:
\begin{itemize}
    \item jedna se o situaci, kdy v OS mame ruzne prioritni procesy, malo prioritni proces si naalokuje si nejaky zdroj, zamkne si pristup k nejakemu sdilenemu sdroji (soubor, adresa v pameti, sitovy port, ..),
    \item viceprioritni procesy tyto procesy predbihaji, 
    \item nizkoprioritni proces se cas od casu dostane ke slovu, provede par instrukci, musi cekat,
    \item (ma naalokovany zdroj, chce s nim neco provest, to ale trva dlouho, protoze ho porad nekdo predbiha),
    \item muze nastat, ze nektery z viceprioritnich procesu potrebuje prave ten zdroj, ktery si zamknul tento nizkoprioritni proces,
    \item vysoceprioritni proces bude muset tak cekat - virtualne se zvysi (rapidne) priorita nizkoprioritniho procesu (= je to vedlejsi efekt, prioritu ma porad stejnou!),
    \item v systemu je mozne mit stredneprioritni procesy, ktere tento zdroj nepotrebuji, ty budou predbihat dale nizkoprioritni proces,
    \item vysokoprioritni proces musi cekat, zatimco stredneprioritni a nizkoprioritni maji najednou "vyssi prioritu",
    \item tento jev muze a nemusi vadit - muze zpusobit snizenou odezvu systemu, nicmene muzou se zablokovat i nektere kriticke procesy realneho casu (ovladani hardware, ..) \\
\end{itemize}

\textbf{Moznosti reseni inverze priorit:}
\begin{itemize}
    \item prioritni strop - priority ceiling - procesy v kriticke sekci ziskavaji nejvyssi prioritu,
    \item priority inheritance - procesy v kriticke sekci, ktery blokuje vyse prioritni procesy po dobu behu v kriticke sekci dedi prioritu cekajiciho procesu (s nejvyssi prioritou),
    \item na jednoprocesorovych systemech se pouziva technika, kdy po dobu behu v kriticke sekci se zakaze preruseni \\
\end{itemize}

Dalsi komplikace behem planovani:
\begin{itemize}
    \item viceprocesorove systemy - nutne vyvazovat vykon (aby na jednom jadru CPU nebezely 4 procesy a na zbytku 0), respektovat obsah cache CPU, lokalitu pameti (neuniformni pristup do pameti)
    \item hard real-time systemy - nutnost zajistit garantovanou odezvu nekterych akci \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{kriticka sekce} je sekce v kodu, kde se pracuje vylucnym zpusobem se sdilenymi prostredky \\[0.2em]
\textit{neuniformni pristup do pameti} - pamet je delena na pametove jednotky, kazda pripojena k jinemu CPU, ale vsechny procesy mohou pristupovat do vsech pametovych jednotek (za ruznou dobu) \\

\subsection{Vlakna, ulohy, skupiny procesu}
Vlakna, neboli threads:
\begin{itemize}
    \item oznacovana jako odlehcene procesy (LWP - lightweight process),
    \item vypocty (odpovidaji vlaknum) bezici paralelne v jednom procesum,
    \item vlakna maji vlastni obsah registru, vlastni zasobnik,
    \item vsechna vlakna sdili stejny ridici kod, data, dalsi zdroje (otevrene soubory, signaly),
    \item vyhody: rychleji se spousti, prepina, efektivnejsi prace (dle systemu - v UNIXu diky fork rozdil mezi vlakny a procesy je mensi nez jinych OS), .. \\
\end{itemize}

\newpage

\subsection{Ulohy, skupiny procesu, sezeni}
\textbf{Uloha (job)} se poji se shellem, je skupina skupina paralelne bezicich procesu spustenych jednim prikazem, prikazy propojene do kolony (p1 | p2 | p3 - pipeline). \\

\textbf{Skupina procesu (process group) v UNIXu:}
\begin{itemize}
    \item mnozina procesu paralelne bezicich, se kterymi je mozne provadet operace jako s celkem,
    \item skupine je mozne poslat signal jako 1 jednotce,
    \item predek take muze cekat na libovolneho potomka z urcite skupiny,
    \item kazdy proces prave v 1 skupine procesu, po vytvoreni vzdy je to skupina jeho predka,
    \item skupina muze a nemusi mit vedouciho - jeji prvni proces, dokud neskonci (pokud skonci - skupina bez vedouciho),
    \item skupina je identifikovana vedoucim skupiny, pokud vedouci skupiny skonci, neni mozne jeho cislo recyklovat a pouzit pro ID skupiny \\
\end{itemize}

\textbf{Sezeni v UNIXu:}
\begin{itemize}
    \item mnozina skupin procesu,
    \item kazda skupina procesu je v jednom sezeni,
    \item sezeni muze a nemusi mit vedouciho,
    \item muze mit ridici terminal (/dev/tty),
    \item v ramci sezeni plati, ze jedna skupina je na popredi (cte z terminalu), ostatni jsou na pozadi,
    \item pokud terminal konci, signalem je SIGHUP, informovan je vedouci sezeni (typicky shell), standardtne se vsem procesum, na ktere nebyl uzit prikaz nohup/disown, posle navic SIGHUP, pokud jsou procesy pozastaveny, tak posle signal SIGCONT \\
\end{itemize}

\newpage

\subsection{Komunikace procesu}
Pouziva se \textbf{IPC - inter-process communication:}
\begin{itemize}
    \item signaly (umoznuji zasilat mezi CPU informace pomoci cisla),
    \item roury,
    \item zasilani zprav (umoznuji posilat retezcova data),
    \item sdilena pamet,
    \item sockety,
    \item RPC (remote procedure call), ... \\
\end{itemize}

\subsection{Signaly}
V zakladni verzi je cislo (int), ktere je procesu zaslano prostrednictvim pro to zvlast definovaneho rozhrani (= signaly v OS, nikoli na vodicich). Jsou generovany:
\begin{itemize}
    \item pri chybach (aritemticka chyba, chyby sbernic, ..),
    \item externich udalostech (dostupnost I/O, vyprseni casovace, ..),
    \item na zadost procesu - IPC (meziprocesova komunikace, procesy si mohou navzajem posilat singnaly, ale jadru signal nelze zaslat - jadro neni proces),
    \item vznikaji obvykle asynchronne k cinnosti programu (program neco provadi, nezavisle na tom co provadi v okamziku ktery nelze predpovedet prijde signal) \\
\end{itemize}

Je nutne peclive zvazovat obsluhu signalu, aby aplikaci \textbf{signal neshodil, vznikaji chyby, ktere se objevuji jen zridka} (spatne ladeni, tzv. race conditions) - vede to na vyuzivani technik pro \textbf{pokrocile testovani} (vkladani sumu - umele v nahodnych okamzicich se snazime programy zpozdit, enumerace prolozeni akci programu), \textbf{nastroje pro verifikaci s formalnimi zaklady} (staticka analyza, model checking). \\

Mezi bezne pouzivane signaly patri:
\begin{itemize}
    \item SIGHUP - odpojeni, ukonceni terminalu,
    \item SIGINT - preruseni z klavesnice (Ctrl+C),
    \item SIGKILL - signal c.9, tvrde ukonceni
    \item SIGSEV (mimo pridelenou pamet - spatny ukazatel),SIGBUS - chybna prace s pameti,
    \item SIGPIPE - zapis do roury bez ctenare,
    \item SIALRM - signal od casovace,
    \item SIGTERM - mekke ukonceni (lze vyvratit),
    \item SIGUSR1, SIGUSR2 - uzivatelske signaly (uzivatel si je muze nadefinovat)
    \item SIGCHLD - pozastaveni ci ukonceni potomka,
    \item SIGCONT - dochazi pri uvolneni z cekani,
    \item SIGSTOP, SIGSTP (Ctrl+Z) - tvrde / mekke pozastaveni,
    \item dalsi viz man 7 signal \\
\end{itemize}

\textbf{definice:}
\textit{race conditions} jsou casove zavisle chyby (zavisi na tom, jak se v case na sobe nakladaji paralelni akce) \\

\subsubsection{Predefinovani obsluhy signalu}
Mezi implicitni reakce na signal patri \textbf{ukonceni procesu} (pripadne s generovani core dump), \textbf{ignorovani signalu, zmrazeni ci rozmrazeni procesu}. 

Predefinovat obsluhu lze u vsech signalu \textbf{mimo SIGKILL, SIGSTOP}. U SIGCONT vzdy dojde k odblokovani procesu (a nasledne se provede preddefinovana akce). \\

Vlastni predefinovani obsluhy:
\begin{itemize}
    \item pouziji se funkce signal (zakladni - jaky signal chci obsluhovat a jakou funkci, funkce ma jediny parametr - cislo signalu)
    \item nebo sigaction (urci se jaka funkce bude obsluzna, moznst nastaveni blokovani signalu behem obsluhy, dalsi specialni rezimy, .. ) 
    \item vice viz. man signal nebo man sigaction \\
\end{itemize}

Prednastavene konstanty:
\begin{itemize}
    \item SIG\_DFL - prednastaveny signal ma byt obsluhovan implicitnim zpusobem
    \item SIG\_IGN - signal ma byt ignorovan \\
\end{itemize}

Z obsluzne funkce je mozne volat pouze bezpecne knihovni funkce. (viz. man 7 signal - na konci seznam funkci, ktere se mohou pouzit pri obsluze funkci) \\

\subsubsection{Blokovani signalu}
Je vhodne nastavit masku blokovani signalu, volani:
\begin{itemize}
    \item sigprocmask (rekneme jake nastaveni signalu menime),
    \item pomoci SIG\_BLOCK (co chceme blokovat), SIG\_UNBLOCK (odblokovat), SIG\_SETMASK (natvrdo nastavit masku blokovanych signalu). \\
\end{itemize}

Blokovani se resi pomoci \textbf{bitovych masek}, ktere jsou typu sigset\_t. K vytvareni masek je mozne pouzit preddefinovana makra sigemptyset, sigfillset, segaddset, sigdelset. Nelze blokovat signaly \textbf{SIGKILL, SIGSTOP, SIGCONT}.

\textbf{Nastaveni blokovani se dedi blokovani potomku} (proces si nastavi blokovani - fork - dedi to i potomci, pri execu obsluzne funkce zanikaji). Pokud chceme zjistit, zda nejake signaly cekaji, zavolame sigpending (preda se ukazatel na masku signalu). Pokud nejaky signal je zablokovan, ale prijde vicekrat, zapamtuje se jeho \textbf{vyskyt pouze 1x}. (neplati pro realtime signaly)

\subsubsection{Zasilani signalu}
Slouzi k tomu volani kill (s parametry pid - komu chceme signal poslat a cislo signalu, ktery zasilame). Umoznuje zasilat signaly:
\begin{itemize}
    \item jednomu konkrektnimu procesu (pid kladne),
    \item skupine procesu (0 - ve skupine, ve ktere proces je),
    \item vsem procesum, kterym proces muze signal poslat (pid = -1, nebo zapornejsi cislo - posle se dane skupine [-10] = vsem v skupine 10). \\
\end{itemize}

Aby mohl proces zaslat signal jinemu procesu, musi odpovidat \textbf{jeho UID, EUID ci saved set-user-ID ciloveho procesu} (nelze posilat signaly nekomu jinemu), pripadne se musi jednat o privilegovaneho odesilatele (napr. EUID=0, nebo CAP\_KILL).

Muze se pouzit i sigqueue pro volani s realtime signaly.

\subsubsection{Cekani na signal}
Meli bychom na signaly cekat \textbf{pasivne} (nikoli se aktivne neustale dokola ptat, zda signal uz prisel). Budto:
\begin{itemize}
    \item jednoduche cekani pause,
    \item obvykle lepsi zabezpecene cekani sigsuspend - je mozne specifikovat masku signalu, ktere maji byt blokovany po dobu cekani a atomicky prepnout mezi signaly jsou blokovany do zacatku cekani a od zacatku cekani (muze se stat, ze probehne test, zda prisel nejaky signal a zjisti se, ze neprisel - zacne se cekat a prijde mezi testem a zacatkem cekani - cekani do nekonecna) \\
\end{itemize}

\newpage

\section{}
\textbf{Desata prednaska:} Nove tema - synchronizace procesu.

\subsection{}

\end{document}
