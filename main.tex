\documentclass[a4paper, 11pt]{article}
\usepackage[a4paper, text={17cm, 24cm}, left={2cm}, top={3cm}]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{times}
\usepackage[czech]{babel}
\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{graphics}
\usepackage{caption}

\title{IOS - Operacni systemy}
\date{}

\begin{document}
%%
%%  TITULNI STRANA
%%
\begin{titlepage}

\begin{center}
\LARGE
\textsc{\Huge Vysoke uceni technicke v Brne}\\
\textsc{\huge Fakulta informacnich technologii}\\
\vspace{\stretch{0.382}}
IOS - Operacni systemy\\[0.4em]
{\Huge poznamky z prednasek}
\vspace{\stretch{0.618}}
\end{center}
{\Large 2019/2020 \hfill Corse \& US Layout}

\end{titlepage}

%%
%% OBSAH
%%

\tableofcontents

%%
%%  TEXT
%%

\newpage

\section{}
\textbf{Prvni prednaska:} Uvod do predmetu, prehled operacnich systemu, zakladni pojmy, jadro operacniho systemu a jejich typy, historie vyvoje operacnich systemu, prehled technickeho vybaveni, klasifikace pocitacu, operacnich systemu, hlavni smery ve vyvoji operacniho systemu. \\
\subsection{Uvod, prehled operacnich systemu}

Operacni system je vyznamnou casti vypocetnich systemu, ty zahrnuji:
\begin{itemize}
    \item hardware, 
    \item operacni system,
    \item uzivatelske aplikacni programy,
    \item uzivatele. \\
\end{itemize}

Prehled nekterych OS:
\begin{itemize}
    \item GNU/Linux 
    \begin{itemize}
        \item GNU/Debian - Ubuntu 
        \item Red Hat - RHEL, Fedora, Cent OS 
        \item SuSE 
        \item Gentoo, Arch Linux, Slackware (= nejstarsi live distribuce linuxu) 
    \end{itemize}
    \item BSD 
    \begin{itemize}
        \item FreeBSD, OpenBSD 
    \end{itemize}
    \item GNU
    \begin{itemize}
        \item zn. GNU Is Not Unix
    \end{itemize}
    \item MS Windows 
    \item Mac OS X
    \begin{itemize}
        \item jadro XNU = X is Not Unix
    \end{itemize}
    \item Android, iOS 
    \item Minix
    \begin{itemize}
        \item pouziva intel ve svych cipech \\
    \end{itemize}
\end{itemize}
\newpage

\subsection{Zakladni pojmy}

Operacni system je program (resp. kolekce programu), ktera vytvari spojujici mezivrstvu mezi hardware operacniho systemu  a uzivateli a jejich uziv. aplik. programy. OS dale spotrebovava zdroje, jako jsou pamet nebo cas CPU.
(tldr: sw, spojujici hardware, uzivatele a programy) \\

\noindent\textbf{Cile OS:}
\begin{itemize}
    \item maximalni vyuziti zdroju pocitace - drahe pocitace, levnejsi pracovni sila (drive)
    \item jednoduchost pouziti pocitacu - levne pc, draha pracovni sila (dnes prevazuje) \\
\end{itemize}

\noindent\textbf{Zakladni role OS:}
\begin{itemize}
    \item spravce prostredku
        \begin{itemize}
            \item pamet, procesor, periferie
             \item dovoluje sdilet prostredky efektivne a bezpecne
        \end{itemize}
    \item tvurce prostredi pro uzivatele a jejich aplikacni programy
        \begin{itemize}
            \item vytvareni abstrakci, virtualnich objektu (resp. poskytuje standardni rozhrani, ktere zjednodusuje prenositelnost aplikaci a zauceni uzivatelu)
            \item abstrakce jsou napr.: proces, program, soubor
            \item problemy abstrakci jsou mensi efektivita a nepristupne nektere nizkourovnove operace \\
        \end{itemize}
\end{itemize}

\noindent\textbf{OS zahrnuje:}
\begin{itemize}
    \item jadro (kernel),
    \item systemove knihovny a utility (= systemove aplikacni programy),
    \item textove (shell) ci graficke uzivatelske rozhrani (X Window). \\
\end{itemize}

\noindent Presna definice, co vse OS zahrnuje neexistuje. Ruzne firmy a komunity to chapou ruzne. (GNU to chape napr. jako projekt svobodneho OS, zahrnujici jadro, utility, GUI, TUI, vyvojove prostredky a knihovny, ...) \\[1em]

\noindent\textbf{definice:} \\[0.5em] \label{procesy} \label{soubory}
\textit{proces} je aktivita rizena programem \\[0.2em]
\textit{program} je predpis, navod na nejakou cinnost zakodovany vhodnym zpusobem \\[0.2em]
\textit{soubor} je kolekce zaznamu (obvykle Byte) slouzici primarne jako zakladni jednotka pro ukladani dat na vnejsich pametovych mediich \\[0.2em]
\textit{adresar} je kolekce souboru

\newpage

\subsection{Jadro operacniho systemu}

Jedna se o nejnizsi a nejzakladnejsi cast OS. Zavadi se jako prvni a bezi po celou dobu behu pocitacoveho systemu (tzv. reaktivni system, spis nez transformacni). Navazuje primo na hardware (pripadne virtualizovany HW) a pro uzivatele a uziv. aplik. zcela zapouzdruje. \\

\noindent\textbf{Bezi v privilegovanem rezimu:}
\begin{itemize}
    \item je mozne menit obsah registru hw, je mozne zadavat prikazy hw (neni mozne v uzivatelskem rezimu)
    \item musi byt podporovano v hardware \\
\end{itemize}

\noindent\textbf{Jadro (obecne) zajistuje:}
\begin{itemize}
    \item zakladni spravu prostredku a tvorbu zakladniho prostredi jak pro uzivatele tak pro zbytek OS
    \item zahrnuje vsechny operace, kdy je potreba primo komunikovat s hardware (prepinani kontextu - jadro, plaovani procesu - nekdy v jadru, nekdy mimo, zavedeni stranky z disku, ..)
    \item sluzby pro zbytek OS a uzivatele, nektere zajistuje automaticky
    \item nektere sluby nejsou poskytovany automaticky, musi si o ne zadat, nazyvame to volani sluzeb, tzv. \textit{system-call} \label{syscall} (= systemova volani), ktere musi byt implemenovana uzitim specializovanych instrukci (intel: sw preruseni, syscall, sysenter) \\
\end{itemize}

\noindent\textbf{Rozlisujeme dva typy rozhrani OS:} \label{kernel-interfaces}
\begin{itemize}
    \item \textit{kernel interface} (nebo taky: ABI, Kernel ABI) - prime volani jadra pomoci specializovanych instrukci
    \item \textit{library interface} - rozhrani vyssi urovne (napr. C knihovny), typicke sluzby jsou napr. printf z C - volaji se funkce ze         systemovych knihoven, mohou ale nemusi vest na volani sluzeb jadra (bezne aplikace pracuji s timto rozhranim) \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{transformacni system} je system, ktery dostane nejaky vstup, zpracuje ho a udela nejaky vystup (prekladac) - pokud se zacykli = chyba \\[0.2em]
\textit{reaktivni system} se spusti a do (teoreticky) nekonecna reaguje na podnety uzivatele (spust proces - spusti proces) - pokud prestane pracovat = chyba \\[0.2em]
\textit{prepinani kontextu} je situace, kdy na CPU bezi proces, ten chci pozastavit a nechat bezet jiny proces \\[0.2em]
\textit{instrukce syscall a sysenter} - jakmile aplikace (bezi v uziv. rezimu) zavola takovou instrukci, dojde ke kontrolovanemu prepnuti do rezimu jadra, provede se sluzba, a pote se prepne zpet \\[0.2em]
\textit{ABI} = Application Binary Interface

\newpage

\subsection{Typy jader OS}

\noindent\textbf{Monoliticka jadra}
\begin{itemize}
    \item vysokourovnove komplexni rozhrani s radou sluzeb, abstrakci, ktere mohou pouzivat vyssi vrstvy OS
    \item vsechny subsystemy jsou implementovany v privilegovanem rezimu, rezimu jadra, a zahrnuji napr. spravu pameti, planovani, meziprocesovou komunikaci, souborove systemy, ..
    \item vyhody: vysoka efektivita diky provazanosti
    \item nevyhody: mala flexibilita pri praci s jadrem (ve filesystemu je chyba, chci zmenit jen implementaci filesystemu za novou verzi a vse ostatni nechat - nelze, je nutne cely system zastavit a znovu nastarovat, nelze menit nic za behu) \\
\end{itemize}

\noindent\textbf{Monoliticka jadra s modularni strukturou}
\begin{itemize}
    \item vylepseni koncepce monolitickych jader
    \item umoznuje zavadet/odstranovat subsystemu jadra v podobe tzv. modulu za behu
    \item vyhody: neni nutne cely system zastavovat a znovu bootovat pro vymenu jednoho modulu, vyssi bezpecnost - zavedou se jen moduly, ktere se budou pouzivat
    \item pouzivane v napr. FreeBSD, Linux \\
\end{itemize}

\noindent\textbf{Mikrojadra}
\begin{itemize}
    \item snaha minimalizovat rozsah jadra a rozsah jeho sluzeb
    \item nabizi jednoduche rozhrani, maly pocet abstrakci, sluzeb, typicky nabizi nejzakladnejsi spravu CPU. I/O zarizeni, pameti, ..
    \item vetsina sluzeb nabizenych monolitickymi jadry (ovladace, vyznamne casti spravy pameti, planovani) je implemenovana mimo jadro v tzv. serverech (nebezi v privilegovanem rezimu).
    \item vyhody: flexibilita (vice soucaasne bezicich implementaci ruznych sluzeb, dynamicke spousteni, zastavovani..), zabezpeceni (chyba v serveru / utok na ne neznamena ovladnuti celeho OS, ale jen daneho serveru)
    \item nevyhody: vyrazne vyssi rezie \\
\end{itemize}

\noindent\textbf{Generace mikrojader}
\begin{itemize}
    \item 1. generace - napr. Mach
    \item 2. generace - napr. L4, mensi rezie nez 1. gen
    \item 3. generace - napr. seL4 nebo ProvenCore, duraz na zabezpeceni, navrh s ohledem na moznost formalni verifikace \\
\end{itemize}

\newpage

\noindent\textbf{Hybridni jadra}
\begin{itemize}
    \item "neco mezi mikrojadry a monolitickymi jadry"
    \item jadra zalozena na mikrojadrech, rozsirena o kod, ktery by mohl byt implementovan ve forme serveru, je ale za ucelem mensi rezie tesneji provazan s mikrojadrem a bezi v jeho rezimu
    \item pouzivane v napr. Mac OS X (Mach + BSD), Windows NT (a vyssi), ... \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{servery (v oblasti mikrojader)} jsou procesy \\[0.2em]
\textit{formalni verifikaci} rozumime overeni urcitych vlastnosti systemu s platnosti matematickeho dukazu \\[0.5em]

\noindent\textbf{linux prikazy:} \\[0.5em]
\textit{lsmod} - vypise aktualne zavedene moduly jadra \\[0.2em]
\textit{rmmod} - maze moduly jadra \\[0.2em]
\textit{modprobe} - zavadeni modulu do jadra \\[0.2em]

\newpage

\subsection{Historie vyvoje OS}

\noindent\textbf{definice:} \\[0.5em] \label{hist-preruseni}
\textit{preruseni} je elektricky signal, ktery jde od periferie po sbernici k procesoru, na CPU vyvola obsluhu preruseni - mechanismus umoznujici rozbehnout operaci na periferii a o tu periferii se nestarat (periferie pote oznami konec operace) (podrobne se tomu venuje oddil \ref{hw-preruseni}) \\[0.2em]
\textit{multitasking} je soucasny beh vice aplikaci na jednom procesoru (muze byt s preemtivnim nebo nepreemtivnim planovanim) \\[0.2em]
\textit{nepreemtivni planovani} zn. ze uloha, kt. aktualne bezi na CPU muze byt od CPU "odstavena" pouze tehdy, kdyz nejak zakomunikuje s jadrem (= pozada o sluzbu jadra, napr. periferni operace), dokonce lze pouzit specializovane sluzby pro prepnuti kontextu (proces se dobrovolne vzda CPU, tzv. yield sluzby) - vyhoda: snadna implementace, nevyhoda: pokud se proces zacykli (chyba), cely system se zablokuje (porad bezi 1 uloha) \\[0.2em]
\textit{preemtivni planovani} - proces muze byt odstaven od CPU bez nutnosti komunikace s jadrem, napr. pomoci preruseni (jakehokoli typu) \\[1em]

\subsection{Prehled technickeho vybaveni}

\noindent\textbf{Procesor (CPU):}
\begin{itemize}
    \item radic, ALU, registry (IP, SP), instrukce, .. \\
\end{itemize}

\noindent\textbf{Pamet:} \label{hiearchie-pameti}
\begin{itemize}
    \item adresa
    \item hiearchie pameti (cache, RAM, disky, ... - bank pameti muze byt vice)
    \begin{itemize}
        \item pameti se lisi spotrebou, kapacitou, rychlosti, cenou za jednotku
        \item na vrcholu hiearchie jsou registry (nejrychlejsi, nejvyssi cena za jednotku, mala kapacita)
        \item cache (vyrovnavaci pameti, ruznych urovni, L1 = level 1, L2, L3, ..)
        \item primarni pamet RAM
        \item sekundarni pameti - disky (SSD, HDD)
        \item vyrovnavaci pameti disku
        \item tercialni pameti (zalohy - nejnizsi cena za jednotku, nejpomalejsi, nejvetsi kapacita - pasky, CD/DVD, externi disky, cloudy, sitove disky, ..) \\
    \end{itemize}
\end{itemize}

\noindent\textbf{Periferie:}
\begin{itemize}
    \item disk (HDD, SDD,..), klavesnice, monitor (I/O porty, preruseni, DMA) \\
\end{itemize}

\noindent\textbf{Sbernice:}
\begin{itemize}
    \item propojuji jednotlive komponenty
    \item na vrcholu hiearchie jsou sbernice propojujici CPU a pamet (FSB - Front Side Bus, HyperTransport QPI - Quick Path Interconnect)
    \item diskove sbernice (SATA/ATA, SCSI/SAS, USB)
    \item dalsi sbernice (NVLink - pripojovani nVidia GPU, PCI - rozsirujici karty ci disky, CAPI - IBM Tauer CPU, propojovani CPU a akceleratoru) \\
\end{itemize}
 
\noindent\textbf{definice:} \\[0.5em] \label{i-o}
\textit{I/O porty} = vstup-vystupni porty, predstavuji pametove oddeleny prostor od adresoveho prostoru bezne pameti, s temito adresami se komunikuje specialnimi instrukcemi (intel: inout) \\[0.2em]
\textit{pametove mapovane I/O} je cast adresoveho prostoru bezne pameti neni pouzita pro praci s pameti, ale adresy jsou presmerovane do HW (neco co zapisu na danou adresu nebude v pameti ale v nejakem registru HW) \\[0.2em]
\textit{DMA} zn. Direct Memory Access, souvisi s nezavislou cinnosti periferii - periferie mohou primo komunikovat s hardware (radic disku si sam z adresy pameti nacte data a pres sbernice je prenasi na disk, nebo naopak) \\[0.2em]

\subsection{Klasifikace pocitacu}

\noindent\textbf{Dle ucelu:}
\begin{itemize}
    \item univerzalni,
    \item specializovane
    \begin{itemize}
        \item vestavene (palubni pc, spotrebni elektronika, ..)
        \item aplikacne orientovane (rizeni db, sitove servery, ..)
        \item vyvojove (zkouseni novych technologii) \\
    \end{itemize}
\end{itemize}

\noindent\textbf{Podle vykonnosti:}
\begin{itemize}
    \item vestavene pc, tablety, mobily, ..
    \item osobni pocitace (PC) a pracovni stanice (workstation) - dnes se nerozlisuje
    \item servery
    \item strediskove pocitace (mainframe) - vyrabi IBM, ladene na obrovsky I/O vykon a vysokou spolehlivost
    \item superpocitace - ladene na surovy vypocetni vykon (vedecke vypocty, simulace) \\
\end{itemize}

\newpage

\subsection{Klasifikace OS}

\noindent\textbf{Podle ucelu:}
\begin{itemize}
    \item univerzalni (UNIX, Linux, Windows, ..)
    \item specializovane (real-time - RT-Linux, databaze, web - z/VSE, mobilni - iOS, Android) \\
\end{itemize}

\noindent\textbf{Podle poctu uzivatelu:}
\begin{itemize}
    \item jednouzivatelske (CP/M, MS-DOS,..)
    \item viceuzivatelske (UNIX, Windows, ..) \\
\end{itemize}

\noindent\textbf{Podle poctu soucasne bezicich uloh:}
\begin{itemize}
    \item jednoulohove
    \item viceulohove (multitasking, ne/preemptivni) \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{soft real-time} - doporuceni aby se akce vykonavaly v realnem case \\[0.2em]
\textit{hard real-time} - akce se musi vykonavat v urcitem case \\[1em]

\subsection{Implementace OS}

OS se obtizne programuji a ladi, protoze to jsou velke programove systemy, paralelni a asynchronni systemy, systemy zavisle na technickem vybaveni. \\

\noindent\textbf{Dusledky:}
\begin{itemize}
    \item setrvacnost pri implementaci (snaha nemenit kod, ktery pracuje spolehlive)
    \item pouzivani technik pro minimalizaci vyskytu chyb (inspekce zdrojoveho kodu, rozsahle testovani, podpora vyvoje technik formalni verifikace) \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{paralelni system} zn. ze zde bezi vice aktivit soucasne \\[0.2em]
\textit{paralelni asynchronni systemy} - procesy se prepinaji v okamzicich, ktere nelze dopredu presne predpovedet \\[1em]

\newpage

\subsection{Hlavni smery ve vyvoji OS}
\begin{itemize}
    \item neustale vylepsovani architektur (snizovani rezii jader,)
    \item bezpecnost, spolehlivost
    \item podpora stale vetsiho poctu procesoru, vice jader
    \item virtualizace
    \item distribuovane zpracovani (cloudy, kontejnery, Internet of Things)
    \item OS tabletu, mobilu, vestavenych systemu, ...
    \item vyvoj novych technik navrhu a implementace OS (podpora formalni verifikace) \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{bezpecnost} zn., ze system je odolny vuci vnejsim utokum \\[0.2em]
\textit{spolehlivost} zn., ze system "nespadne sam od sebe"




%%
%% 2
%%
\newpage

\section{}
\textbf{Druha prednaska:} Unix - uvod: historie UNIXu (nezkousi se), priciny uspechu UNIXu, varianty UNIXu, zakladni koncepty, struktura jadra, komunikace s jadrem - hardwarova preruseni. Prehled programovani v UNIXu: nastroje programatora, ..


\subsection{Priciny uspechu UNIXu}
\begin{itemize}
    \item viceprocesovy, viceuzivatelsky,
    \item napsan v C - prenositelny,
    \item zpocatku (a pozdeji) siren ve zdrojovem tvaru,
    \item "mechanism, not policy",
    \item "fun to hack",
    \item jednoduche uzivatelske rozhrani (terminal),
    \item skladani slozitejsich programu z jednodussich (tvoreni aplikaci typu filtr),
    \item hierarchicky system souboru,
    \item konzistentni rozhrani perifernich zarizeni \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{"mechanism, not policy"} zn. snaha oddelit casti aplikaci (napr. GUI - oddelit zakladni rutiny pro vykreslovani grafiky od politik, tzn. koncove nastavby - barvy oken, umisteni tlacitek, .. - systematicke rozdeleni vede k lepsim optimalizacim a ladenim algoritmu a zaroven rychlym zmenam politik) \\[0.2em]
\textit{"fun to hack"} zn., lide se na vyvoji podili, protoze je to bavi (nejen protoze jsou za to placeni) \\[0.2em]
\textit{aplikace typu filtr} - jednoduche otevrene aplikace, na vstupu maji textovy dokument v otevrene podobe, vstup zpracuji a na vystupu opet otevreny dokument (zadne binarni, zakodovane) \\[1em]

\newpage

\subsection{Varianty UNIXu}
\textbf{Hlavni vetve OS UNIXoveho typu:}
\begin{itemize}
    \item UNIX System V (puvodni system z AT\&T),
    \item BSD UNIX (FreeBSD, NetBSD, ..),
    \item firemni varianty (AIX, Solaris, ..)
    \item Linux \\
\end{itemize}

\noindent\textbf{Sousisejici normy:}
\begin{itemize}
    \item XPG - X/OPEN, SVR4 - AT\&T,SUN, OSF/1, Single UNIX Specification,
    \item POSIX - IEEE standard,
    \item Single UNIX Specification v3/v4 - shell, utility (CLI), API \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{POSIX} je striktni podmnozina Single UNIX Specification, je to standard definujici zakladni textove prikazove rozhrani OS + API \\[1em]

\subsection{Zakladni koncepty}
Jsou dve zakladni koncepce (abstrakce) UNIXu: \textbf{procesy} a \textbf{soubory}. \\

\noindent Procesy mezi sebou komunikuji pomoci ruznych mechanismu meziprocesove komunikace - IPC (Inter-Process Communication) - roury, signaly, semafory, sdilena pamet, sockets, zpravy, streams, .. a pro komunikaci pouzivaji nejake I/O rozhrani (read, write, close, ..) \\

\noindent\textbf{definice:} \\[0.5em]
\textit{procesy} jsou abstrakci probihajici nejake aktivity (viz \ref{procesy})\\[0.2em]
\textit{soubory} jsou abstrakci dat (viz \ref{soubory}) \\[1em]

\newpage

\subsection{Struktura jadra UNIXu}
Zakladni podsystemy jsou sprava souboru a sprava procesu. \\
\textbf{Popis:}
\begin{itemize}
    \item Na hornim okraji jadra (smerem k uzivatelum, aplikacim) je vrstva implementujici rozhrani volani sluzeb, prostrednictvim ktere jadro prebira zadosti o sluzby od aplikaci. Rozhrani kontroluje zda ten, kdo o sluzbu zada ji muze volat, zda jsou parametry validni a rozhrani predava pozadavek dal do jadra.
    \item Aplikace mohou s jadrem komunikovat primo, nicmene nejcasteji komunikuji s jadrem pres knihovny. (viz. \ref{kernel-interfaces})
    \item Na druhem okraji (tesne nad HW) je vrstva abstrakce hadrware.
    \item Mezi spravou souboru a hardware se nachazi ovladace, pote vrstva vyrovnavacich pameti, ktere souborove systemy pouzivaji ke zrychleni prace s relativne pomalymi disky (HDD, SSD - oproti RAM pomale) - OS se snazi vyhnout opakovanemu cteni stejnych dat, proto si v jednom okamziku nacte vic dat nez uzivatel zada, ulozi si data do vyrovnavaci pameti (pri dostatku pameti) a data nacita odtud. (napr. C knihovny jsou pouzivane kazdym druhym programem - jsou v pameti temer porad). \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em] \label{ovladace}
\textit{ovladace} jsou programy slouzici k rizeni (zadavani prikazu, prebirani stavovych informaci, reseni mimoradnych stavu konkretnich periferii) - lze je (jako i prislusna zarizeni) rozdelit na znakova a blokova (kratsi definice viz \ref{ovladac}) \\[0.2em]
\textit{znakova zarizeni} jsou zarizeni komunikujici po jednotlivych znacich (klavesnice) \\[0.2em]
\textit{blokova zarizeni} komunikuji po blocich (disk - sektory, resp. bloky) \\[0.2em]
\textit{komunikaci s jadrem} rozumime nastavovani parametru hardware, vydavani prikazu hw, obsluhu ruznych stavu do kterych se hw dostava (a o kterych je CPU a jadro informovano prostrednictvim preruseni) \\[0.2em]
\textit{nastavovani parametru hw} se deje pomoci I/O portu nebo pametove mapovanych operaci (viz \ref{i-o}) \\[0.2em]

\newpage

\subsection{Komunikace s jadrem a hardwarova preruseni} \label{hw-preruseni}
Sluzby jadra jsou operace, jejich realizace je pro procesy zajistovana jadrem. Explictne je mozne o provedeni urcite sluzby zadat prostrednictvim system call (viz \ref{syscall}). \\

\noindent\textbf{Priklady nekterych sluzeb jadra (systemova volani v UNIXu):}
\begin{itemize}
    \item open, close, read - otevre/zavre/cte soubor,
    \item write - zapisuje,
    \item kill - posle signal,
    \item fork - duplikuje proces,
    \item exec - prepise kod,
    \item exit - ukonci proces. \\
\end{itemize}

\subsubsection{Hardwarove preruseni}
\begin{itemize}
    \item hardware interrupt je mechanismus, kterym HW zarizeni oznamuji jadru asynchronne vznik udalosti, ktere je zapotrebi obslouzit (dalsi mozna definice viz \ref{hist-preruseni}),
    \item zadosti o HW preruseni prichazi jako elektricke signaly (IRQ) do radice preruseni (APIC),
    \item procesor s radicem preruseni komunikuje pomoci I/O portu. \\
\end{itemize}

\noindent\textbf{Prijem nebo obsluju HW preruseni lze zakazat:}
\begin{itemize}
    \item maskovanim preruseni, 
    \item na CPU (instrukce CLI/STI na Intel/AMD - zakazou se vsechna krome NMI),
    \item ciste programve v jadre (preruseni se prijme, ale jadro si jen poznamena jeho prichod a neobsluhuje se) \\
\end{itemize}

\noindent\textbf{NMI:}
\begin{itemize}
    \item non-maskable interrupt je HW preruseni, ktere nelze zamaskovat na radici ani zakazat na CPU,
    \item pouziva se pri kritickych chybach pameti, sbernice, .. (alternativne se pouziva pro ladeni / reseni uvaznuti v jadre "NMI watchdog") \\
\end{itemize}

\noindent\textbf{Preruseni mohou vznikat i v CPU - jsou to synchronni preruseni, tzv. vyjimky (= exceptions):}
\begin{itemize}
    \item trap - po obsluze se pokracuje dalsi intrukci (breakpoint, overflow, ..)
    \item fault - po obsluze se znovu opakuje intrukce, ktera vyjimku vyvolala (vypadek stranky, deleni 0, ..)
    \item abort - dochazi k zavaznym problemum detekovanym CPU, neni jasne jak pokracovat - provedeni se ukonci (zanorene vyjimky typu fault, chyby HW detekovane CPU) \\
\end{itemize}

\textbf{Mohou existovat i dalsi typy preruseni:} (tato preruseni obsluhuje CPU zcela specifickym zpusobem (casto mimo vliv jadra, napr. na Intel/AMD))
\begin{itemize}
    \item Interprocessor interrupt (IPI)
    \begin{itemize}
        \item meziprocesorove preruseni
        \item pouziva se pro preposilani preruseni z jednoho CPU na druhy nebo pro spravu cache (kazdy CPU ma svoji cache, do nich mohou mit CPU nacteny stejne adresy z pameti - pokud dojde ke zmenam v pameti, musi CPU informovat ostatni CPU o zmene)
    \end{itemize}
    \item System management Interrput (SMI)
    \begin{itemize}
        \item preruseni typu sprava systemu
        \item muze byt vyvolano HW i SW ve zvlastnich situacich
        \item pokud se takove preruseni vyvola, tak se dostane ke slovu firmware, ktery provadi obsluhu ruznych chybovych stavu (prehrati, vybita baterie, ..)
        \item v ramci SMI nebezi bezne aplikace ani jadro, nesmi obsluha SMI bezet prilis dlouho (system se muze dostat do nekonzistentniho stavu) \\
    \end{itemize}
\end{itemize}

\subsubsection{Zakazovani preruseni}
\textbf{Proc preruseni zakazovat?}
\begin{itemize}
    \item v ramci obsluhy jednoho preruseni muze nastat dalsi preruseni,
    \item napr. na CPU bezi vypocet, neco nastane na disku, disk posle preruseni, to dojde k CPU a jadro zacne preruseni obsluhovat, v ten moment se neco stane na klavesnici a prijde dalsi preruseni,
    \item pote dale v ramci obsluhy muze jadro upravovat ruzne sve interni struktury, ktere mohou byt v nekonzistentnim stavu (napr. zretezene seznamy procesu [ukazatele], ruzne si je projuje, nez je stihne propojit, prije dalsi proces a muze sahnout do pameti kam nema),
    \item proto obsluha preruseni musi byt synchronizovana a v pripade, ze se v ramci preruseni provadi nejaka kriticka operace je nutne vyloucit ostatni (vsechna) preruseni \\
\end{itemize}

\newpage

\subsubsection{Pristupy k zakazovani preruseni}

Pokud vsak zakazu (nejaka/vsechna) preruseni, abych se mohl venovat obsluze jednoho a budu ho obsluhovat prilis dlouho, system se muze dostat do nekonzistentniho stavu (jako u SMI). Pouzivaji se proto dva pristupy:
\begin{itemize}
    \item je snaha zakazovat jen preruseni s nizsimi prioritami,
    \item rozdelit obsluhu preruseni do vice casti (urovni).
\end{itemize}

\noindent\textbf{Obsluha preruseni je casto delena na dve urovne:}
\begin{itemize}
    \item 1. uroven:
    \begin{itemize}
        \item ma byt co nejkratsi,
        \item v ramci obsluhy preruseni se zakomunikuje nezbytnym zpusobem s HW (prevzani dat z/do HW, vydani prikazu HW, ..) a naplanuje se beh 2. urovne,
        \item nelze pouzit bezne synchronizacni prostredky (protoze napr. CPU bezi nejaky vypocet, prijde preruseni z disku, jadro zacne resit 1. uroven obsluhy, nicmene obsluha != proces)
    \end{itemize}
    \item 2. uroven:
    \begin{itemize}
        \item dokoncuje obsluhu preruseni,
        \item provadi se operace, kdy neni potreba komunikovat s hardware,
        \item nemusi se zakazovat preruseni,
        \item muze bezet v specialnich procesech (interrup threads ve FreeBSD nebo tasklety/softIRQ v Linuxu),
        \item mohou se pouzit bezne synchronizacni prostredky \\
    \end{itemize}
\end{itemize}

\subsubsection{Ovladace zarizeni a preruseni}
\begin{itemize}
    \item pri inicializaci ovladace (v Linuxu je to typicky modul) nebo pri jeho prvnim pouziti se musi registrovat k obsluze urciteho IRQ,
    \item bud u nekterych zarizeni se pouzivaji (historicky) zafixovana cisla preruseni,
    \item nebo ovladac muze zjistit cislo preruseni tak, ze zakomunikuje s radicem sbernic, pokud to nefunguje,
    \item ovladac vyda prikaz zarizeni, ktere ma ovladat, aby zacalo vysilat nejaka preruseni (a "poslouchala" sbernici, "kdo se ozve"),
    \item pote se zaregistruje k obsluze prislusneho preruseni a hardware se pres tabulku preruseni ovladac "dostane ke slovu",
    \item vice zarizeni vsak muze pouzivat stejne cislo zadosti o preruseni
    \begin{itemize}
        \item v takovem pripade jadro vytvori zretezeny seznam ovladacu, ktere maji zajem o dane preruseni
        \item ovladace musi byt napsane tak, ze pokud jim dojde preruseni (o ktere maji zajem), tak musi zakomunikovat s tim zarizenim a zeptat se ho, zda opravdu to zarizeni poslalo dane preruseni
        \item pokud ano - obslouzi se, pokud ne - preda se rizeni preruseni dalsimu ovladaci v seznamu \\
    \end{itemize}
\end{itemize}


\subsubsection{Priklad komunikace s jadrem} \label{pristup-na-disk}
Synchronni komunikace je proces-jadro, asynchronni je hardware-jadro. Priklad (detailnejsi, ale na tema pristupy na disk viz \ref{pristup-na-disk-detailed}):
\begin{itemize}
    \item proces A zavola sluzbu read() a jadro ihned zacne volani obsluhovat (synchronni)
    \item nejprve se podiva do cache zda data, o ktera ma zajem proces A uz tam nejsou
    \item pokud ano, tak mu je rychle nakopiruje z cache na adresu, kterou pozaduje proces (bez komunikace s diskem)
    \item pokud data nejsou v cache, proces A bude pozastaven a jadro vyda prostrednictvim ovladacu disku prikaz k nacteni urciteho objemu dat, typicky vice nez zada uzivatel a nacita do vyrovnavaci pameti (ne na pozadovanou adresu)
    \item na procesoru dale bezi proces B, taky pozada o read(), zopakuje se to same co u A
    \item az disk dokonci operace jednoho z procesu (nemusi byt v poradi volani), disk posle preruseni na CPU
    \item jadro bude informovano, ze ma potrebna data pro proces A/B
    \item z cache nakopiruje pozadovana data na pozadovanou adresu
    \item pote se proces A/B probudi a bezi dal, to same se stane u dalsiho procesu \\
\end{itemize}


\noindent\textbf{definice (pro \ref{hw-preruseni}.x):} \\[0.5em]
\textit{asynchronni} zn., bez prime-okamzite vazby na to co dela jadro nebo aplikace (tiskarna tiskne - operace nekdy skonci - ale nikdy nevim dopredu kdy presne) \\[0.2em]
\textit{synchronni} zn., ze CPU neco provede a ihned se zavola preruseni (napr. deleni 0) \\[0.2em]
\textit{IRQ} = interrupt request \\[0.2em]
\textit{radic preruseni} = interrput controller, hardwarova jednotka, ktera predava preruseni do CPU - registruje prichozi IRQ, ty se dle priorit predavaji do CPU (preruseni je mozne take zamaskovat - nepredavat dal do CPU) v podobe cisla preruseni, CPU se automaticky prepne do chraneneho rezimu a spusti obsluznou rutinu definovanou jadrem (preruseni 1 - provede xxx, 2 - xxx, ..) \\[0.2em]
\textit{APIC} = Advanced Programmable Interrupt Controller - distribuovany system, kazdy CPU ma lokalni APIC, externi zarizeni mohou byt pripojena primo / pres I/O APIC \\[0.2em]
\textit{NMI watchdog} - jadro si nadefinuje, ze casovac mu kazdych n casovych jednotek posle toto preruseni - pokud dojde v jadre k uvaznuti pri obsluze jineho preruseni a vsechna preruseni budou zakazana, toto se vzdy dostane do CPU (jadro se muze zotavit) \\[0.2em]
\textit{vypadek stranky} zn., (pamet je rozdelena na casti, ktere mohou byt rozdeleny na disk) kdyz proces bude sahat do pameti a sahne na stranku, ktera v ni neni - detekuje se ze stranka tam neni - poruseni ochrany pameti - jadro zkontruluje, zda proces nesaha kam by nemel, a pokud ne, tak mu stranku nahraje zpet do pameti a znovu se provede ta stejna instrukce \\[0.2em]
\textit{bezne synchronizacni prostredky} jsou napr semafory nebo zamky a synchronizuji procesy \\[1em]

\noindent\textbf{linux:} \\[0.5em]
zakladni statistiky o obsluze preruseni jsou v \textit{/proc/interrupts}

\subsection{Nastroje programatora UNIXu}
X-Window system, vzdaleny pristup pres X-Window uzitecne prikazy na linuxu, ovladani vimu, apod. - vice viz. 2. prednaska IOS, u zkousky to nebyva.

\section{}
\subsection{Bash, shell, experimenty}
\section{}
\subsection{Bash, shell, experimenty}
Treti a ctvrta prednaska je venovana hlavne shellu, prochazi se prakticky ruzne prikazy a provadi se experimenty, apod. - lepsi je shlednout + na zkousce nic takoveho nebyva.

\newpage

\section{}
\textbf{Pata prednaska:} Sprava souboru: pevny disk, diskove sbernice, sektory, parametry pevnych disku, SSD, problematika zapisu SSD, zabezpeceni disku, diskova pole (RAID), ulozeni dat na disku, fragmentace, pristup na disk a jeho planovani, logicky disk.
\subsection{Pevny disk}
\textbf{Popis:}
\begin{itemize}
    \item uvnitr maji radu kulatych ploten, zaznam se provadi na kazdem z tech dvou povrchu, je v soustrednich kruznicich (= tracks, stopy)
    \item vsechny plotny jsou na stejne ose, pridelane k sobe a rotuji soucasne
    \item k nacitani slouzi sada hlavicek, cteci a zapisove, jsou tam v tolika kusech, kolik je tam povrchu (napr. 3 plotny = 6 povrchu = 6 hlavicek), vsechny umistene na jednom rameni, vsechny hlavicky se pohybuji soucasne
    \item hlavicky jsou nastavene na sade nekolika stop (kruznic) o stejnem prumeru = cylindr,
    \item stopy se deli na sektory
    \item velikosti sektoru byly drive 512B, u CD/DVD 2048B, dnes 4096B \\
\end{itemize}

\noindent\textbf{Adresace sektoru:}
\begin{itemize}
    \item ze zacatku se pouzival CHS - urci se se kterym cylindrem chci pracovat, dale s kterou hlavou a jakym sektorem v ramci stopy,
    \item v soucasne dobe se pouziva LBA, kde jsou sektory (bloky) cislovane (jako adresy v pameti) od 0 po n, diskova jednotka si musi tato cisla prevadet na CHS \\

\end{itemize}

\noindent\textbf{Periferni ci diskova rozhrani:}
\begin{itemize}
    \item pouzivaji se pro pripojeni disku,
    \item nejbezneji se pouziva ATA, drive se pouzivala v paralelni verzi (PATA - jednotlive byty se posilaly paralelne, pri rostoucich rychlostech byl problem zajistit synchronizaci techto dat), nyni v seriove verzi (SATA)
    \item take se pouziva SCSI ci SAS (Serial Attached Scasi), USB, FireWire, FibreChannel, Thunderbold, PCI Express nebo NVMe (pripojovani nejrychlejsich SSD),
    \item nad temito rozhranimi muze byt dalsi HW rozhrani propojujici tyto sbernice, jako treba AHCI, OHCI, UHCI, .. \\
\end{itemize}

\newpage

\noindent\textbf{Diskove sbernice se lisi:}
\begin{itemize}
    \item rychlosti (SATA do 6 Gbit/s, SAS 22.5 Gbit/s),
    \item poctem pripojenych zarizeni (SATA desitky, 65535 SAS),
    \item maximalni delkou kabelu (1-2m SATA, 10m SAS),
    \item architekturou pripojeni (moznost pripojeni jednoho zarizeni vice cestami u SAS),
    \item seznamem prikazu, ktere to zarizeni umi (flexibilita pri chybach, selhani, zotaveni, ..) \\
\end{itemize}

Pres diskove sbernice je mozne mit pripojene i jine typy pameti, jako jsou flash disky, SSD, pasky, CD/DVD/BD ci tercialni pameti. V systemu vznika hierarchie pameti, viz. \ref{hiearchie-pameti}. \\

\noindent\textbf{definice:} \\[0.5em]
\textit{cylindr} (v HDD) je mnozina stop o stejnem prumeru \\[0.2em]
\textit{sektor} je nejmensi jednotka diskoveho prostoru, ktery mi umozni diskova elektronika nacist nebo zapsat \\[0.2em]
\textit{blok} nebo \textit{diskovy blok} je sektor v HDD \\[0.2em]
\textit{alokacni blok} nebo \textit{blok souboroveho systemu} je nejmensi jednotka, kterou umozni alokovat OS \\[0.2em]
\textit{CHS} zn. Cylinder Head Sector  \\[0.2em]
\textit{LBA} zn. Linear Block Adress \\[0.2em]

\subsection{Parametry pevnych disku}
Pristupova doba sestava z \textbf{doby vystaveni hlav} a \textbf{rotacniho zpozdeni}. \\

\noindent Typicke parametry soucasnych disku jsou kapacita, prumerna doba pristupu (jednotky ms u HDD) , otacky a prenosova rychlost. U prenosovych rychlosti se rozlisuje \textit{sustained tranfer rate} a \textit{maximum transfer rate}. \\

\noindent Mazani dat probiha tak, ze se prepisou metadata, pouze se poznamena (OS), ze dany soubor byl smazan. \\

\noindent\textbf{definice:} \\[0.5em]
\textit{doba vystaveni hlavicek} zn., ze pokud nejsou nastavene hlavicky na stope, se kterou chci pracovat (malokdy), tak je nutne pohnout hlavickami (vic zasunout dovnitr nebo vysunout) \\[0.2em]
\textit{rotacni zpozdeni} je doba nez mi pod spravne nastavenou hlavicku najede sektor (narotuje se disk) \\[0.2em]
\textit{maximum transfer rate} je spickova prenosova rychlost, jak maximalne rychle je schopen disk komunikovat po kratkou dobu (typicky rychlost predani dat z vyrovnavacich pameti disku) \\[0.2em]
\textit{sustained transfer rate} opravdova rychlost cteni z ploten \\[0.2em]

\noindent \textbf{linux:} \\[0.5em]
\textit{hdparm [-t]} umoznuje zmerit prenosovou rychlost a menit parametry disku, -T meri rychost prenosu z vyrovnavaci pameti OS (RAM)

\newpage

\subsection{Solid State Drive - SSD}
Mohou byt zalozena na ruznych technologiich, nejcasteji na nevolatilnich pametech NAND flash nebo DRAM (se zalohovanym napajenim) ci na kombinacich.

\subsubsection{Klady a zapory SSD}

\noindent \textbf{Vyhody:}
\begin{itemize}
    \item rychly (okamzity) nabeh,
    \item nahodny pristup (mikrosekundy),
    \item vetsi prenosove rychlosti (stovky MB/s, ATA do 600MB/s, 3.5GB/s s M.2, 7GB/s s PCI Express 4),
    \item zapis muze byt mirne pomalejsi,
    \item tichy provoz, lepsi mechanicka a magneticka odolnost,
    \item obykle nizsi spotreba (neplati pro DRAM). \\
\end{itemize}

\noindent \textbf{Nevyhody:}
\begin{itemize}
    \item vyssi cena za jednotku prostoru,
    \item omezeny pocet prepisu (nevyznamne pro bezny provoz),
    \item vetsi riziko katastrofickeho selhani, 
    \item mensi vydrz mimo provoz (pri vyplem napajeni a skladovani),
    \item komplikace se zabezpecenim (bezpecne mazani nebo sifrovani prepisem dat - vyzaduje specialni pdporu). \\
\end{itemize}

\subsubsection{Problematika zapisu u SSD}
NAND flash SSD jsou organizovany do stranek (typicky 4KiB) a ty jsou sdruzeny do bloku (typicky 128 stranek = 512 KiB). \\

\noindent\textbf{Zapis nebo prepis dat:}
\begin{itemize}
    \item prazdne stranky lze zapisovat jednotlive (prepisovat ne!),
    \item pokud chci prepisovat (jednu stranku), je nutne cely blok nacist do pameti, vymazat (zresetovat) a v pameti upraveny blok nacist zpet (= write emplification, zesileni zapisu - mnohonasobne zpomaleni),
    \item problem je mensi pri sekvencnim (pockam az budu mit dost dat tak aby pokryly blok) nez pri nahodnem zapisu do souboru. \\
\end{itemize}

\noindent\textbf{Problem se sifrovanim a bezpecnym mazanim:}
\begin{itemize}
    \item diky tomu jak SSD prepisuji data se data nekolikrat presouvaji po disku,
    \item proto disk musi poskytovat hw podporu pro bezpecne mazani nebo sifrovani. \\
\end{itemize}

\noindent\textbf{Reseni problemu prepisu u SSD:}
\begin{itemize}
    \item typicky ma SSD vice stranek-bloku nez je deklarovana kapacita (pri prepsani se zapise do volne stranky),
    \item po smazani dostatku stranek (tak ze tvori blok) se blok zresetuje - prikazem TRIM souborovy system sdeli SSD, ktere stranky jiz nejsou pouzivane (a ktere bloky muze SSD smazat),
    \item radic SSD muze stranky presouvat tak, aby si nektere bloky uvolnil (pokud je v bloku malo stranek, presunou se a blok se zresetuje),
    \item TRIM nelze pouzit vzdy (typicky pokud v souborovem systemu mame obraz jineho souboroveho systemu, nemusi byt mozne sdelit zakladnimu filesystemu informace o praznych blocich, apod. nebo databaze, ktere si ukladaji data do velkeho predalokovaneho prostoru, ci obrazy virtulanich stroji a virtualni disky) \\
\end{itemize}

\noindent Radic SSD presouva i dlouho nezmenene stranky, aby minimalizoval pocet prepisu stranek. \\

\noindent\textbf{definice:} \\[0.5em]
\textit{nevolatilni} zn., ze pokud se vypne napajeni, tak obsah zustane zachovan (alespon po nejakou rozumnou dobu) \\[0.2em]
\textit{stranka} je nejmensi jednotka dat, kterou lze do SSD zapsat \\

\subsection{Zabezpeceni disku}
Diskova elektronika typicky na ukladana data (sama o sobe) zabezpecuje kody, ktere umi pri naslednem cteni detekovat a pripadne opravit chyby - pouziva ECC. (detekce a oprava chyb je pouze v rezii disku, pokud disk detekuje chybu a neni prilis velka, chybu opravi a data ulozi na jiny sektor, poznaci si, ze ten sektor nema pouzivat) \\

\noindent Existuje technologie, ktere umoznuji zjistit, v jakem stavu disk je (statistiky, premapovani, pocet chybnych sektoru, ..) - S.M.A.R.T (podporovana vsemi "rozumnymi" disky) \\

\noindent Pak je mozne jeste provadet testovani na urovni OS, napr. e2fsck nebo badblocks nebo si nektere filesystemy (RFS, ZFS) provadeji kontinualni kontroly toho, co se ve filesystemu deje. Tyto utility nebo filesystemy mohou chyby detekovat (a varovat) nebo opravit (pokud neni chyba prilis velka) ci vyradit pouziti nekterych sektoru. \\


\noindent\textbf{definice:} \\[0.5em]
\textit{ECC} = Error Correction Code \\[0.2em]
\textit{S.M.A.R.T} = Self Monitoring Analysis and Reporting Technology \\[0.2em]
\textit{kontinualni kontroly (fs)} zn., ze si ukladaji sve dalsi kontrolni soucty, a pote si kontroluji pri praci se souborem, zda kontroly souhlasi \\

\noindent\textbf{linux:} \\[0.5em]
\textit{smartctl} je prikaz umoznujici vyuziti technologie S.M.A.R.T (testy disku, statistiky, ..) \\[0.2em]
\textit{smartd} je nadstavbou smartctl (pravidelne spousteni testu, ..)

\newpage

\subsection{Diskova pole (RAID)} \label{RAIDs}
RAID je technologie umoznujici z vetsiho poctu (levnejsich a ne prilis spolehlivych, vykonnych) disku vytvorit jeden disk, ktery je rychlejsi a spolehlivejsi. \\

\noindent\textbf{Muze byt implementovan:}
\begin{itemize}
    \item hardwarove (do rozsirujici karty pripojime nekolik disku a ta implementuje RAID),
    \item subsystemem v jadre,
    \item nektere souborove systemy maji implementaci RAID v sobe.  \\
\end{itemize}

\noindent Ruznych typu RAID je nekolik (tzv. raid levels). \\

\subsubsection{RAID 0}
\begin{itemize}
    \item data jsou rozlozena po dvou ci vice discich, ale kazdy datovy blok je ulozen jen na jednom disku (napr. dva disky, 0 a 1, prvni datovy blok [sektor, skupina sektoru] je na 0, druhy na 1, treti na 0, ...)
    \item vyssi efektivita cteni ci zapisu,
    \item je mozne paralelne cist ci zapisovat (do vice disku)
    \item prudce snizuje spolehlivost - pokud selze jeden disk, prijdu o data na nem \\
\end{itemize}

\subsubsection{RAID 1}
\begin{itemize}
    \item disk mirroring, pro 2 a vice disku,
    \item vsechny bloky dat se zapisuji na vsechny disky,
    \item moznost cist a zapisovat paralelne,
    \item vyssi spolehlivost (data jsou na vsech discich) \\
\end{itemize}

\subsubsection{RAID 2}
\begin{itemize}
    \item nejslozitejsi, proto se prilis nepouziva,
    \item pouziva zabezpecovaci Hemingovy kody,
    \item k urcitemu poctu datovych disku je urcity pocet zabezpecovacich disku,
    \item data se ukladaji na datovych discich na urovni bytu, k nim se dopocitavaji zabezpecovaci kody (napr. 4 datove - 3 zabezpecovaci),
    \item byty dat se rozlozi do vsech disku (ofc ty se musi prevest do bajtu a sektoru a zapisuje se to po sektorech)
    \item jediny RAID, ktery umi detekovat chyby, nektere i sam opravit, dokonce umi i zjistit, ktery disk selhal \\
\end{itemize}

\newpage

\subsubsection{RAID 3}
\begin{itemize}
    \item jednodussi zabezpeceni nez RAID 2, v podobe paritnich bytu,
    \item rozklada data po bajtech ci skupinach bajtu, ktere zabezpecuje partinim zabezpecenim (napr. 4 disky - 3 datove a 1 paritni). \\
\end{itemize}

\subsubsection{RAID 4}
\begin{itemize}
    \item je analogie (tak jako RAID 3, akorat ..),
    \item provadi se rozkladani na urovni bloku-sektoru,
    \item nevyhoda u RAID 3 i 4 je pretizeni paritniho disku - pri zapisu/cteni se vzdy pracuje s paritnim diskem (a datovym) - na paritni disk se zapisuje tolikrat casteji, kolik mam datovych disku, tzn. vetsi pravdepodobnost selhani \\
\end{itemize}

\subsubsection{RAID 5}
\begin{itemize}
    \item prakticky se uz pouziva,
    \item funkce paritniho disku neni vyhrazena pro jeden disk, ale mezi disky tzv. rotuje,
    \item napr. v konfiguraci se 4 disky, prvni 3 datove bloky se ulozi na 3 disky, na poslednim bude parita, pro dalsi trojici se ulozi na 3. disk, pro dalsi na 2., dalsi na 1., a potom zase na posledni, apod. .. = rovnomerne zatizeni disku,
    \item diky parite jsme schopni opet detekovat a korigovat chybu v jednom disku (pocet bitu neni sudy - chybi tam parity bit),
    \item parita se pocita dle sektoru (prvni bit 1. sektoru, prvni 2. sektoru, ..),
    \item pokud selze vice disku, nelze dopocitat bity (data) \\
\end{itemize}

\subsubsection{RAID 6}
\begin{itemize}
    \item parita se uklada 2x,
    \item dokaze se vyrovnat se selhanim az 2 disku,
    \item vetsi redudance dat (obetuji se 2 disky jako parita) \\
\end{itemize}

\noindent RAID je mozne vytvorit i na jednom fyzickem disku (na kterem jsou logicke disky).

\newpage

\subsection{Opravy chyb u paritnich disku}
\begin{itemize}
    \item paritni disky pouzivane u RAID 3 - 6,
    \item jakmile clovek urci disk, ktery selhal, je mozne zreprodukovat jeho obsah,
    \item priklad: 4 disky, 1 paritni, treti datovy selze
    \begin{itemize}
        \item prvni byty v datovych jsou 010 (potom v paritnim aby byl sudy pocet je 1), dalsi byty jsou 111 (licha parita, do paritniho disku se doplni 1 na sudou), dalsi jsou 011 (suda - v paritnim je 0)
        \item selze treti disk, vymeni se za novy, prazdny
        \item dopocitaji se data opet na sudou paritu: mam prvni byty 01? a v paritnim 1 - aby byla suda, v novem disku musi byt 0, dalsi byty 11? a v paritnim 1 - v novem musi byt 1, apod. ... \\
    \end{itemize}
\end{itemize}

\noindent\textbf{definice: (pro \ref{RAIDs}.x)} \\[0.5em]
\textit{RAID} = Redundant Array of Independent Disks \\[0.2em]
\textit{parita (bitu)} je sudost/lichost bitu, pocet sudych/lichych 1 bitu \\[0.2em]
\textit{parity bit} zn., ze na MSB se prida 1 pokud pocet 1 (bitu) je lichy \\

\subsection{Ulozeni dat na disku}
Diskova jednotka neumozni pracovat s nicim mensim nez sektor, ale typicky OS si sektory nejak seskupi (do vetsi jednotky) a neumozni pracovat s nicim mensim, nez je alokacni blok. \\

\noindent\textbf{Logicka a fyzicka naslednost:}
\begin{itemize}
    \item 1 alokacni blok se namapuje fyzicky za sebou na diskovem prostoru,
    \item vice alokacnich bloku jiz nemusi byt fyzicky na disku za sebou (filesystem se vsak snazi o to, aby tomu tak bylo) \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{alokacni blok} neboli cluster je skupina pevneho poctu sektoru, typicky mocnina 2 (nejmene $2^0$ = 1 alokacni blok), pro sektory v ramci alokacniho bloku je zaruceno, ze jdou za sebou logicky i fyzicky (na disku) v souboru, dale je to nejmensi jednotkou diskovou diskoveho prostoru, se kterym bezne pracuje jadro (filesystem, uzivatel). \\

\newpage

\subsection{Fragmentace}

\subsubsection{Externi fragmentace}

Rozumime jev, ktery vznika v pametech postupnym obsazovanim a uvolnovanim pameti, kdy v pameti vznika sekvence oblasti, ktere jsou volne a pouzite (a pouzite ruznymi soubory). \\

\noindent\textbf{Priklad externi fragmentace:}
\begin{itemize}
    \item na disku vytvorim soubor 1, zabira urcite misto,
    \item pote dalsi soubor 2,
    \item pote soubor 1 chci zvetsit, tak se soubor 1 rozdeli na 2 casti - soubor 1.1 (puvodni misto kde byl - pred s2) a soubor 1.2, ktery bude za souborem 2,
    \item stejnym zpusobem zvetsim soubor 2 a vznikne sekvence s1.1, s2.1, s1.2, s2.2,
    \item nyni se rozhodnu smazat prvni soubor a budu mit sekvenci volne misto, s2.1, volne misto, s2.2 == externi fragmentace. \\
\end{itemize}

\noindent Externi fragmentace je i na plne obsazenem disku, kde staci, aby byl disk obsazen soubory nespojite (tzn. jeden soubor je rozdelen do vice casti, neni ulozeny na jednom miste, napr. s1.1, s2, s1.2 nebo viz priklad hore). \\

\noindent\textbf{Negativni dopady externi fragmentace:}
\begin{itemize}
    \item na disku za urcitych okolnosti (v beznych FS nevznikaji) mohou vzniknout casti prostoru, ktere jsou jiz dale nevyuzitelne, protoze jsou prilis male (tldr vznik volnych useku, ktere nejdou vyuzit)
    \begin{itemize}
        \item okolnosti (pri kterych vzniknou nevyuzitelne casti prostoru): pri alokovani diskoveho prostoru spojite (na miru souboru ci jeho castem, nepridelovani po jednotkach pevne velikosti) a navic budu mit dolni mez urcujici velikost diskoveho prostoru tak, aby byl pouzitelny (muze vzniknout v souvislosti s tim, ze do pouzitych diskovych oblasti si mohu ukladat pomocne informace, k cemu se pouzivaji - pokud bude informace vetsi nez "volna dira" - nepouzitelna) - mam na disku bloky volneho mista o pozadovane velikosti (1GB, soubor, 0.5GB), ale protoze chci ukladat spojite (soubor o velikosti 1.5GB), nelze takove misto vyuzit
        \item vznikne nespojite rozlozeny soubor (viz priklad) a je nutne si pamatovat v pomocnych datech = metadatech informace o tom, kde jednotlive casti souboru jsou (ukladaji se na mista, kde jednotlive casti jsou, "odkazuji" se na dalsi metadata - dalsi casti smazaneho souboru),
    \end{itemize}
    \item cim vice casti souboru - tim vice metadat - cim vice fragmentovane - tim vice je pristup na data pomalejsi (u HDD se ceka navic na natoceni hlavicek a rotace disku) \\
\end{itemize}

\noindent\textbf{Souborove systemy se snazi negativni dopady fragmentace minimalizovat:}
\begin{itemize}
    \item rozlozeni souboru po disku (snaza ukladat soubory na disk tak, aby nebyly nutne za sebou, ale bylo mezi nimi volny prostor),
    \item pouzivani predalokace (uzivatel si pozada filesystem o vymezeni urciteho prostoru na disku, napr. databaze),
    \item odlozena alokace (=allocate-on-flush, filesystem nezapise ihned po zmene souboru, ale chvili pocka - pocita s tim, ze uzivatel bude chtit menit soubor "za chvili" znovu - az nebude delsi dobu dochazet ke zmenam, pote hleda vhodny volny prostor) \\
\end{itemize}

\noindent Pri (intenzivnim) beznem pouzivani disku se vsak fragmentaci nelze vyhnout. Pokud by byla fragmentace prilis vyrazna, je mozne pouzit defragmentacni nastroje, ktere provadeji kopirovani, presouvani casti souboru a reorganizaci diskoveho prostoru tak, aby se fragmentace odstranila - casove narocna operace. \\

\noindent Prvniho negativniho dopadu externi fragmentace (nevyuzitelne a prilis male oblasti) je mozne se zbavit pri pouzivani alokaci po jednotkach pevne velikosti - alokacni bloky - vzdy je ale snaha alokovat spojite (v horsim pripade alokuji nespojite, pokud to nejde) \\

\subsubsection{Interni fragmentace}
Nespojita alokace po jednotkach pevne velikosti (alokacni bloky) ma vyhodu, ze redukuje dopady externi fragmentace, ale potom vytvari interni fragmentace. Interni fragmentace se obvykle toleruje.  \\

\noindent\textbf{Priklad interni fragmetace:}
\begin{itemize}
    \item chci alokovat soubor o velikosti 9 000 B,
    \item mam 4 KiB velke alokacni bloky,
    \item potom je nutne alokovat 12 KiB pro tento soubor,
    \item ty zbyvajici 3 KiB v poslednim alokacnim bloku zustanou nevyuzite. \\
\end{itemize}

\noindent Existuje nekolik malo filesystemu, ktere se snazi resit interni fragmentaci (ReiserFS, ZFS) pomoci techniky zvane 'tail packing' ("zbavovani ocasku" souboru) - vice souboru muze pouzivat 1 fyzicky alokacni blok (zaplni se volne misto). Vetsine filesystemu toto vsak nepodporuje. \\

\newpage

\subsection{Pristup na disk} \label{pristup-na-disk-detailed}
(viz \ref{pristup-na-disk}) Proces kdyz chce nacitat/zpracovavat data, zavola sluzbu k tomu urcenou (read, write, .. - muze byt zabaleno i v nejakem knihovnim volani, napr. scanf zavola read), dojde k predani rizeni jadru, dostane se ke slovu jadro, podiva se do cache, pokud tam ta data ma, preda je, pokud ne, musi je nacist z disku - s diskem komunikuje pres I/O porty nebo pametove mapovane I/O porty, disku se predavaji prikazy pres jeho rozhrani (ATA disk - ATA prikazy), jdou z filesystemu pres ovladac prislusneho disku (pote to prochazi sbernicemi), ten komunikuje s radicem disku - disk dostane prikaz, jakmile dobehne operace, disk posle preruseni na procesor, tam se dostava ke slovu jadro, to zpracuje preruseni a zachova se podle nej (uspech - preda data, chyba - zpracuje ji). \\

\noindent\textbf{definice:} \\[0.5em] \label{ovladac}
\textit{ovladac} je software, ktery umi komunikovat s urcitym typem zarizeni, jina definice viz. \ref{ovladace}

\subsection{Planovani pristupu na disk}
Soucasti jadra je subsystem nazyvany planovac diskovych operaci, ktery shromazduje pozadavky od filesystemu (nacteni, zapsani dat z/do disku). Planovac si uklada pozadavky do svych planovacich front, pozadavky pripadne preusporadava a predava dal ovladaci ci radici disku k realizaci. \\

\noindent Planovac se snazi minimalizovat rezii disku. \\

\noindent Jednou ze strategii preusporadavani pozadavku (u HDD) je pouziti \textbf{vytahoveho alogritmu (elevator, SCAN alghorithm):}
\begin{itemize}
    \item snaha, aby se hlavicka disku plynule pohybovala od stredu k okraji a zpet a vyrizovat pozadavky dle pohybu hlavicky,
    \item modifikace SCAN algoritmu je napriklad Circual SCAN, kdy se pozadavky vyrizuji pouze pri jednom smeru,
    \item dalsi modifikace jsou LOOK a C-LOOK, kde se hlavicka nepohybuje od stredu k okraji, ale pouze v tom rozsahu, kde je potreba provadet operace. \\
\end{itemize}

\noindent\textbf{Planovac se muze snazit vice operaci sloucit do jedne operace} (napr. operace v ramci jednoho bloku se sdruzi):
\begin{itemize}
    \item takove kroky maji vyznam i u SSD,
    \item snaha vyvazovat pozadavky jdouci od jednotlivych uzivatelu (procesu),
    \item implementace priorit (prioritnejsi proces - pozadavky se vykonaji drive),
    \item snaha odkladat operace tak (v nadeji), ze je bude pote mozne sloucit,
    \item snaha implementovat casova omezeni na dobu cekani pozadavku,
    \item muze implementovat paralelizaci pozadavku predavanych do diskoveho subsystemu (modernejsi a velmi vykonne SSD umi resit operace  paralelne). \\
\end{itemize}

\noindent\textbf{linux:} \\ [0.5em]
pro zjisteni, jaky planovac pouzivame se staci podivat do \textit{/sys/block/$<$devname$>$/queue/scheduler} \\

\subsection{Logicky disk} \label{5.11}
V pocitaci je mozne mit vicero fyzickych disku, ktere je dale mozne rozdelit na logicke disky a konkretni souborove systemy je mozne instalovat na logicke disky. Pro spravu a vytvareni logickych disku lze pouzit programy cfdisk, disk, gparted, .. \\

\subsubsection{Zpusob ulozeni informaci o diskovych oblastech na disku}
\begin{itemize}
    \item MBR
    \begin{itemize}
        \item v prvnim (nultem) sektoru byla tabulka obsahujici rozdeleni na 1-4 primarni partitions
        \item pokud bylo nutne pouzit vice partitions, potom misto primarni se nahradila rozsirenou diskovou oblasti, ktera se dale mohla rozdelit na podoblasti zvane logicke diskove oblasti, kazda z nich popsana formou zretezeneho seznamu, EBR
        \item pouzivane u starsich PC
    \end{itemize}
    \item GPT
    \begin{itemize}
        \item je tabulka (pole) o az 128 odkazech na jednotlive diskove oblasti,
        \item stejny vyhrazeny prostor jako u MBR \\
    \end{itemize}
\end{itemize}

\subsubsection{LVM}
\begin{itemize}
    \item spravce logickych oblasti,
    \item umoznuje pokrocilejsi tvorbu logickych disku a
    \item do logickeho disku pridavat fyzicke disky (za behu),
    \item LVM muze byt bud primo ve filesystemu nebo v casti jadra (mezi filesystemem a planovacem). \\
\end{itemize}

\subsubsection{Ruzne typy souborovych systemu}
\begin{itemize}
    \item fs (prvni fs na unixu), ufs, ufs2,
    \item ext2, ext3, ext4,
    \item btrfs (inspirovan ZFS),
    \item ReiserFS, HSF+/APFS (Mac OS X), XFS, JFS, HPFS,
    \item FAT, VFAT, FAT32, exFAT (rodina FAT vznikla v MSDOS, pote pouzivany ve Windows - velmi jednoduche a siroce podporovane),
    \item F2FS (fs pro efektivni prace se SSD), ISO9660, UDF, Lustre, GPFS (clustery, superpocitace),
    \item ZoneFS (ZFS). \\
\end{itemize}

\noindent Po koupe noveho disku a rozdeleni na logicke disky je nutne se rozhodnout, jaky souborovy system na prislusnem logickem disku bude pouzivan - je nutne disk \textbf{zformatovat} pro pouziti. Drive se pouzivalo i nizkourovnove formatovani (stare disky s nestabilnim magnetickym zaznamem). \\

\newpage

\subsubsection{Chyby disku (souvislost s FS)}

\noindent Na disku mohou vznikat chyby beznym opotrebenim, nevhodnym vypnutim napajeni, je zapotrebi opravit ridici struktury souboroveho systemu (program fsck - kontroluje konzistenci filesystemu nebo zurnalovani, copy on write, soft updates, ..). \\

\subsubsection{Dalsi typy souborovych systemu}

\noindent\textbf{Virtualni souborovy system (VFS)} je vrstva, ktera v jadre zastresuje vsechny ostatni souborove systemy z toho duvodu, aby jine subsystemy jadra nemusely pracovat specialnim zpusobem s ruznymi souborovymi systemy.  \\

\noindent Existuji take ruzne sitove souborove systemy, treba NFS. \\

\noindent\textbf{Specialni souborove systemy}
\begin{itemize}
    \item neukladaji zadna data, obsah neni nikde na disku ani neexistuje zadna specialni cast pameti
    \item zpristupnuji napr. aktualni stav jadra - adresar /sys, sysfs filesystem,
    \item procfs filesystem v adresari /proc zpristupnuje informace o bezicich procesech (ale i o nejakych castech stavu jadra),
    \item tmpfs zase vytvari souborovy system v RAM. \\
\end{itemize}

\noindent\textbf{definice: (pro \ref{5.11}.x)} \\[0.5em]
\textit{logicky disk} je taky diskova oblast, partition \\[0.2em]
\textit{MBR} = master boot record \\[0.2em]
\textit{EBR} = extended boot record \\[0.2em]
\textit{GPT} = GUID Partition Table, GUID = Globally Unique Identifier \\[0.2em]
\textit{LVM} = Logical Volume Manager \\[0.2em]
\textit{formatovani} zn., ze se nainstaluji metadata (ridici data) souboroveho systemu do prislusne diskove oblasti, v ramci toho se mohou vymazat vsechna data na dane oblasti \\[0.2em]

\newpage
\setlength{\parindent}{0pt}

\section{}
\textbf{Sesta prednaska:} pokracovani Spravy souboru. Zurnalovani, jeho implementace a alternativy, Copy-on-write, Klasicky UNIXovy system souboru FS, i-uzly, kde a jak jsou data ulozena, pocty odkazu, limit maximalni velikosti souboru, vyhody a nevyhody FS, jine zpusoby organizace souboru, EXT4, NTFS, Organizace volneho prostoru na disku, deduplikace, typy souboru v UNIXu, adresar, montovani disku
\subsection{Zurnalovani}
Je technika zalozena na vytvareni zurnalu.  \\

\begin{itemize}
    \item souborove systemy se zurnalem jsou treba ext3, ext4, ufs, XFS, JFS, NTFS, ..
    \item zurnalovani umoznuje spolehlivejsi (nikdy nemame obecne zajisteno, ze se nic spatneho stat nemuze) a     \item rychlejsi navrat (nez nejake utility) do konzistentniho stavu po chybach
    \item data obvykle zurnalovana nejsou (velka rezie), ale mohou byt
    \item zavisi na tom, ze operace, ktere zurnalovani implementuji, se provedou ve spravnem poradi -- nutnost spoluprace s planovacem, take disky si samy data preusporadavaji (nelze nijak ovlivnit) \\
\end{itemize}

\noindent\textbf{Zurnal:}
\begin{itemize}
    \item zapis zurnalu je p\v{r}ed\v{r}azen\'{y},
    \item vytvari se v nem cyklicky prepisovany buffer,
    \item p\v{r}ed\v{r}azenost zapisu do zurnalu mi zaruci, ze operace pokryte zurnalovanim jsou atomicke - vytvari transakce \\
\end{itemize}

Kompromis mezi zurnalovanim a nezurnalovanim dat je \textbf{p\v{r}ed\v{r}azen\'{i} zapisu dat na disk pred zapisem metadat do zurnalu} (a nasledne zapis ostrych metadat na disk). Priklad:
\begin{itemize}
    \item zapisuji do souboru - bud vytvarim zcela novy nebo ho zvetsuji (typicke zpusoby zapisu),
    \item pri zvetsovani se nejprve zapisou data na disk za existujici data (bez poznamenavani informace o tom, ze se soubor zvetsuje),
    \item pokud operace selze, soubor zustane v puvodnim stavu (diky neupravenym metadatum puvodniho souboru),
    \item teprve az data budou na disku, tak se do zurnalu zapise informace o zvetsovani souboru,
    \item pote se zmeni metadata souboru (a uzivatel se k datum dostane),
    \item pri selhani napajeni v moment, kdy jsou metadata v zurnalu, ale ne na disku, je mozne tyto metadata obnovit \\
\end{itemize}

\textbf{Proces mazani souboru na disku:}
\begin{itemize}
    \item odstraneni zaznamu z adresare,
    \item uvolneni uzlu (metadat souboru),
    \item uvolneni oblasti pouzitych tim souborem \\
\end{itemize}

\noindent\textbf{definice:} \\[0.5em]
\textit{zurnal} je specialni soubor ci specialni oblast na disku slouzici pro zaznamy modifikovanych metadat (dat o datech), pripadne i dat pred jejich zapisem na disk (v podobe beznych dat) \\[0.2em]
\textit{p\v{r}ed\v{r}azen\'{y}} znamena, ze zapis do zurnalu se provede pred ostrym zapisem "uzitecnych" dat (ci metadat) na disk \\[0.2em]
\textit{atomicke operace} zn., ze but operace uspeje cela (vsechny dilci kroky) nebo neuspeje vubec (zadny dilci krok) \\

\subsubsection{Implementace zurnalovani}
Existuji 2 zakladni pristupy k implementaci zurnalovani. \\
\textbf{REDO:}
\begin{itemize}
    \item implementace na zaklade dokonceni transakci,
    \item pouziva napr. ext3, ext4,
    \item sekvence dilcich operaci (vytvarejici tu operaci, kterou chci provest) se zapise do zurnalu (zacatek, konec transakce, kontrolni soucet),
    \item pote se operace provadi na disku,
    \item po uspesnem dokonceni se transakce ze zurnalu uvolni,
    \item pri selhani a pote zotaveni se system podiva do zurnalu, podiva se po neuvolnenych transakcich, jestli jsou cele - pocatecni a koncova znacka, jestli sedi kontrolni soucet - pokud vse sedi, tak system provede vsechny operace znovu \\

\end{itemize}
\textbf{UNDO:}
\begin{itemize}
    \item implementace na zaklade anulace transakci,
    \item v kombinaci s REDO se pouziva v NTFS,
    \item proklada zaznam dilcich operaci (ktere se maji provest) do zurnalu a nasledne jejich provedeni na ostrych datech (zaznamena dilci operaci - provede ji),
    \item probehne cela transakce - zaznam ze zurnalu se uvolni,
    \item pri chybe se eliminuji vsechny nedokoncene transakce (vsechny provedene dilci kroky se musi vratit - vrati se disk do puvodniho stavu) \\
\end{itemize}

Pri implementaci zurnalovani je klicove \textbf{dodrzeni poradi kroku, ve kterem se provadeji}. (U REDO napr. je nutne, aby se nejprve zapsaly sekvence operaci do zurnalu a teprve pote se provadely operace na disku) Pokud tato sekvence nebude dodrzena, zurnal nebude spravne fungovat. \\

\newpage

\subsubsection{Copy-on-write}
Je alternativa k zurnalovani pouzivana napriklad v ZFS (OpenZFS), BTRFS, ReFS (Resilient File System).
\begin{itemize}
    \item kopie pri zapisu,
    \item zalozeno na tom, ze vsechna nova data / metadata se zapisi na disk, a pote se zpristupni,
    \item vyuziva se pritom toho, ze obsah disku je popsam hierarchickou stromovou strukturou,
    \item zmeny se provadeji v souladu s touto strukturou (od listu ke koreni),
    \item pokud vypadne napajeni v moment, kdy data (bloky) nejsou jeste zpristupnena, data nejsou dostupne z korene stromu a jakoby se nic nestalo,
    \item pokud se mi tyto data podari zapsat uspesne, postupne zacnu upravovat vsechny uzly vedouci az ke koreni a zpristupnim nova data,
    \item teprve po modifikaci korenu se stanou zmenena data (uzly) dostupne
    \begin{itemize}
        \item koren je nutne zabezpecit, aby nedoslo k chybe pri zapisu do nej
        \item stary korenovy uzel se neprepisuje, ale pouze se tam zapise nova verze korenoveho zaznamu (s casovym razitkem)
        \item soucasne tam bude zabezpecovaci kod (kontrolni soucet),
        \item pokud dojde ke krachu systemu, staci si nacist vsechny koreny, zkontrolovat kontrolni soucty, vybrat si vsechny, kde sedi kontrolni soucty, s nejnovejsim casovym razitkem a tyto pouziju (pokud dojde k chybe nez se stihne zapsat novy koren, pouzije se ten puvodni) \\
    \end{itemize}
\end{itemize}

\textbf{Vyhodami copy-on-write jsou:}
\begin{itemize}
    \item snimky souboroveho systemu (zapamatuje se pouze korenovy uzel - minimalni rezie),
    \item klony souboroveho systemu (vytvori se pozadovany pocet kopii korenoveho uzlu),
    \item vyhodou je, ze nezmenene uzly (data) a listy budou na disku pouze jednou, pouze je nutne si pamatovat zmenene uzly / listy a cestu ke koreni + koren (kopie stale ukazuji na stejny strom). \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{stromova struktura} (copy-on-write) je vyhledavaci strom, ktery popisuje veskery obsah disku, typicky se v nem vyhledava na zaklade unikatni identifikace souboru \\[0.2em]
\textit{adresare} (copy-on-write) jsou specialni soubory ulozeny na disku, ktere jsou dostupne ve strome (stromove strukture) \\[0.2em]
\textit{snimek souboroveho systemu} ulozi se obsah disku tak, ze je mozne se k nemu pozdeji vratit \\[0.2em]
\textit{klon souboroveho systemu} je vytvoreni 2 kopii souboroveho systemu a od daneho okamziku je mozne s kazdou kopii pracovat samostatne (napr. pri vetsim poctu VM, kdy vsechny VM sdili stejny pocatecni obsah disku, ale od urciteho momentu kazda VM chce obsah menit samostatne) \\

\newpage

\subsubsection{Dalsi alternativy zurnalovani}
\textbf{Soft updates:}
\begin{itemize}
    \item pouziva se v UFS (FreeBSD systemy),
    \item filesystem se snazi sledovat zavislosti mezi tim jaka data a metadata se meni,
    \item uzpusobuje poradi zapisu metadat a dat na disk tak, aby v jakemkoli okamziku byl obsah na disku konzistentni (az na moznost vzniku "garbage") \\
\end{itemize}

\textbf{Log-structured file systems:}
\begin{itemize}
    \item logovaci souborove systemy (= strukturovane jako log),
    \item pouziva se v LFS, UDF, F2FS,
    \item cely souborovy system ma charakter jednoho velkeho logu,
    \item ktery se zapisuje v cyklicky prepisovane pameti napric celym diskem,
    \item posledni obsah disku je vzdy dostupny pres posledni zaznam (a odkazy, ktere z nej vedou),
    \item pri provadeni zmen se pridaji data napr. za aktualni konec vyuziteho diskoveho prostoru, prida se k tomu zaznam (o tom co se zmenilo), zpristupni se data z posledniho zaznamu. \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{"garbage"} je cast prostoru na disku, ktera se tvari jako obsazena, ale neni \\[0.2em]
\textit{logem} rozumime soubor, ktery obsahuje zaznamy o zmenach (nebo: log = zapis o zmenach) \\

\newpage

\subsection{Klasicky UNIXovy system souboru (FS)}
Je puvodni filesystem unixu (70. leta). Vyvinul se z nej UFS, z nej zase EXT2, 3 (pote vznikl i EXT4). \\

\textbf{Souborovy system byl rozclenen (na urovni logickych disku) na:}
\begin{itemize}
    \item boot blok - obsahoval informace (kod, cast kodu) potrebne pro zavedeni pri startu,
    \item super blok - informace o souborovem systemu (typ, verze, velikost, pocet i-uzlu, volne misto, korenovy adresar, volne i-uzly, ..),
    \item tabulka i-uzlu - tabulka (pole n i-uzlu) pouzita s popisy souboru,
    \item datove bloky - data souboru, metadata (pomocne adresovaci bloky). \\
\end{itemize}

\textbf{Zakladni rozlozeni FS bylo zmodifikovano v navazujicich filesystemech:}
\begin{itemize}
    \item datove bloky byly rozdeleny do skupin, 
    \item kazda skupina mela svoje i-uzly,
    \item duvodem byla lepsi lokalita, prostorova blizkost dat a metadat (typicky pri praci se soubory jsou nutne i jeho metadata),
    \item pote tedy ta struktura vypadala takto: boot blok, super blok, usek i-uzlu, usek dat, usek i-uzlu, usek dat, .. \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{i-uzel} je zakladni datova struktura reprezentujici kazdy jeden soubor v typickych UNIXovych systemech (pozn. pri formatovani se urci dopredu maximalni pocet souboru, ktere na diskovem oddilu budou existovat) \\

\subsubsection{i-uzel}
Zakladni datova struktura popisujici soubor v UNIXu (nebo viz definice hore). Ke kazdemu souboru musi byt i-uzel. Ten obsahuje metadata o souboru: 
\begin{itemize}
    \item stav i-uzlu (alokovany, volny)
    \item typ souboru (obycejny, adresar, zarizeni, pojmenovana roura, ..),
    \item delka souboru v bajtech,
    \item casy mtime (posledni modifikace dat - zapis), atime (posledni pristup - cteni), ctime (posledni modifikace i-uzlu),
    \item UID, GID,
    \item pristupova prava (cislo, napr. 0644 = rw-r--r--),
    \item pocet pevnych odkazu (neboli jmen souboru),
    \item informace o tom, kde se nachazi data o souboru (tabulka odkazu na datove bloky a dalsi informace nebo odkazy na pomocne bloky s dalsimi metadaty, napr. ACL, extended attributes, dtime - udaj o smazani souboru, ..) \\
\end{itemize}

Jmeno souboru neni v i-uzlu, ale je ulozeno v adresari. \\

\textbf{definice:} \\[0.5em]
\textit{UID} je cislo identifikace vlastnika \\[0.2em]
\textit{GIT} je cislo identifikace skupiny \\[0.2em]
\textit{ACL} zn. Access Control List, pristupove seznamy rozsirujici zakladni UNIXova prava tak, ze je mozne priradit konkretni prava ke konkretnim uzivatelum \\[0.2em]
\textit{extended attributes} zn. rozsirene atributy, s jakymi specifickymi prave se muze soubor napr. spoustet \\[0.2em]
\textit{ctime} je posledni zmena i-uzlu, vyuzitelne napr. pokud se zfalsuje mtime, posledni zmena souboru se pozna prave podle ctime \\

\subsubsection{Kde a jak jsou ulozena data}
\begin{itemize}
    \item v i-uzlu je rada primych (az 10, novejsi unixove fs maji 12) i neprimych odkazu na data,
    \item prime odkazy odkazuji na alokacni bloky na disku,
    \item pokud je potreba vice odkazu, pouzije se neprimy odkaz prvni urovne, ktery odkazuje na specialni alokacni blok neobsahujici data, ale dalsi prime odkazy na data,
    \item pokud nestaci ani to, pouzije se neprimy odkaz druhe urovne, ktery odkazuje na pomocny adresovaci blok, ktery obsahuje dalsi neprime odkazy 1. urovne, ktere odkazuji na dalsi prime odkazy (a ty odkazuji na data) - vznika strom
    \item pokud ani to stacit nebude, pouzije se adresovaci blok 3. urovne, vedouci na adresovaci bloky s neprimymi odkazy 2. urovne, kazdy z nich na bloky s odkazy 1. urovne, ty vedou na prime odkazy a ty na data.
\end{itemize}

\begin{figure}[htb]
    \centering
    \scalebox{1.6}{\includegraphics{6.2.2.jpg}}
    \caption{z prezentace IOS: Souborove systemy, slide 23 - odkazy v i-uzlech}
\end{figure}

\newpage

\subsubsection{Pocty odkazu}
\begin{itemize}
    \item neprimy odkaz 1. urovne - pri 4 KiB clusteru je to 1024 odkazu (1 odkaz = 4B) = 1024 datovych bloku,
    \item neprimy odkaz 2. urovne - pri 4 KiB clusteru je to $1024^2$ odkazu = stejny pocet datovych bloku,
    \item neprimy odkaz 3. urovne - pri 4 KiB clusteru je tam $1024^3$ odkazu = stejny pocet datovych bloku \\
\end{itemize}

\subsubsection{Limit maximalni velikosti souboru}

Poctem primych odkazu neprimeho odkazu 3. urovne je dan maximalni pocet bloku, ktere je mozne v tomto souborovem systemu ulozit. Teoreticky limit velikosti souboru je tak:
$$10 * D + N * D + N^2 * D + N^3 * D$$
kde $D$ je velikost bloku v bajtech (bezne 4096B), $M$ je velikost odkazu na blok v bajtech (bezne 4B), $N = D/M$, je pocet odkazu v bloku. \\

Toto omezeni velikosti je pouze jednim z omezenim, ktere velikosti souboru omezuji. \textbf{Dalsi omezeni jsou dana:}
\begin{itemize}
    \item dalsimi datovymi strukturami a typy, ktere pouziva FS (napr. datovy typ delky souboru v bajtech v i-uzlu),  
    \item strukturami VFS (veskera prace s jakymkoli filesystemem musi projit pres VFS),
    \item rozhranim jadra,
    \item architekturou systemu (32b - velikost souboru bude 32b cislo + MSB je pouzit pro indikaci chyby [-1 bit pro data] - soubory maximalne do 2 GiB nebo dnes bezna architektura 64b - 64b velikosti) \\
\end{itemize}

\textbf{Existuje Large File System Support}, kde ve 32b systemu se nahradi vsechny udaje kde se pracuje s velikosti vetsim datovym typem - podpora souboru \textit{vetsich jak 2 GiB}. \\

\textbf{linux:} \\[0.5em]
\textit{du [soubor]} vypise zabrane misto v blocich vc. rezie (metadat) \\[0.2em]
\textit{ls -l [soubor]} vypise velikost souboru v bajtech (pouze uzitecna data) \\[0.2em]
\textit{df} vypise volne misto na discich \\[0.2em]
\textit{ls -i [soubor]} zpristupni cislo i-uzlu souboru \\[0.2em]
\textit{is -e /dev/... n} - vypis i-uzlu n na /dev/... \\[0.2em]
\textit{dumpe2fs} - zakladni informace o souborovem systemu ext2,3,4 \\[0.2em]
\textit{/dev/zero} je soubor typu zarizeni generujici proud 0 \\[0.2em]
\textit{dd if=[source] of=[dest]} je nizkourovnove kopirovani \\

\newpage

\subsubsection{Vyhody a nevyhody architektury FS}
Neboli proc bylo navrzen FS prave tak, jak je. Architektura FS je totiz ovlivnena snahou o minimalizaci jejich rezie s relativne pomalymi disky (HDD, SDD), jedna se zejmena o bezne operace se soubory, jako je pruchod soubourem (otevru - prochazim od zacatku do konce) ci presun (seek), zvetsovani ci zmensovani (vc. mazani) souboru. \\

\textbf{Je nutne vzit do uvahy, z jakych (mikro)operaci se tyto operace sestavaji}. Jsou to operace:
\begin{itemize}
    \item vyhledavani adresy prvniho nebo urciteho bloku souboru,
    \item vyhledavani nasledujicich bloku,
    \item pridani ci odebrani bloku,
    \item alokace ci dealokace volneho souboru (informace o volnych oblastech, minimalizace externi fragmentace) \\
\end{itemize}

FS a jeho naslednici UFS, EXT2, EXT3 (EXT4 uz neni jeho naslednik!) predstavuji kompromis s ohledem prevazne na male soubory. (tyto fs funguji skvele pro male soubory - u vetsich souboru je nutne prochazet ci menit vetsi objem metadat) \\

Jistou optimalizaci pouzivanou i u klasickych filesystemu pro male soubory je ulozeni dat primo do i-uzlu. (pokud se tam data vlezou). \\

\textbf{definice:} \\[0.5em]
\textit{symbolicky odkaz} je soubor odkazujici na jiny soubor (pouziva ulozeni dat primo do i-uzlu) \\[0.2em]
\textit{rychle symlinky} maji data v i-uzlu \\[0.2em]
\textit{pomale symlinky} maji data mimo i-uzel

\newpage

\subsection{Jine zpusoby organizace souboru}
\subsubsection{Kontinualni ulozeni}
\begin{itemize}
    \item neboli spojite ulozeni souboru na disku,
    \item na disku je jeden spojity usek dat reprezentujici soubor,
    \item vyhodami jsou rychle vyhledani adresy 1./urciteho bloku nebo vyhledavani nasledujicich bloku,
    \item nevyhody: soubory nebude mozne jednoduse zvetsovat pokud budou prilis blizko u sebe (bude nutne jej presunout na jine volne a vetsi misto, pokud to pujde ci provest defragmentaci a pote zvetsit soubor)
    \item nepouziva se prilis (kvuli sve nevyhode) \\
\end{itemize}

\subsubsection{Zretezene seznamy alokacnich bloku}
\begin{itemize}
    \item kazdy alokacni blok obsahuje sva (uzitecna) data a na konci obsahuje odkaz na nasledujici alokacni blok,
    \item kvyhodami jsou rychly pristup na zacatek ci pruchod daty,
    \item knevyhodou je presun na nahodne misto v souboru - nutnost precist cely soubor az po dany blok (1 GiB soubor, chci posledni blok - musim precist cely),
    \item kdalsi nevyhodou je rozprostreni metadat po celem disku - pri drobne chybe na disku prijdu o data (tedy i metadata, kde jsou odkazy na nasledujici bloky) a dojde k velke ztrate dat (vsechna data "za" ztracenymi daty jsou nepristupna),
    \item kneni prilis vhodna, nicmene se pouziva v souborovych systemech FAT \\
\end{itemize}

\subsubsection{FAT}
\begin{itemize}
    \item File Allocation Table,
    \item od zretezenych seznamu se lisi tim, ze seznamy popisujici rozlozeni souboru na disku jsou ulozeny v separatni oblasti na disku (tzv. FAT),
    \item kde jsou tato data koncentrovana - rychleji se prohledavaji, lze vytvorit tak vice kopii FAT (prevence okamzite ztraty dat pri chybe),
    \item stale vznikaji problemy s rychlosti pri nahodnem pristupu (stale jde o zretezeny seznam)
    \item tabulka je pole, ktere obsahuje pro kazdy blok na disku 1 polozku, kazda polozka obsahuje odkaz na dalsi blok/polozku,
    \item pouziva se i dodnes (a je to velmi rozsirene), protoze je to jednoduche (napr. vestavene systemy) \\
\end{itemize}

\newpage

\subsubsection{B+ stromy}
\begin{itemize}
    \item jsou datovou strukturou prevzatou z databazovych systemu,
    \item maji dva typy uzlu - vnitrni a listove,
    \item vnitrni uzly jsou koren, jeho naslednici krome listovych, obsahuji odkaz na naslednika a vyhledavaci klic,
    \item listove uzly take obsahuji odkazy a vyhledavaci klice, odkazy vedou na data na disku, posledni odkaz na poslednim listu odkazuje na list na stejne urovni (jsou tak propojeny linearnim seznamem),
    \item pouzivaji se za ucelem popisu rozlozeni dat na disku (obsah souboru, pote vyhledavaci klic bude offset - cislo logickeho bloku v ramci souboru) nebo se pouzivaji pro adresare (klice budou jmena souboru) nebo pro popis celeho obsahu disku (klic je dvojice i-uzel a posuv souboru) \\
\end{itemize}

\textbf{Vyhledavani v B+ stromu:}
\begin{itemize}
    \item pri hledani klice (k) se podivam, zda je klic mensi jak klic k0, pokud ano, pujdu nize, kde je k00, pokud ne, zjistim, jestli je klic mezi k0 a k1, pokud ano, jdu druhym smerem, opakuji po kn,
    \item pokud jsem niz, opakuji to same co vys az nedojdu k listovym uzlum,
    \item zde hledany klic najdu nebo zjistim ze v teto strukture klic neni
    \item pote mam odkaz na datovy blok,
    \item v pripade ze chci cist dal, tak jdu linearne po sobe po nasledujicich listovych uzlech \\
\end{itemize}

\begin{figure}[htb]
    \centering
    \scalebox{2}{\includegraphics{6.3.4.jpg}}
    \caption{z prezentace IOS: Souborove systemy, slide 27 - B+ strom}
\end{figure}

\newpage

\textbf{Prace s B+ stromy:}
\begin{itemize}
    \item jsou zde limity jak moc/malo maji byt uzly zaplneny (strom se udrzuje vyvazeny) - pro uzly s $m$ odkazy mame klice $0, 1$, .. az $m - 2$ klicu (odkazu je o 1 mene nez klicu + cislovani od 0), 
    \item pokud je strom tvoren solo korenem - nejmene muze mit $1$ odkaz, maximalne $m - 1$ odkazu (posledni odkaz je pouzit jako ukoncovac seznamu listu),
    \item pokud to neni solo koren, tak ma nejake nasledniky, minimalne jich ma tak $2$, maximalne $m$,
    \item vnitrni uzel ma tak $\frac{m}{2}$ (zaokr. nahoru) az $m$ odkazu, list $\frac{m}{2} - 1$ (opet $\frac{m}{2}$ zaokr. nahoru) az $m - 1$ odkazu,
    \item vlozeni:
    \begin{itemize}
        \item nejprve projdeme stromem od korene k listum,
        \item najdeme kam chceme vlozit,
        \item podivame se, zda ma list volny odkaz,
        \item pokud ano - pouzijeme ho, pokud ne - list se rozstepi na 2 poloviny a podivam se o uroven vys, zda je mozne namisto 1 listu linkovat 2 listy,
        \item pokud ano - prida se odkaz, pokud ne - nadrazeny uzel se musi rozstepit a postupovat o uroven vys,
        \item ... stepi se strom az pripadne se rozstepi koren a strom bude mit 2 koreny
    \end{itemize}
    \item ruseni:
    \begin{itemize}
        \item se opet od listove urovne, tak, ze se zrusi odkaz v listu,
        \item zkontroluje se, zda je uzel zaplneny v ramci danych limitu,
        \item pokud ano - gut, pokud ne - podivam se na sousedni uzly a pokud se provest prerozdeleni tak, aby byly vsechny uzly naplneny v ramci limitu,
        \item pokud se to nepodari, tak dojde ke slouceni listu,
        \item posunu se o uroven vys, zrusim jeden odkaz, zkontroluji opet limity, zopakuji to same,
        \item ... az se muze stat, ze se zrusi i koren \\
    \end{itemize}
\end{itemize}

B+ stromy a jeho varianty jsou pouzivany pro popis diskoveho prostoru v filesystemech jako
XFS, JFS, ZFS, Btrfs, ReFS, ..
v omezene podobe tzv. stromu extentu v EXT4, podobna struktura je i v NTFS \\

\textbf{definice:} \\[0.5em]
\textit{solo koren} = jediny koren

\newpage

\subsubsection{Extent}
\begin{itemize}
    \item pouziva se ke zrychleni prace s velkymi soubory,
    \item umoznuji zmensit objem metadat (je mozne rict, ze nektere alokacni bloky jsou ulozeny pospolu = vytvari extent), potom budu popisovat rozlozeni souboru po extentech (ne po alokacnich blocich),
    \item prinese lepe vyvazene indexove struktury,
    \item rychlejsi mazani,
    \item jsou pouzity snad ve vsech systemech s B+ stromy,
    \item B+ strom se snadno kombinuje s extenty (neplati pro klacicky Unixovy strom - protoze ve stromu jsou explicitne ulozene vyhledavaci klice, ale Unixovy nema v zadnych strukturach [i-uzel] ulozenou velikost datovych bloku [protoze jsou vsechny stejne a konstantni]) \\
\end{itemize}

Pokud pouzivame B+ stromy, tak rychlemu spojitemu pruchodu pomaha listova uroven, pokud je prolinkovani listu pouzito. Pro male soubory muze predstavovat B+ strom zbytecnou rezii (data se bud ulozi primo v i-uzlu nebo nebo z nej mame prime odkazy na extenty z i-uzlu [do max. 4 extentu]) \\

\textbf{definice:} \\[0.5em]
\textit{extent} je jednotka vystavena na bloky, posloupnost promenneho poctu alokacnich bloku (jdoucich za sebou logicky v souboru i fyzicky na disku) \\

\newpage

\subsection{EXT4}
Pouziva pro popis rozlozeni dat na disku strom extentu. Pro "male soubory" (mysleno soubory, na ktere je mozne se odkazovat az 4 extenty, pak tyto extenty budou odkazovane primo z i-uzlu; tldr soubory s malym poctem extentu) \\

\textbf{definice:} \\[0.5em]
\textit{strom extentu} je v principu B+ strom degradovany na maximalne 5 urovni, bez pouzivani vyvazovani (napr. prerozdelovani uzlu pri mazani) a zretezeni listu \\

\subsection{NTFS}
Zakladni datovou strukturou popisujici disk je MFT - Master File Table (ma pro kazdy soubor alespon 1 radek, na 0. radku popisuje samo sebe, 1. radek pripadne kopie MFT, pripadne metadata, pote obsahy souboru).  \\

\textbf{Obsah souboru muze byt reprezentovan bud:}
\begin{itemize}
    \item pokud jde o kratky soubor, bude ulozen v MFT v jeho radku (vcetne metadat),
    \item soubor je rozdelen na extenty (ty jsou odkazovane primo z radku souboru v MFT, tak ze v radce souboru jsou informace o pocatecnim VCN a LCN a pocet clustero, ktery dany extent obsahuje) - vyhledava se v tom stejne jako v B+ stromu
    \item pokud je extentu potreba vice nez se vleze na jeden radek, alokuji se pomocne radky (z hlavniho radku vedou odkazy na pomocne, z pomocnych vedou odkazy na disk) - prochazeni je opet ve stylu B+ stromu \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{VCN} - virtual cluster number, logicky blok souboru \\[0.2em]
\textit{LCN} - logical cluster number, cislo fyzickeho bloku (souvisi s tim ze je to na logickem disku) \\

\subsection{Organizace volneho prostoru na disku}
V klasickem Unixovem FS a rade jeho nasledovniku (UFS, EXT2, 3), take v NTFS se pouzivaji bitove mapy, kde pro kazdy blok mam 1 bit. V bitove je mozne pote vyhledavat pomoci bitovych mask - zrychli vyhledavani. \\

\textbf{Dalsi mozne zpusoby organizace volneho prostoru:}
\begin{itemize}
    \item pouziji se alokacni seznamy (zretezeni volnych bloku na disku),
    \item zretezeni volnych polozek v tabulce (FAT),
    \item B+ strom (udrzovani informaci o tom, kde je volne misto, adresace velikosti a/nebo offsetem)
    \item volny prostor muze byt take organizovan po extentech. \\
\end{itemize}

\newpage

\subsection{Deduplikace}
\begin{itemize}
    \item podporovana ZFS, NTFS, Btrfs, XFS, (ext4 ne) ..
    \item snazi se odhalit opakovane ukladani stejnych dat na disk a ulozi je pouze jednou a odkazuje se na ne vicenasobne.
    \item systemy s deduplikaci se snazi takova data detekovan (sekvence bitu, bloku, extentu, ..)
    \item zalozeno na kryptografickem hashovani (hledaji se data se stejnym popisem, urci se shoda),
    \item muze byt realizovano pri zapisu nebo dodatecne (zadost uzivatele),
    \item muze usporit diskovy prostor (pri virtualizaci, na mail serverech, repozitare, ..), pametovy prostor i cas (zamezi se opakovanemu cteni i zapisu),
    \item pri mensim objemu duplikace muze naopak zvysit spotrebu CPU casu, spotrebu pametoveho i diskoveho prostoru \\
\end{itemize}

\textbf{Rozdil oproti copy-on-write:}
\begin{itemize}
    \item copy-on-write se muze uchytit (klony, snimky) pouze tehdy, pokud duplikaty vzniknou cinnosti samotneho filesystemu (napr. vytvoreni virtualek),
    \item zatimco deduplikace aktivne vyhledava duplikaty (napr. uzivatel, co stahuje stejne reklamni letaky) \\
\end{itemize}

\subsection{Typy souboru v UNIXu}
\begin{itemize}
    \item - je obycejny soubor,
    \item d adresar,
    \item b blokovy specialni soubor,
    \item c znakovy specialni soubor,
    \item l symbolicky odkaz (symlink),
    \item p pojmenovana roura,
    \item s socket \\
\end{itemize}

\textbf{definice:} \\[0.5em]
\textit{specialni soubor} je typ souboru reprezentujici hardwarove zarizeni (disk, hw, pamet) se kterym se komunikuje po blocich nebo znacich \\[0.2em]
\textit{symbolicky odkaz} je soubor obsahujici jmeno jineho souboru (odkazuje na nej) \\

\newpage

\subsection{Adresar}
Je to kolecke jinych souboru na nejvyssi urovni abstrakce. Soubor obsahuje mnozinu dvojic jmeno a unikatni ciselne oznaceni. \\

\textbf{Jmeno souboru:}
\begin{itemize}
    \item drive limit 14 znaku, dnes az 255 (na konci musi byt '\verb|\0|')
    \item ve jmene nesmi byt / nebo '\verb|\0|' \\
    \item lati ze kazdy adresar v POSIX systemu vzdy obsahuje minimalne 2 jmena: . (odkaz na sebe) a .. (odkaz na rodicovsky adresar)
\end{itemize}

\textbf{Cislo souboru:}
\begin{itemize}
    \item u klasickeho souboru unixu je to cislo i-uzlu,
    \item v jinych pripadech to slouzi jako klic do dane vyhledavaci struktury (B+ strom)
\end{itemize}

\textbf{Implementace adresaru:}
\begin{itemize}
    \item pouzivaji se ruzne pristupy, lisi se jednoduchosti implementace ci rychlosti vyhledavani (vkladani),
    \item seznam (obsah souboru bude tvorena seznamem),
    \item B+ stromy (v NTFS, XFS, JFS, APFS nebo EXT3/4 - ty pouzivaji H-stromy: 1-2 urovne, bez vyvazovani a vyhledava se na zaklade zahashovaneho jmena)
    \item hashovaci tabulky v napr. ZFS \\
\end{itemize}

Soubor v UNIXu muze mit vice jmen. Dalsi jmena se vytvari pomoci prikazu ln \\

\textbf{linux:} \\[0.5em]
\textit{ln [existujici jmeno] [nove jmeno]} vytvori dalsi jmeno souboru \\

\newpage

\subsection{Montovani disku}
\textbf{Princip motnovani disku:}
\begin{itemize}
    \item v UNIXu neni zadne oznaceni disku (A:, C:, ..), ale mame jeden adresarovy "strom",
    \item v systemu je jeden korenovy logicky disk,
    \item dalsi logicke disky se pripojuji programem \textit{mount} do existujiciho adresaroveho stromu (korenovy adresar zarizeni se "slepi" s adresarem v mem stromu) \\
\end{itemize}

Pripojovaci volby se mohou zadavat rucne (v terminalu) nebo se mohou predpripravit do /etc/fstab. Soubor /etc/mtab obsahuje tabulku aktualne pripojenych disku. \\

\textbf{Novejsi technologie umoznuji automaticke montovani nove pripojenych zarizeni:}
\begin{itemize}
    \item na linuxu bezne pracuje system udev, ktery
    \item rozpozna, ze se pripojilo nove zarizeni,
    \item vytvori odpovidajici soubor typu blokove zarizeni (/dev/..),
    \item informuje o tom zbytek systemu pomoci sbernice D-Bus,
    \item aplikace typu spravce souboru pak muze provest automaticke montovani (a dalsi akce),
    \item prednost ma vzdy /etc/fstab,
    \item identifikace se nemusi provadet jen zarizenim (/dev/..), je mozne si vygenerovat unikatni identifikator a pouzivat ten (UUID) \\
\end{itemize}

\textbf{Technologie Automounter:}
\begin{itemize}
    \item subsystem jadra,
    \item pripojuje automaticky potrebne disky v situaci, kdy se pokusime pristoupit na pozici adresaroveho stromu, kam by takovyto disk mel byt pripojeny (napr. na /mnt ma byt pripojena flashka, nemusi byt mountla, uzivatel da cd /mnt, automounter to zjisti a pripoji flashku sem),
    \item ma take nejaky cas, po kterem disk automaticky odpoji, pokud se nim nepracuje  \\
\end{itemize}

\textbf{Union mount:}
\begin{itemize}
    \item technologie umoznujici sjednocujici montovani (v unixu dostupna pomoci filesystemu UnionFS),
    \item umoznuje do jednoho pripojneho bodu namontovat vice disku,
    \item obsah pripojneho bodu je sjednocenim obsahu disku,
    \item v pripade, ze na vice discich jsou soubory se stejnymi jmeny vznikaji kolize, ty se resi napr. preddefinovanim priorit pripojovanych filesystemu a zpristupni se soubor daneho jmena z logickeho disku, ktery ma nejvetsi prioritu
    \item UnionFS ma copy-on-write semantiku, coz umoznuje emulaci prepisovani neprepisovatelnych medii (v 1 vetvi CD, neprepisovatelne, na tom je linuxova distribuce, soucasne se do stejneho bodu pripoji bezny disk s vyssi prioritou - na zacatku bude disk prazdny, budou videt vsechny soubory z CD, jakmile se pokusim prepsat neco, UnionFS vytvori kopii na prepisovatelny disk) \\
\end{itemize}

\textbf{linux:} \\[0.5em]
\textit{mount [co-pripojit] [kam-pripojit]} pripoji logicky disk \\

\newpage

\section{}
\textbf{Sedma prednaska:} Pokracovani Spravy souboru. Symbolicke odkazy, 
\subsection{Symbolicke odkazy}
\begin{itemize}
    \item je samostatny soubor odkazujici na existujici soubor,
    \item system pri otevreni automaticky otevre cilovy souboru - vicenasobne zpracovani cesty (ceska k symlinku a cesta uvnitr nej),
    \item soubor se smaze, pokud jeho pocet jmen klesne na 0,
    \item symlink muze odkazovat na neexistujici soubor (pri otevreni dojde k chybe),
    \item muze odkazovat i na jiny logicky disk,
    \item lze ze symlinku vytvorit cyklkus (jeden odkazuje na druhy a druhy na prvni) - v systemy je preddefinovany maximalni pocet na sebe odkazujicich symlinku (pri prekroceni dojde k chybe),
    \item symlinky lze vyuzit napr. pri upgradu systemu. \\
\end{itemize}

\textbf{Rozdil rychlych/pomalych symlinku:}
\begin{itemize}
    \item obsahem symlinku je jmeno ciloveho souboru,
    \item pokud jmeno souboru neni prilis dlouhe (vleze se do i-uzlu), potom se ulozi do i-uzlu = rychly symlink (staci otevrit jen i-uzel),
    \item pokud se jmeno nezleve do (i-uzlu), alokuji se normalne alokacni bloky na disku = pomaly symlink \\
\end{itemize}

\textbf{linux:} \\[0.5em]
\textit{ln -s [existujici soubor] [symbolicky odkaz]} vytvori symbolicky odkaz \\

\newpage

\subsection{Blokove a znakove specialni soubory} \label{blok-char-hw}
Soubory reprezentujici rozhrani souboroveho systemu k fyzickym (opravdovy hw) ci virtualnim zarizenim (xterminaly, ..). Souborovy system vyvtari souborove rozhrani, tim umoznuje tyto soubory pri urcitych operacich identifikovat (jmeno soubory, napr. /dev/sdX), s celym zarizenim lze take pracovat jako se souborem. \\

Typicky zarizeni sidli v adresari /dev \\

\textbf{Bezne typy zarizeni:}
\begin{itemize}
    \item /dev/hda - (drive)oznaceni pro prvni fyzicky disk na prvnim ATA/PATA rozhrani
    \item /dev/hda1 - (drive) prvni logicky disk na hda
    \item /dev/sda - prvni fyzicky disk SCSI, navic i disky SATA/PATA (jadro nad temito disky emuluje SCSI)
    \item /dev/mem - obsah pameti (RAM)
    \item /dev/zero - nekonecny zdroj 0 bajtu
    \item /dev/null - soubor typu cerna dira - cokoli se do nej zapise, do se zahodi (presmerovani vystupu programu tak, aby nas neotravoval), pri cteni se tvari jako prazdny soubor
    \item /dev/random - generator nahodnych cisel
    \item /dev/tty - terminal
    \item /dev/lp0 - tiskarny
    \item /dev/mouse - mys
    \item /dev/dsp - zvukova karta
    \item /dev/loop - zarizeni typu (smycka) loop mi umoznuje pripojit soubor jako disk (obraz souboroveho systemu) k adresari, jakoby se jednalo o novy fyzicky disk \\
\end{itemize}

Tato oznaceni zavisi na pouzitem systemu (Linux, distribuce, ..). Vyhoda zavedeni specialnich souboru je, ze umoznuji identifikovat zarizeni, se kterymi chci pracovat. \\

\newpage

\subsection{Pristupova prava}
V UNIXu jsou typicky rozlisena na prava pro vlastnika, skupinu vlastniku a ostatni.
Existuje rozsireni ACL (access control list). \\

\textbf{Uzivatele:}
\begin{itemize}
    \item jsou definovani administratorem systemu (root) v /etc/passwd,
    \item maji definovana sva UID - uzivatelska cisla (root UID = 0),
    \item kazdy soubor ma sveho vlastnika,
    \item chown - zmena vlastnika souboru (pouze root), \\
\end{itemize}

\textbf{Skupiny:}
\begin{itemize}
    \item definuje administrator systeu v /etc/group,
    \item maji sva GID - cislo identifikujici skupinu uzivatelu,
    \item v kazde skupine je uvedeno, kdo do te skupiny patri,
    \item kazdy uzivatel muze byt clenem vice skupin,
    \item jedna z nich je aktualni (pouziva se pri vytvareni souboru) \\
\end{itemize}

\textbf{linux:} \\[0.5em]
\textit{groups} - vypis skupin uzivatele \\[0.2em]
\textit{chgrp} - zmena skupiny souboru \\[0.2em]
\textit{newgrp} - novy shell s jinym aktualnim GID \\

\newpage

\subsection{Typy pristupovych prav}
\textbf{Obycejne soubory:}
r, w, x - pravo cist, zapisovat a spustit soubor jako program. \\

\textbf{Adresare:}
\begin{itemize}
    \item r - pravo cist obsah adresare,
    \item w - pravo zapisovat (vytvaret a rusit soubory),
    \item x - pravo pristupovat k souborum v adresari (moznost cd adresar, ls -l adresar, ..) \\
\end{itemize}

\textbf{Typicky vystup pristupovych prav je:}
\begin{itemize}
    \item ve formatu: [1:typ souboru] [3:prava vlastnika] [3:prava skupiny] [3:prava ostatnich]
    \item napr.: -rwx---r-- (ciselne vyjadreni v 8 soustave 0704)
    \item je obycejny soubor, vlastnik ma vsechna prava, skupina zadna a ostatni maji prava na cteni \\
\end{itemize}

Zmena pristupovych prava se deje pomoci chmod. (Pro nespustitelne soubory je bezny chmod 0644). \\

\textbf{linux:}
\textit{chmod [1:pro koho][nova prava] [soubor/y]} zmena pristupovych prav \\

\subsection{Sticky bit}
Priznak, ktery pokud bude prirazen nejakemu adresari, tak se vytvori adresar, ve kterem i pres pravo cteni a zapisu souboru mohou uzivatele rusit pouze ty soubory, ktere sami vytvorili. (typicky adresar /tmp) (tldr: uzivatel muze mazat, ale pouze to co vlastni) \\

\subsection{SUID, SGID}
\textbf{S procesy jsou spojeny identifikatory jako jsou:}
\begin{itemize}
    \item UID - realna identifikace uzivatele (cislo uzivatele, ktery dany proces spustil)
    \item EUID - efektivni identifikator pouzivany pro kontrolu pristupovych prav (vetsinou stejne jako UID)
    \item GID - realna identifikace skupiny (kdo spustil proces)
    \item EGID - efektivni GID, (stejne chovani jako u EUID) \\
\end{itemize}

Vlastnik programu muze propujcit sva prava komukoliv, kdo spusti program s nastavenym SUID. (tldr: propujci se prava mezi uzivateli, bezne se to pouziva v pripadech, kdy administrator propujcuje sva prava uzivatelum, napr. passwd) \\

Pri pouziti SUID bude UID = uzivatele, ktery proces spustil a EUID = identifikace vlastnika (= ktery prava pujcil). Pokud budou prava propujcena (pouzito SUID), misto x se vypise s, pokud tam x neni, vypise se S. \\

\subsection{Typicka struktura adresaru v UNIXu}
\textbf{FHS - Filesystem Hierarchy Standard (Linux), (cast hierarchie):}
\begin{itemize}
    \item /bin - programy pro vsechny uzivatele (spustitelne, mohou byt zapotrebi pri bootovani - musi byt dostupne lokalne)
    \item /boot - soubory pro zavadec systemu (obrazy jadra, pocatecni fs)
    \item /dev - specialni soubory - rozhrani zarizeni
    \item /etc - konfiguracni soubory pro system i aplikace
    \item /home - domovske adresare uzivatelu
    \item /lib - sdielne knihovny a moduly jadra
    \item /media - pripojny bod pro prenosna zarizeni
    \item /mnt - pripojny bod pro docasne filesystemy
    \item /proc - informace o procesech a jadru
    \item /root - domovsky adresar superuzivatele
    \item /run - docasne informace o bezicim systemu (demony)
    \item /sbin - programy pro superuzivatele (nutne pro bootovani, ne vse je spustitelne superuzivatelem)
    \item /sys - informace o jadru, zarizenich, modulech, ..
    \item /tmp - docasne pracovni soubory (obsah se maze pri restartu)
    \item /usr - obsahuje dale adresare a
    \begin{itemize}
        \item soubory, ktere nejsou nutne pri zavadeni systemu, struktura je zde podobna jako u / :
        \item bin, sbin, lib,
        \item include (hlavickove soubory),
        \item share (soubory je mozne sdilet nezavisle na architekture),
        \item local (koren dalsi hierarchie urcena pro lokalni nestandardni instalace programu),
        \item src (zdrojove texty jadra)
    \end{itemize}
    \item /var - soubory menici se za behu systemu
    \begin{itemize}
        \item obsahuje log (zaznamy o cinnosti systemu), 
        \item spool (pomocne soubory pro tisk),
        \item mail (postovni prihradky uzivatelu) \\
    \end{itemize}
\end{itemize}

\newpage

\textbf{Nove tema: Datove struktury a algoritmy pro vstup/vystup}
\subsection{Pouziti vyrovnavacich pameti}
Cilem pouziti cache (vyrovnavacich pameti) je minimimalizace poctu pomalych operaci s periferiemi (disky). Hierarchie:
kolekce, sbirka dilcich vyrovnavacich pameti (s velikosti 1 alokacniho bloku, ci nasobku), nazyva se buffer-pool, muze mit pevnou velikost, spise je promenna. \\

\newpage

\subsection{Operace se soubory}

\subsubsection{Cteni}
\textbf{Prvni cteni alokacniho bloku:}
\begin{itemize}
    \item zjisti se, zda je blok v pameti,
    \item pokud ne, naalokuje se novy blok, muze se vyuzit jiz nejaky systemem predalokovany a nevyuzity,
    \item nactou se data z disku, presunou se do vyrovnavaci pameti,
    \item vyrovnavaci pamet je v prostoru jadra (bezne procesy zde nemaji pristup),
    \item vykousne se z nactenych dat tu cast, o kterou ma uzivatel/proces zajem,
    \item nakopiruje se to do adresoveho prostoru uzivatelskeho prostoru \\
\end{itemize}

\textbf{Pri dalsim cteni:}
\begin{itemize}
    \item nejprve se opet vyhleda, zda je blok v pameti,
    \item pokud ano,
    \item nebude se cist z disku, pouze se z alokacniho bloku vykousne cast, o kterou ma uzivatel/proces zajem,
    \item tato cast se uzivateli preda \\
\end{itemize}

\subsubsection{Zapis}

\textbf{Postup pri zapisu:}
\begin{itemize}
    \item nejprve se zjisti, zda je blok v pameti,
    \item pokud ne, prideli se vyrovnavaci pamet,
    \item nactou se data z disku do vyrovavaci pameti,
    \item jadro prevezme od procesu, ktery chce zapisovat data, ktera chce zapsat,
    \item prepise jimi danou cast alokacniho bloku, dirty bit se zmeni (0 na 1),
    \item operace konci (neprovede se zapis na disk),
    \item casem se provede zpozdeny zapis na disk a vynuluje se dirty bit \\
\end{itemize}

System sam od sebe s periodou prepisuje cache na disky, lze si to vynutit pomoci sync ci fsync. \\

Pokud je znamo, ze se prepise cely alokacni blok (nebo se jedna o novy blok), buffer se vynuluje a nenacitaji se data z disku do cache. \\


\textbf{definice:} \\[0.5em]
\textit{dirty bit} je indikator toho, jestli jsou data cache sladena s obsahem na disku (0 - data v cache = disk, 1 - data cache != data disk - nuluje se zpozdenym zapisem) \\

\subsubsection{Otevreni souboru pro cteni}
Pokud soubor jeste \textbf{nebyl otevren}:
\begin{itemize}
    \item system musi vyhodnotit cestu a naleznou cislo i-uzlu (resp. cislo datove struktury poskytujici informace o danem souboru - pristupova prava, kde jsou ulozena data),
    \begin{itemize}
        \item pri tom se postupne nacitaji i-uzly vsech adresaru vedouci na soubor,
        \item pote se nacte i-uzel souboru,
        \item system pouziva d-entry cache (specialni vyrovnavaci pamet pouzita pro preklad odpovidajicich jmen souboru na i-uzel) 
        \item dale alokuje polozku v tabulce V-uzlu,
    \end{itemize}
    \begin{itemize}
        \item z disku se nacte i-uzel,
        \item vlozi se do nove alokovane polozky = vznika rozsirena pametova kopie i-uzlu,
        \item budou tam i informace navic (jako je pocet odkazu na danou polozku - danym i-uzlem muze pracovat vice procesu).
    \end{itemize}
    \item v tabulce popisovacu vytvorime novou polozku,
    \begin{itemize}
        \item tato tabulka je ulozena v zaznamu o procesu (tabulka procesu v jadre) nebo v uzivatelske oblasti,
        \item pouzije se nejnizsi volna polozka zde,
        \item naplni se odkazem na polozku v tabulce otevrenych souboru,
    \end{itemize}
    \item pokud se otevreni vydari, vrati se cislo popisovace, pokud ne, tak vraci -1. \\
\end{itemize}

Tolik tabulek se pouziva pro zamezeni duplikaci udaju. Behem otevirani se provadi kontrola pristupovych prav. Soubor je mozne otevrit v rezimu pro cteni, zapis, cteni i zapis. \\

Dalsi otevreni souboru (\textbf{jiz jednou otevreny}):
\begin{itemize}
    \item opet se vyhodnoti cesta k souboru a ziska se cislo i-uzlu,
    \item system se podiva do tabulku V-uzlu,
    \item zjisti, ze i-uzel uz tam je,
    \item nebude se znovu i-uzel nacitat z disku, pouze se zvysi citac pouziti i-uzlu,
    \item tabulka V-uzlu musi byt vyhledavaci (typicky vyhledaci struktury jako hash tabulka, strom, ..),
    \item naalokuje se nova polozka v tabulce otevreni (naplni se rezimem otevreni, pozici, odkazem na sdileny V-uzel),
    \item naalokuje se nove poloza ve file descriptoru ukazujici na nove otevreni (a ta se vrati) \\
\end{itemize}

\newpage

\textbf{Je mozne pridavat i dalsi identifikatory, napr.:}
\begin{itemize}
    \item priznak, ze ma byt soubor vytvoren pokud neexistuje,
    \item pokud existuje, ma byt zkracen na 0,
    \item otevrit v rezimu pridavani (kdekoli je aktualne ukazovatko v souboru, tak v pripade zapisu se automaticky posune na konec a tam se prida),
    \item synchronni zapis (operace zapisu skonci az tehdy, kdyz se data zapisou opravdu na disk) \\
\end{itemize}

\textbf{Pri chybe:}
\begin{itemize}
    \item open vraci -1,
    \item nastavi se chybovy kod, ktery blize popisuje co se stalo (do knihovni promenne errno),
    \item existuji standardni chybove kody,
    \item lze pouzit standardni knihovni funkci perror \\
\end{itemize}

\textbf{linux:} \\[0.5em]
\textit{fd = open([jmeno souboru], [rezim]);} otevre soubor \\[0.2em]
\textit{V-uzly} je tabulka i-uzlu filesystemu VFS \\[0.2em]
\textit{tabulka popisovacu} je pole s radky cislovanymi od 0 (0 - stdin, 1 - stdout, 2 - stderr) \\[0.2em]
\textit{tabulka procesu} v jadre je cast adresoveho prostoru, ve kterem ma jadro ulozene pomocne informace k procesum a ma sem pristup pouze jadro \\[0.2em]

\subsubsection{Cteni a zapis z/do souboru}
\textbf{Cteni:}
\begin{itemize}
    \item zkontroluje se platnost popisovace (otevreni popisovace, soubor pro cteni),
    \item pokud se jedna o prvni pristup, naalokuje se cache, nactou se data do cache a z cache se prislusna data pouziji,
    \item pokud uz jsou data v cache, nactou se odtud,
    \item predani se deje pozadovanych z cache (RAM, jadro) do pole (RAM, cache adresoroveho prostoru procesu),
    \item funkce vraci pocet opravdu prectenych bajtu nebo -1 pri chybe (+ nastavi errno). \\
\end{itemize}

\textbf{Zapis:}
\begin{itemize}
    \item funguje podobne jako read,
    \item pred vlastnim zapisem kontroluje dostupnost diskoveho prostoru a tento prostor alokuje (rezervuje),
    \item vraci pocet opravdu zapsanych bajtu nebo -1 \\
\end{itemize}

\newpage

\textbf{linux:} \\[0.5em]
\textit{read([popisovac], [adresa pameti, kam se ma zapsat], [kolik bajtu se ma nacist])} precte soubor \\[0.2em]
\textit{write ([popisovac], [adresa pameti, ze ktere se nactou data], [kolik bajtu se zapise])} zapis do souboru \\

\subsubsection{Primy pristup k souboru}
Nahodne presouvani v souboru. \textbf{Postup:}
\begin{itemize}
    \item zkontroluje zda je popisovac platny (je soubor otevren?)
    \item nastavi pozici offset bajtu od whence
    \begin{itemize}
        \item SEEK\_SET - napr. 200 - posunu se od 200 bajtu od zacatku,
        \item SEEK\_CUR - od aktualni pozice,
        \item SEEK\_END - od konce souboru),
    \end{itemize}
    \item nelze se posunou pred zacatek souboru,
    \item je ale mozne se posunout za konec souboru (a zapsat),
    \item vraci se vysledna pozice od zacatku souboru nebo -1 \\
\end{itemize}

Posunem za konec souboru a naslednym zapisem vznikaji tzv. ridke soubory (sparse files):
\begin{itemize}
    \item umoznuje na disku o nejake kapacite vytvorit soubor, ktery ma zdanlive vetsi velikost nez samotny disk,
    \item bloky do kterych se nezapisovalo nejsou alokovany a nezabiraji diskovy prostor (pri cteni se povazuji za 0),
    \item take muze vzniknout mazanim uprostred souboru (hole punching) \\
\end{itemize}

\begin{figure} [h]
    \centering
    \scalebox{2}{\includegraphics{7.9.5.jpg}} \\
    \caption{z prezentace IOS: Sprava souboru - ridke soubory} 
\end{figure}

\textbf{linux:} \\[0.5em]
\textit{lseek([popisovac souboru], [offset], [oproti cemu se chci posouvat])} primy pristup k souboru \\

\newpage

\subsubsection{Zavreni souboru}
\begin{itemize}
    \item zkontroluje se platnost file descriptoru (je vubec otevreny?),
    \item uvolni se dana polozka v tabulce popisovacu,
    \item system se podiva na odkazovanou polozku v tabulce otevrenych souboru,
    \item snizi se pocitadlo o 1,
    \item pokud bude pocitalo != 0, uzavirani skonci,
    \item pokud bude pocitadlo == 0, pokracuje se do 
    \item prislusne polozky tabulky V-uzlu, snizi se zde pocitadlo o 1,
    \item pokud bude zde pocitadlo != 0, uzavreni skonci,
    \item pokud bude zde == 0, soubor se definitivne uzarve,
    \item uvolni se z pameti i-uzel z tabulky V-uzlu (se zmenenymi udaji - cas zapisu, pristupu, modifikace i-uzlu, ..),
    \item naplanuje se blok, ve kterem je i-uzel ulozen,
    \item casem se i-uzel zapise na disk,
    \item funkce vraci 0 nebo -1 pri chybe \\
\end{itemize}

Pokud se proces skonci, automaticky se zavrou vsechny jeho deskriptory. Uzavreni souboru nezpusobi ulozeni obsahu jeho vyrovnavaci pameti na disk. \\

\textbf{linux:} \\[0.5em]
\textit{close([popisovac souboru])} zavre soubor \\

\subsubsection{Duplikace deskriptoru souboru}
\begin{itemize}
    \item zkontroluje se platnost deskriptoru (je soubor otevren?),
    \item zkopiruje obsah puvodniho popisovace do noveho (odkaz ve fd tabulce se zkopiruje do dalsi polozky v teto tabulce - oboje ukazuji na stejnou polozku tabulky otevrenych souboru + inkrementuje se pocitadlo), 
    \item automaticky se novy deskriptor uzavre (pokud je otevren),
    \item vraci index nove vytvorene polozky nebo -1,
    \item typicke pouziti je u presmerovani (stdin/stdout) \\
\end{itemize}

\textbf{linux:} \\[0.5em]
\textit{dup([popisovac])} duplikace deskriptoru (duplikuje existujici popisovac do nejvyssiho volneho noveho) \\[0.2em]
\textit{dup2([popisovac], [novy popisovac])} duplikace deskriptoru (do ktereho popisovace se duplikuje) \\

\subsubsection{Ruseni souboru}
\begin{itemize}
    \item vyhodnoti se cesta, zkontroluje se platnost jmena souboru, pristupova prava (zapis),
    \item odstrani se pevny odkaz (=hard link) mezi jmenem souboru a i-uzlem,
    \item zmensi se pocet jmen v i-uzlu,
    \item pokud je pocet jmen == 0 a i-uzel nikdo nepouziva - i-uzel muze byt uvolnen a mohou byt uvolneny vsechny bloky souboru,
    \item dokud ma soubor alespon 1 jmeno nebo nema zadne jmeno ale je otevren alespon 1x, nelze soubor z disku opravdu smazat,
    \item funkce vraci 0 nebo -1 pri chybe \\
\end{itemize}

Je mozne provest unlink na otevreny soubor (smaze se az po jeho uzavreni) a pracovat s nim dale,
vyuziti pri instalacich novych verzich programu, ktere aktualne bezi. (upgradovat upgradovaci program) \\

\textbf{linux:} \\[0.5em]
\textit{unlink([jmeno soubor, prip. cesta])} rusi soubor \\[0.2em]
\textit{shred} - bezpecne mazani \\

\subsubsection{Dalsi operace se soubory}

\textbf{linux:} \\[0.5em]
\textit{creat, open} - vytvoreni souboru \\[0.2em]
\textit{rename} - prejmenovani souboru \\[0.2em]
\textit{truncate, ftruncate} - zkraceni souboru \\[0.2em]
\textit{fcntl, lock} - zamykani zaznamu \\[0.2em]
\textit{chmod, chown} - zmena atributu \\[0.2em]
\textit{utime} - umoznuje zmenit casy prace se soubory (neumoznuje zmenit cas modifikace i-uzlu) \\[0.2em]
\textit{stat} - ziskani atributu (velikost, prava, ..) \\[0.2em]
\textit{sync, fsync} - vynuceni si zapisu vyrovnavacich pameti \\

\subsubsection{Adresarove soubory}
Obsahuje dvojice cislo i-uzlu a jmena souboru. Adresare nelze zapisovat ci cist po bajtech.

\textbf{linux:} \\[0.5em]
\textit{mkdir} - tvori se adresare (vytvori polozky . a ..) \\[0.2em]
\textit{opendir} - otevre adresar \\[0.2em]
\textit{readdir} - cte adresar \\[0.2em]
\textit{closedir} - zavre adresar \\[0.2em]
\textit{creat, link, unlink} - modifikace se provadi neprimo vytvarenim/modifikacemi souboru \\

\subsubsection{Blokove a znakove specialni soubory}
Predstavuji rozhrani k blokovym / znakovym zarizenim (/dev/..., viz. \ref{blok-char-hw})
\begin{itemize}
    \item lze je vytvorit pomoci mknod,
    \item typicky tyto soubory vytvari jadro ci demoni (udev, devd - pri pripojeni zarizeni se vytvori automaticky prislusny soubor) \\
\end{itemize}

Pri pouziti beznych souborovych operaci jadro mapuje operace na odpovidajici podprogramy, ktere ty operace implementuji pro dany typ zarizeni s vyuzitim \textbf{tabulek}:
\begin{itemize}
    \item znakovych zarizeni,
    \item blokovych zarizeni \\
\end{itemize}

Tyto tabulky obsahuji ukazatele na funkce implementujici prislusne operace v ovladacich danych zarizeni. \\

Specialni soubory na disku zabiraji \textbf{pouze i-uzel, krome beznych udaji maji v i-uzlu typ souboru a 2 udaje}:
\begin{itemize}
    \item hlavni cislo,
    \begin{itemize}
        \item major number,
        \item udava typ zarizeni
        \item odkazuje do tabulky zarizeni (hlavni cislo = n-ty radek tabulky),
    \end{itemize}
    \item vedlejsi cislo 
    \begin{itemize}
        \item minor number, 
        \item udava instanci zarizeni
        \item pouziva se jako parametr pri volani urcite operace - parametr funkce ovladace (cislo = ktere zarizeni se ma presne pouzit)
    \end{itemize}
    \item typ souboru urcuje tabulku (blok, znak.) \\
\end{itemize}

\textbf{linux:} \\[0.5em]
\textit{mknod} vytvori specialni soubory \\[0.2em]
\textit{ovladac} je sada podprogramu pro rizeni urciteho typu zarizeni (nebo viz xx nebo viz xx) \\

\newpage

\subsection{Terminaly}
Jsou fyzicka ci logicka zarizeni umoznujici (primarne) textovy vstup a vystup systemu (po radcich), editace vstupniho radku ci specialni znaky (Ctrl+C SIGINT, Ctrl-D konec vstupu, ..) \\

\textbf{Rozhrani:}
\begin{itemize}
    \item /dev/tty - pro kazdy proces, ktery ma ridici terminal, odkazuje na jeho ridici terminal
    \item /dev/ttyS1 - fyzicke terminaly na seriove lince,
    \item /dev/tty1 - virtualni terminaly (konzole),
    \item pseudoterminaly (/dev/ptmx - master, /dev/pts/1,..) tvoreny dvojici master / slave, po kazdem otevrenim se vytvori novy slave - emuluje komunikaci pres seriovou linku (umoznuje pro propojeni urcitych casti, napr. SSH - propojeni klienta se vzdalenym klientem) \\
\end{itemize}

\textbf{Ruzne rezimy zpracovani znaku} (radkove discipliny - line discipline):
\begin{itemize}
    \item raw - neprovadi se zpracovani znaku,
    \item cooked - zpracovani vsech ridicich znaku,
    \item cbreak - provadi zpracovani maleho poctu znaku (ctrl+c, mazani, ..) \\
\end{itemize}

Nastaveni rezimu zpracovani znaku je mozne pomoci stty. Dale je mozne nastavit \textbf{rezim terminalu}:
\begin{itemize}
    \item prikazy tset, tput, reset,..
    \item promennou TERM, ve ktere ulozen aktualni typ terminalu,
    \item typy terminalu (prikazy terminfo, termcap) \\
\end{itemize}

Tyto prikazy komunikuji s terminalem pomoci \textit{escape sekvenci}. Knihovna curses je standardni knihovna pro rizeni terminalu ci tvorbu aplikaci s terminalovym uzivatelskym rozhranim. \\

\textbf{definice:} \\[0.5em]
\textit{escape sekvence} jsou sekvence znaku escape, prikaz [parametry], escape, prikaz, .. \\

\newpage

\subsection{Roury}
Jsou prostredkem meziprocesove komunikace. Rozlisujeme: \\

\textbf{Nepojmenovane roury}
\begin{itemize}
    \item nemaji adresarovou polozku, tedy neexistuji v souborovem systemu,
    \item lze s nimi pracovat pouze tak, ze se vytvori pomoci volani pipe (vrati cteci a zapisovy deskriptor), jakmile dojde k uzavreni - prace s rourou konci,
    \item mohou s ni pracovat bezne pouze pribuzne procesy,
    \item je dostupna pomoci popisovacu z tabulky popisovaci (pri klonu procesu se naklonuje tabulka popisovaci - proces bude ukazovat na stejne misto v tabulce otevrenych souboru),
    \item jedina vyjimka, jak je mozne odkaz na nepojmenovanou rouru predat je pres UNIXove sockety (krome klonovani procesu),
    \item vytvari se v kolonach (napr. paralelne bezici procesy p1 | p2 | p3 - na presmerovani se pouzivaji nepojmenovane roury) \\
\end{itemize}

\textbf{Pojmenovane roury}
\begin{itemize}
    \item vyvtari se pomoci mknod is mkfifo,
    \item existuji v souborovem systemu,
    \item mohou se zavrit, otevrit, apod. \\
\end{itemize}

Roury slouzi jako mechanismus meziprocesove komunikace. Implementovane jako kruhovy buffer s omezenou kapacitou. Procesy komunikujici pres rouru jsou synchronizovany. \\

\textbf{definice:} \\[0.5em]
\textit{pribuzne procesy} - pokud jeden proces otevre rouru a zacne se klonovat, vsechny tyto procesy mohou s rourou pracovat \\[0.2em]
\textit{konzumenti} - procesy, ktere ctou \\[0.2em]
\textit{producenti} - procesy, ktere zapisuji \\

\subsection{Sockety}
TUDU


\end{document}
